MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001     title "ME2700 Programmer Firmware Rev 1.03"
                      00002     subtitle "Copyright (C) 2016 Martin Eberhard"
                      00003     list b=4, c=132, n=80
                      00004 ;********************************************************************************
                      00005 ;* ME2700 Programmer Firmware                                                   *
                      00006 ;*                                                                              *
                      00007 ;*Revision History                                                              *
                      00008 ;*  1.00  3 November 2015   M. Eberhard                                         *
                      00009 ;*      Created                                                                 *
                      00010 ;*  1.01  20 January 2016  M. Eberhard                                          *
                      00011 ;*      First released version                                                  * 
                      00012 ;*  1.02  2 February 2016  M. Eberhard                                          *
                      00013 ;*      Add ASCII to BD printout, slight help menu improvements. Default to the *
                      00014 ;*      EPROM size for UI & US, if no count parameter provided.                 *
                      00015 ;*  1.03  4 October 2016  M. Eberhard                                           *
                      00016 ;*      Reset stack pointer at main to prevent overflows on several ^Cs         *
                      00017 ;********************************************************************************
                      00018 ; Major revision must change if the firmware is not fully compatable with       *
                      00019 ; previous revisions.                                                           *
                      00020 ;********************************************************************************
  00000001            00021 REV_MAJOR           equ 0x01    ;major revision number. Max = 9
  00000003            00022 REV_MINOR           equ 0x03    ;minor revision number. Each nibble: max = 9
                      00023 
                      00024 ;TO DO (Maybe)
                      00025 ;deal with 4-bit (and maybe 1-bit) EPROMs
                      00026 
                      00027 ;********************************************************************************
                      00028 ; Specify the required Kernel Loader revision level. An error message will be   *
                      00029 ; printed if this does not match the kernel in FLASH.                           *
                      00030 ;********************************************************************************
  00000010            00031 REQUIRED_KERN_REV   equ 0x10    ;only the most significant nibble counts
                      00032 
                      00033 ;********************************************************************************
                      00034 ;*                              GENERAL NOTES                                   *
                      00035 ;* This program assumes the PIC is clocked at 16 MHz, meaning a 4 MHz CPU       *
                      00036 ;* operating speed, or 0.25 uS instruction cycle time. The internal oscilator   *
                      00037 ;* has an accuracy of +/- 2% (page 369), which must be considered in all timing.*
                      00038 ;*                                                                              *
                      00039 ;* Page references in the comments refer to the appropriate pages in Microchip  *
                      00040 ;* document DS40001303H "PIC18F2XK20/4XK20 28/40/44-Pin Flash Microcontrollers  *
                      00041 ;* with XLP Technology"                                                         *
                      00042 ;*                                                                              *
                      00043 ;* The "Kernel" is actually just the firmware loader, together with a           *
                      00044 ;* collection of primitive subroutines. This code is protected by hardware      *
                      00045 ;* against being overwritten by a firware load. The minimum protectable size    *
                      00046 ;* for this particular PIC is 2K, which was far more than needed for the        *
                      00047 ;* firmware loader itself. For this reason, most of the basic I/O routines and  *
                      00048 ;* routines for acessing EEPROM and the external SRAM were put in the Kernel.   *
                      00049 ;* See the file KernelMemory.inc for kernel subroutines.                        *
                      00050 ;*                                                                              *
                      00051 ;* Note that FSR2 is owned by the Kernel interrupt service routines, and should *
                      00052 ;* not be used here unless interrupts are masked.                               *
                      00053 ;*                                                                              *
                      00054 ;* See Help messages for commands and their operation.                          *
                      00055 ;********************************************************************************
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  2
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00056     page
                      00057 ;********************************************************************************
                      00058 ;* Include standard header and programmer header, and macros                    *
                      00059 ;********************************************************************************
  000000FF            00060 TRUE    equ 0xff
  00000000            00061 FALSE   equ 0
  00000000            00062 DEBUG   equ FALSE
                      00063 
                      00064     #include    P18F45K20.INC
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ;  MPASM PIC18F45K20 processor include
                      00005 ; 
                      00006 ;  (c) Copyright 1999-2011 Microchip Technology, All rights reserved
                      00007 ;==========================================================================
                      00008 
                      01568         LIST
                      00065     #include    ASCII.inc
                      00013     list
                      00066     #include    18FKernelMemory.inc
                      00001 ;****************************************************************************
                      00002 ;* RAM Usage: RAM allocations are assigned to be compatible with the EPROM  *
                      00003 ;* programmer firmware.                                                     *
                      00004 ;****************************************************************************
                      00005 
                      00006 ;Code Space assignments (from Kernel)
  00000002            00007 K_KERN_REV      equ 0x0002  ;return kernal loader major rev and minor rev in high & low nibbles of W
  00000004            00008 K_PROG_ID       equ 0x0004  ;return programmer ID in W. 00 for now.
  0000000A            00009 K_CONIN         equ 0x000A  ;get one chr from Rx Queue into W & R0. Z set if empty. Trashes FSR0.
  0000000C            00010 K_CONOUT        equ 0x000C  ;print W (returns chr in R0 unless chr was CR. Trashes FSR0.)
  0000000E            00011 K_PRINTF        equ 0x000E  ;print 0-terminated string at TBLPTRH:TBLPTRL. Trashes R0,FSR0,TBLPTR
  00000010            00012 K_EEPRINT       equ 0x0010  ;print 0-terminated string from EEPROM at EEADR, Trashes R0,FSR0,READR
  00000012            00013 K_PRINTHEX1     equ 0x0012  ;print low nibble of W as 1 hex chr. trashes R0,FSR0
  00000014            00014 K_PRINTHEX2     equ 0x0014  ;print W as 2 hex chrs. Trashes R0,R1,FSR0
  00000016            00015 K_PRINTDEC      equ 0x0016  ;print R1:R0 in decimal, leading zeros suppressed. Trash W,R0,R1,R2,FSR0,PRO
                            DH,PRODL
  00000018            00016 K_PRINTSN       equ 0x0018  ;print this unit's serial number. Trashes FSR0.
  0000001A            00017 K_HEX2BIN       equ 0x001A  ;Convert hex value in R0 to binary, combine it with R1. Trashes FSR0.
  0000001C            00018 K_GETLIN        equ 0x001C  ;Get W-byte null-terminated input line from user. Returns FSR1= LINBUF
  0000001E            00019 K_PARSE         equ 0x001E  ;Search cmd table at TBLPTR for cmd at FSR0, return W=cmd index
  00000020            00020 K_GETCHR        equ 0x0020  ;Get next LINBUF chr at FSR1. Result in W and R0
  00000022            00021 K_GETUCHR       equ 0x0022  ;Get next LINBUF chr at FSR1 and convert to uppercase. Result in W & R0
  00000024            00022 K_GETDEC        equ 0x0024  ;Get 8-bit decimal value from LINBUF at FSR1. Result in W & PRODL. Trash R0
  00000026            00023 K_GETHEX2       equ 0x0026  ;Get 2-digit hex, result in W & R1, sum in CHECKSUM, Z set if CHECKSUM=0
  00000028            00024 K_GETHEX4       equ 0x0028  ;Get 4-digit hex value from LINBUF at FSR1. Result in R2:R1. Trash W,R0
  0000002A            00025 K_ASKYN         equ 0x002A  ;ask user Y/N. Z set if Y, cleared if N. Trashes FSR0.
  0000002C            00026 K_CHKABORT      equ 0x002C  ;Check for user abort. Z if no chr, C if abort, chr in W and R0
  0000002E            00027 K_RDSRAM        equ 0x002E  ;read SRAM byte at ADDRESSH:ADDRESSL, Result in W, trash R0
  00000030            00028 K_WRSRAM        equ 0x0030  ;write W to SRAM at ADDRESSH:ADDRESSL. Trashes W R0,R1
  00000032            00029 K_RDEEPROM      equ 0x0032  ;read EEPROM byte at address W, result in W. Sets EEADR to EEPROM address.
  00000034            00030 K_WREEPROM      equ 0x0034  ;write W to EEPROM at address EEADR
                      00031 ;2 slots reserved here
  0000003A            00032 K_STALL25M      equ 0x003A  ;stall for W * 25 mSec (trashes R0,R1
  0000003C            00033 K_STALL250U     equ 0x003C  ;stall for W * 250 uSec (trashes R0)
  0000003E            00034 K_STALL1U       equ 0x003E  ;stall for W + 1 uSec
                      00035 
  00000800            00036 LOADED_CODE     equ 0x800       ;beginning of main programmer code
                      00037 
                      00038 ;*--------------------------------------------------------------*
                      00039 ;* Access RAM usage (visible from every bank)                   *
                      00040 ;* Those entries marked with (K) are fixed locations that are   *
                      00041 ;* accessible from the downloaded firmware.                     *
                      00042 ;* Those marked with (I) are used by the interrupt service      *
                      00043 ;* routines.                                                    *
                      00044 ;*--------------------------------------------------------------*
  00000000            00045 RQ_IPTR     equ 0x00        ;(K)(I)points to first empty slot in receive queue
                      00046                             ;(Written only by Rx interrupt!)
  00000001            00047 RQ_OPTR     equ 0x01        ;(K)(I)points to oldest chr in receive queue
  00000002            00048 TQ_IPTR     equ 0x02        ;(K)(I)points to first empty slot in transmit queue
  00000003            00049 TQ_OPTR     equ 0x03        ;(K)(I)points to oldest chr in transmit queue
                      00050                             ;(Written only by Tx interrupt!)
  00000004            00051 CHECKSUM    equ 0x04        ;checksum for current hex record
  00000005            00052 ADDRESSL    equ 0x05        ;address low byte
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  3
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000006            00053 ADDRESSH    equ 0x06        ;address high byte
  00000007            00054 RECOUNTL    equ 0x07        ;low byte of count of hex records
  00000008            00055 RECOUNTH    equ 0x08        ;high byte of count of hex records
  00000009            00056 ERRCNTL     equ 0x09        ;16-bit error counter
  0000000A            00057 ERRCNTH     equ 0x0A
                      00058 
  0000000B            00059 INT_FLAGS   equ 0x0B        ;(K)(I)flags used by int service routines and kernel routines
  00000000            00060 XOFF_STATE      equ 0x00        ;(K)transmitter stopped due to XOFF state
  00000001            00061 TQ_EMPTY        equ 0x01        ;(K)tx queue is empty
  00000002            00062 PREV_CR         equ 0x02        ;(K)Previous received chr was a CR (used by rx int)
  00000003            00063 PREV_LF         equ 0x03        ;(K)Previous received chr was a LF (used by rx int)
  00000004            00064 RQ_FULL         equ 0x04        ;(K)Receive queue full
                      00065 
  0000000C            00066 KERN_FLAGS  equ 0x0C        ;(K)flags used by int service routines and kernel routines
  00000000            00067 ERR_FLAG        equ 0x00        ;(K)generic error flag
  00000001            00068 FLASH_MEM       equ 0x01        ;'FLASH memory has been selected' state bit (only during code load)
  00000001            00069 INP_FLAG        equ 0x01        ;(K)input value found (never during code load)
  00000002            00070 ECHO_FLAG       equ 0x02        ;(K)Echo enabled when set
  00000003            00071 CR_FLAG         equ 0x03        ;(K)CR detected in LINBUF
                      00072 
  0000000D            00073 R0              equ 0x0D        ;general purpose registers
  0000000E            00074 R1              equ 0x0E
  0000000F            00075 R2              equ 0x0F        ;Other header files assume that R2 is the last one
                      00076 
                      00077 ;*--------------------------------------------------------------*
                      00078 ;* Linear-memory buffers                                        *
                      00079 ;* Those entries marked with (K) are fixed locations that are   *
                      00080 ;* accessible by from the downloaded firmware.                  *
                      00081 ;* The PIC18F44K20 has 768 bytes of SRAM. The first 96 bytes    *
                      00082 ;* map to the Access Bank.                                      *
                      00083 ;*--------------------------------------------------------------*
                      00084 ;Input line buffer
  00000060            00085 LINBUF          equ     .96                 ;just past the Access Bank
  00000050            00086 MAXLIN          equ     .80                 ;max input line size
                      00087 
                      00088 ;transmit queue (must be on (TQ_SIZE*2)-byte boundary)
  000000E0            00089 TX_QUEUE        equ     0xE0                ;(K) 16-byte transmit queue
  00000010            00090 TQ_SIZE         equ     0x10
                      00091 
                      00092 ;receive buffer (must be on RQ_SIZE-byte boundary)
  00000100            00093 RX_QUEUE        equ     0x100               ;(K) 256-byte receive buffer
  00000100            00094 RQ_SIZE         equ     0x100
                      00095 
                      00096 ;General purpose RAM buffer, used during code load here 
  00000200            00097 RAM_BUF         equ     0x200           ;(must be on 256-byte boundary)
  00000100            00098 RAMBUF_SIZ      equ     0x100           ;256-byte RAM buffer
                      00099 
                      00100 ;*--------------------------------------------------------------*
                      00101 ;* Internal EEPROM allocation                                   *
                      00102 ;*--------------------------------------------------------------*
  00000000            00103 EE_INIT         equ     0x00                    ;initialized string
  00000014            00104 EE_INITLEN      equ     .20                     ;Room for loader_msg
                      00105 
  00000014            00106 EE_SN           equ     EE_INIT+EE_INITLEN      ;Serial number
  00000008            00107 EE_SNLEN        equ     .8                      ;Length of serial number
                      00108 
  0000001C            00109 EE_VARBEG       equ     EE_SN+EE_SNLEN          ;beginning of variables
  000000E4            00110 EE_VARLEN       equ     .256-EE_VARBEG          ;room for variables
                      00111 
                      00112 
                      00113 
                      00067     #include    EPROMStructure.inc
                      00001 ;********************************************************************************
                      00002 ; EPROM Configuration Table Data Structure
                      00003 ;
                      00004 ; For inbuilt EPROM definitions, ET_NAME and all the PARTNO's are compressed
                      00005 ; pointers to strings in Flash. For custom EPROMs (stored in the PIC's onboard
                      00006 ; EEPROM), ET_NAME is the null-terminated name string itself, and PARTNOs,
                      00007 ; custom Vcc messages, and custom Vpp messages are not supported.
                      00008 ; Numbers in <angle braces> are bit numbers.
                      00009 ;********************************************************************************
                      00010 
  00000000            00011 ET_NAME         equ     0                   ;Pointer to EPROM name string
                      00012                                             ;(The high byte is reserved and should be 0FFh)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  4
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000002            00013 ET_PARTNO1      equ     ET_NAME+2           ;1st byte is manufacturer string, 2nd byte is part number st
                            ring
  00000004            00014 ET_PARTNO2      equ     ET_PARTNO1+2
  00000006            00015 ET_PARTNO3      equ     ET_PARTNO2+2
  00000008            00016 ET_PARTNO4      equ     ET_PARTNO3+2
  0000000A            00017 ET_PARTNO5      equ     ET_PARTNO4+2
  0000000C            00018 ET_PARTNO6      equ     ET_PARTNO5+2
  0000000E            00019 ET_PARTNO7      equ     ET_PARTNO6+2
  00000010            00020 ET_PARTNO8      equ     ET_PARTNO7+2
  00000012            00021 ET_PARTNO9      equ     ET_PARTNO8+2
  00000014            00022 ET_PARTNO10     equ     ET_PARTNO9+2
                      00023 
                      00024                                         ;The following 2 string pointers overlap ET_PARTNO10
  00000014            00025 ET_VCCMSG       equ     ET_PARTNO10     ;Pointer to Vcc adjustment string
  00000015            00026 ET_VPPMSG       equ     ET_VCCMSG+1     ;Pointer to Vpp adjustment message
                      00027 
  00000016            00028 ET_BYTES        equ     ET_VPPMSG+1         ;<7:4> = bits/byte
                      00029                                             ;<3> reserved
                      00030                                             ;<2:0> = Bytes/EPROM
                      00031                                             ;  0: 256
                      00032                                             ;  1: 512
                      00033                                             ;  2: 1024
                      00034                                             ;  3: 2048
                      00035                                             ;  4: 4096
                      00036                                             ;  5: 8192
                      00037 
                      00038 ;For the following EPROM signal assignments, pin numbers are encoded as follows:
                      00039 ;           0x00: none
                      00040 ;           0x01: pin 18
                      00041 ;           0x02: pin 19
                      00042 ;           0x03: pin 20
                      00043 ;           0x04: pin 21
                      00044 ;           0x05: pin 22
                      00045 ;           0x06: pin 23 (which is actually not used here, since code always assumes pin 23 is A8)
                      00046 
  00000017            00047 ET_A9A10        equ     ET_BYTES+1          ;<7> reserved
                      00048                                             ;<6:4> = A9 pin
                      00049                                             ;<3> reserved
                      00050                                             ;<2:0> = A10 pin
                      00051 
  00000018            00052 ET_A11A12       equ     ET_A9A10+1          ;<7> = 1 means force A11 high always
                      00053                                             ;<6:4> = A11 pin
                      00054                                             ;<3> = 1 means this is the -Address Strobe pin
                      00055                                             ;<2:0> = A12 pin
                      00056 
  00000019            00057 ET_OECS         equ     ET_A11A12+1         ;<7> = 1 means -OE=+12V while programming (pin 20 only)
                      00058                                             ;<6:4> = -OE pin (always active low)
                      00059                                             ;<3> = 1 means active-high CS pin
                      00060                                             ;<2:0> = CS pin
                      00061 
  0000001A            00062 ET_PGMVPP       equ     ET_OECS+1           ;<7> = 1 means active-high PGM pin
                      00063                                             ;<6:4> = PGM pin
                      00064                                             ;<3> reserved
                      00065                                             ;<2:0> = Vpp pin    
                      00066 
  0000001B            00067 ET_VBBVDD       equ     ET_PGMVPP+1         ;<7:6> Reserved
                      00068                                             ;<5> = Vdd assignment (pin 19):
                      00069                                             ;   0: none
                      00070                                             ;   1: pin 19 = +12V Vdd
                      00071                                             ;<4> = Vbb assignment (pin 21):
                      00072                                             ;   0: none
                      00073                                             ;   1: Pin 21 = -5V Vbb
                      00074                                             ;<3> reserved
                      00075                                             ;<2:0> = Vcc voltage during programming
                      00076                                             ;   0: 0V
                      00077                                             ;   1: +5V
                      00078                                             ;   2: +6.25V
                      00079                                             ;   3: +12V
                      00080 
  0000001C            00081 ET_VPPSETUP     equ     ET_VBBVDD+1         ;<7> reserved
                      00082                                             ;<6:4> = Vpp programming voltage:
                      00083                                             ;   0: Off
                      00084                                             ;   1: 12.75V
                      00085                                             ;   2: 13.15V
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  5
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00086                                             ;   3: 21V
                      00087                                             ;   4: 25V or 26V
                      00088                                             ;   5: use external negative supply
                      00089                                             ;<3> reserved
                      00090                                             ;<2> = Vpp level during reading
                      00091                                             ;  0 = 0V
                      00092                                             ;  1 = +5V
                      00093                                             ;<1:0> = programming pulse type:
                      00094                                             ;      00 = high-voltage pulse on Vpp pin, return to 0V
                      00095                                             ;      01 - high-voltage pulse on Vpp pin, return to +5V
                      00096                                             ;      10 = digital pulse on PGM pin
                      00097 
  0000001D            00098 ET_PROGREPS     equ     ET_VPPSETUP+1       ;number of programming repetitions
                      00099                                             ;If smart programming, this is the limit for P.
                      00100 
  0000001E            00101 ET_PROGPULSE    equ     ET_PROGREPS+1       ;Programming pulse duration
                      00102                                             ;<7> x 100 multiplier
                      00103                                             ;<7:0> = 00 means 0.25 uS (PGM pulse only!)
                      00104                                             ;<7> = 0, <6:0> = 01-03 reserved
                      00105                                             ;                 04 to 7F: pulse in units of 10 uS
                      00106                                             ;<7> = 1, <6:0> = pulse in units of mS
                      00107 
  0000001F            00108 ET_PPDELAY      equ     ET_PROGPULSE+1      ;duration of delay between programming pulses
                      00109                                             ;<7> x 100 multiplier
                      00110                                             ;<7:0> = 00 means no delay
                      00111                                             ;<7:0> = 01 means EEPROM-style polling
                      00112                                             ;<7> = 0, <6:0> = 02-03 reserved
                      00113                                             ;                 04 to 7F: pulse in units of 10 uS
                      00114                                             ;<7> = 1, <6:0> = pulse in units of mS
                      00115 
                      00116 
  00000020            00117 ET_SMART1       equ     ET_PPDELAY+1        ;Phase 1 Algorithm
                      00118                                             ;00 means no smart programming (just program the
                      00119                                             ;EPROM ET_PROGREPS times)
                      00120                                             ;80 means just program until match
                      00121                                             ;<6:4> Phase 1 type
                      00122                                             ;    0: program until match, then program n times
                      00123                                             ;    1: program until match, then 1 pulse
                      00124                                             ;      that is n*ET_PROGPULSE long
                      00125                                             ;    2: program until match (P), then nP times
                      00126                                             ;    3: program until match (P), then 1 pulse
                      00127                                             ;      that is n*P*ET_PROGPULSE long
                      00128                                             ;    4: Program n times
                      00129                                             ;    5: Program once, pulse time = n*ET_PROGPULSE
                      00130                                             ;<3> set means write FF (EEPROM erase)
                      00131                                             ;<2:0> Phase n
                      00132 
  00000021            00133 ET_SMART2       equ     ET_SMART1+1         ;Phase 2 Algorithm
                      00134                                             ;00 means no phase 2
                      00135                                             ;80 means just program until match
                      00136                                             ;<6:4> Phase 2 type
                      00137                                             ;    0: program until match, then program n times
                      00138                                             ;    1: program until match, then 1 pulse
                      00139                                             ;      that is n*ET_PROGPULSE long
                      00140                                             ;    2: program until match (P), then nP times
                      00141                                             ;    3: program until match (P), then 1 pulse
                      00142                                             ;      that is n*P*ET_PROGPULSE long
                      00143                                             ;    4: Program n times
                      00144                                             ;    5: Program once, pulse time = n*ET_PROGPULSE
                      00145                                             ;<3> set means write FF (EEPROM erase)
                      00146                                             ;<2:0> Phase n
                      00147 
  00000022            00148 ET_SPECIAL      equ     ET_SMART2+1         ;Special requirements
                      00149                                             ;<7:4> reserved
                      00150                                             ;<3> 1 = EEPROM: no blank check required
                      00151                                             ;<2> 1 = External Vpp required
                      00152                                             ;<1> 1 = Vpp requires adjustment
                      00153                                             ;<0> 1 = programming Vcc requires adjustment
                      00154 
  00000023            00155 ET_RESERVED     equ     ET_SPECIAL+1        ;reserved for future use
                      00156 
  00000024            00157 ET_RLENGTH      equ     ET_RESERVED+1       ;record length (bytes/record)
                      00158 
                      00159 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  6
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00160 
                      00068     #include    IOPorts.inc
                      00001 ;****************************************
                      00002 ;* Input/Putput Port Bit Definitions    *
                      00003 ;****************************************
                      00004 
                      00005 ;*------------------------------------------------------------------------*
                      00006 ; I/O Port A Initialization Values (Page 113)
                      00007 ;  Bit  Name            Dir         Function        Use
                      00008 ;   0   M25V        Analog Input    C12IN0-     25-volt compare
                      00009 ;   1   M21V        Analog Input    C12IN1-     21-volt compare
                      00010 ;   2   P18_0       Output          RA2         Pin 18 Control:
                      00011 ;   3   P18_1       Output          RA3         00 = TTL low
                      00012 ;                                               01 = TTL high
                      00013 ;                                               10 = -40V (Intersil option req'd)
                      00014 ;                                               11 = Vpp
                      00015 ;
                      00016 ;   4   P19_0       Output          RA4         Pin 19 Control:
                      00017 ;   5   P19_1       Output          RA5         00 = TTL low
                      00018 ;                                               01 = +5V
                      00019 ;                                               10 = +12V
                      00020 ;                                               11 = N/A (TTL high)
                      00021 ;
                      00022 ;   6   P20_0       Output          RA6         Pin 20 Control:
                      00023 ;   7   P20_1       Output          RA7         00 = TTL 0
                      00024 ;                                               01 = TTL 1
                      00025 ;                                               10 = +12V
                      00026 ;                                               11 = Vpp
                      00027 ;*----------------------------- -------------------------------------------*
  00000000            00028 M25V            equ     0
  00000001            00029 M21V            equ     1
  00000002            00030 P18_0           equ     2
  00000003            00031 P18_1           equ     3
  00000004            00032 P19_0           equ     4
  00000005            00033 P19_1           equ     5
  00000006            00034 P20_0           equ     6
  00000007            00035 P20_1           equ     7
                      00036 
  00000003            00037 TRISA_INIT      equ     (1 << M25V) | (1 << M21V)
  00000003            00038 ANSEL_INIT      equ     (1 << M25V) | (1 << M21V)
                      00039 
                      00040 ;*------------------------------------------------------------------------*
                      00041 ; I/O Port B Initialization Values (Page 116)
                      00042 ;  Bit  Name             Dir        Function        Use
                      00043 ;   0   P24_5Vn     output          RB0         0 applies +5V to pin 24
                      00044 ;   1   M13_1V      Analog Input    C12IN3-     13.1-volt compare
                      00045 ;   2   P24_12Vn    Output          RB2         0 applies +12V to pin 24
                      00046 ;   3   M12_75V     Analog Input    C12IN2-     12.75-volt compare
                      00047 ;   4   P24_6Vn     Output          RB4         0 applies 6.2V to pin 24
                      00048 ;   5   P22n        Output          RB5         Inverted EPROM pin 22
                      00049 ;   6   DBUFDIR     Output          RB6         Data buffer direction:
                      00050 ;                                               0 = Read from EPROM
                      00051 ;                                               1 = Write to EPROM
                      00052 ;   7   DBUFOEn     Output          RB7         0 enables  data buffer output   
                      00053 ;*------------------------------------------------------------------------*
  00000000            00054 P24_5Vn         equ     0
  00000001            00055 M13_1V          equ     1
  00000002            00056 P24_12Vn        equ     2
  00000003            00057 M12_75V         equ     3
  00000004            00058 P24_6Vn         equ     4
  00000005            00059 P22n            equ     5
  00000006            00060 DBUFDIR         equ     6
  00000007            00061 DBUFOEn         equ     7
                      00062 
  0000000A            00063 TRISB_INIT      equ     (1 << M13_1V) | (1 << M12_75V)
  0000000A            00064 ANSELH_INIT     equ     (1 << M13_1V) | (1 << M12_75V)
                      00065 
                      00066 ;*------------------------------------------------------------------------*
                      00067 ; I/O Port C Initialization Values (Page 119)
                      00068 ;  Bit  Name         Dir        Function        Use
                      00069 ;
                      00070 ;   0   P23n        Output      RC0         Inverted EPROM pin 23
                      00071 ;                                           (inverted EPROM address bit 8)
                      00072 ;   1   SRAM_CEn    Output      RC1         Active-low SRAM chip enable
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  7
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00073 ;   2   VPPULSE     Output      CCP1/P1A    Vpp Switcher pulse output
                      00074 ;   3   SCK         Output      SCK1        SPI Clock to SRAM
                      00075 ;   4   SI          Input       SDI1        SPI Data In from SRAM
                      00076 ;   5   SO          Output      SDO1        SPI Data Out to SRAM
                      00077 ;   6   TxD         Output      TX1         RS-232 transmit data
                      00078 ;   7   RxD         Input       RX1         RS-232 receive data
                      00079 ;*------------------------------------------------------------------------*
  00000000            00080 P23n            equ     0
  00000001            00081 SRAM_CEn        equ     1
  00000002            00082 VPULSE          equ     2
                      00083 
  00000090            00084 TRISC_INIT      equ     0x90
                      00085 
                      00086 ;*------------------------------------------------------------------------*
                      00087 ; I/O Port D Initialization Values (Page 122)
                      00088 ;  Bit  Name         Dir        Function        Use
                      00089 ;   0   D0          In/out      RD0         Data bit 0
                      00090 ;   1   D1          In/out      RD1         Data bit 1
                      00091 ;   2   D2          In/out      RD2         Data bit 2
                      00092 ;   3   D3          In/out      RD3         Data bit 3
                      00093 ;   4   D4          In/out      RD4         Data bit 4
                      00094 ;   5   D5          In/out      RD5         Data bit 5
                      00095 ;   6   D6          In/out      RD6         Data bit 6
                      00096 ;   7   D7          In/out      RD7         Data bit 7
                      00097 ;*------------------------------------------------------------------------*
  000000FF            00098 TRISD_INIT      equ     0xff            ;initialize as inputs
                      00099 
                      00100 ;*------------------------------------------------------------------------*
                      00101 ; I/O Port E Initialization Values (Page 125)
                      00102 ;  Bit  Name         Dir        Function        Use
                      00103 ;   0   P21_0       Output      RE0         Pin 21 Control:
                      00104 ;   1   P21_1       Output      RE1         00 = TTL 0
                      00105 ;                                           01 = TTL 1
                      00106 ;                                           10 = -5V
                      00107 ;                                           11 = Vpp
                      00108 ;
                      00109 ;   2   ADRCLK      Output      RE2         Positive edge clocks address low byte
                      00110 ;                                           Also light BUSY LED when high
                      00111 ;   3   SETUP       In          RE3         SETUP (jumper to +3.3 on ICP connector)
                      00112 ;   (Note: Pin RE3 gets high voltage during PIC programming)
                      00113 ;*------------------------------------------------------------------------*
  00000000            00114 P21_0           equ     0
  00000001            00115 P21_1           equ     1
  00000002            00116 ADRCLK          equ     2
  00000003            00117 SETUP           equ     3
                      00118 
  00000008            00119 TRISE_INIT      equ     (1 << SETUP)        ;SETUP is an input
                      00120 
                      00069     #include    ME2700.inc
                      00001 ;****************************
                      00002 ; Various M2700 Constants   *
                      00003 ;****************************
                      00004 ; General constants
  00002000            00005 SRAM_SIZE       equ 0x2000          ;8kB SRAM size
  00000000            00006 ME2700ID        equ 0               ;expected ID from kernel
                      00007 
  00000012            00008 VPP_PW          equ 0x12            ;pulse width for Vpp's PWM
                      00009 
  00000080            00010 PACCOUNT        equ .128            ;pacifier character every 128 bytes written
                      00011 
  0000000E            00012 MAXNAME         equ .14             ;max custom EPROM name character count
                      00013 
  00000010            00014 LISTROWS        equ .16             ;number of rows for the EL command
                      00015 
  0000003E            00016 PROMPTCHR:      equ '>'             ;Prompt
                      00017 ;*------------------------------------------------------------------------*
                      00018 ;* RAM assignments
                      00019 ;*------------------------------------------------------------------------*
                      00020 ;General purpose registers (R0-R2 defined by Kernel):
                      00021 
  00000010            00022 R3              equ     R2+1
  00000011            00023 R4              equ     R3+1
  00000012            00024 R5              equ     R4+1
  00000013            00025 R6              equ     R5+1
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  8
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000014            00026 R7              equ     R6+1
  00000015            00027 R8              equ     R7+1
  00000016            00028 R9              equ     R8+1
                      00029 
                      00030 ;Special function registers of our own
                      00031 
  00000017            00032 BUF_OFFSET      equ R9+1            ;buffer address offset
  00000018            00033 COUNTL          equ BUF_OFFSET+1    ;byte count low byte for commands & hex records
  00000019            00034 COUNTH          equ COUNTL+1        ;byte count high byte
                      00035 
  0000001A            00036 ADDRESSL_SAVE   equ COUNTH+1        ;save for ADDRESSL
  0000001B            00037 ADDRESSH_SAVE   equ ADDRESSL_SAVE+1 ;save for ADDRESSH
  0000001C            00038 COUNTL_SAVE     equ ADDRESSH_SAVE+1 ;save for COUNT_LOW
  0000001D            00039 COUNTH_SAVE     equ COUNTL_SAVE+1   ;save for COUNT_HIGH
  0000001E            00040 ETYPE_SAVE      equ COUNTH_SAVE+1   ;save for ETYPE
                      00041 
  0000001F            00042 SHARED          equ ETYPE_SAVE+1    ;shared pin flags
  00000000            00043 OEVPP               equ 0x00        ;1 if -OE pin is also Vpp
  00000001            00044 CSVPP               equ 0x01        ;1 if CS pin is also Vpp
  00000002            00045 OEPGM               equ 0x02        ;1 if -OE pin is also PGM
  00000003            00046 CSPGM               equ 0x03        ;1 if CS is also PGM
                      00047 
  00000020            00048 FLAGS1          equ SHARED+1        ;Flags and binary states
  00000000            00049 INTEL_STATE         equ 0x00        ;Intel (rather than Motorola) record
  00000001            00050 A_STATE             equ 0x01        ;general purpose flag
  00000002            00051 B_STATE             equ 0x02        ;EB command in process (used for other things, too)
  00000003            00052 DFLT_FLAG           equ 0x03        ;set if no first parameter was provided
  00000004            00053 FULL_FLAG           equ 0x04        ;set if operation is for a complete EPROM
  00000005            00054 AO_MANUAL           equ 0x05        ;0 means get address offset from 1st record
  00000006            00055 AO_INIT             equ 0x06        ;1 when ADR_OFFSET is initialized
  00000007            00056 TEST                equ 0x07        ; Test mode indicator
                      00057 
  00000021            00058 FLAGS2          equ FLAGS1+1        ;More flags. Bits marked (*) must remain where placed!
  00000000            00059 PMODE0              equ 0x00        ;(*)00: pulse CS pin  01: pulse PGM pin
  00000001            00060 PMODE1              equ 0x01        ;(*)10: pulse Vpp, return to 0V, 11: pulse Vpp, return to +5V
  00000002            00061 RDVPP               equ 0x02        ;(*)Vpp level during read: 0=0V, 1=5V
  00000003            00062 FAST_PULSE          equ 0x03        ;1 means <1 uS programming pulse
  00000004            00063 ADJ_VCC             equ 0x04        ;(*)1 means Vcc requires manual adjustment
  00000005            00064 ADJ_VPP             equ 0x05        ;(*)1 means Vpp requires manual adjustment
  00000006            00065 EXT_VPP             equ 0x06        ;(*)1 means external Vpp required
  00000007            00066 CUST_EPROM          equ 0x07        ;1 means current EPROM is custom
                      00067 
  00000022            00068 ADR_OFFSET      equ FLAGS2+1        ;hex record address high-byte offset
  00000023            00069 PPULSEL         equ ADR_OFFSET+1    ;(2 bytes)Programming pulse duration, in units of 10 uS
  00000024            00070 PPULSEH         equ PPULSEL+1       ;..not meaningful if FAST_PULSE=1
  00000025            00071 PPDELL          equ PPULSEH+1       ;(2 bytes)Delay between programming pulses, in units of 10 uS
  00000026            00072 PPDELH          equ PPDELL+1        ;..not meaningful if FAST_PULSE=1
                      00073 
  00000027            00074 PROGREPS        equ PPDELH+1        ;programming rpeitions (or rep limit for smart)
  00000028            00075 SMART1          equ PROGREPS+1      ;Smart programming mode, phase 1
  00000029            00076 SMART2          equ SMART1+1        ;Smart programming mode, phase 2
  0000002A            00077 PACINDEX        equ SMART2+1        ;pacifier character counter
                      00078 
  0000002B            00079 VSENSE_LOW      equ PACINDEX+1      ;lower Vpp voltage limit (0 means no limit)
  0000002C            00080 VSENSE_HIGH     equ VSENSE_LOW+1    ;upper Vpp voltage limit (0xFF means no limit)
                      00081 
                      00082 
                      00083 ;*------------------------------------------------------------------------*
                      00084 ;* EEPROM assignments (retained when powered off)
                      00085 ;*------------------------------------------------------------------------*
  0000001C            00086 ETYPE           equ     EE_VARBEG+0         ;EPROM Type
  0000001D            00087 PROGCNT         equ     ETYPE+1             ;2-byte successful EPROM program count
  0000001F            00088 FAILCNT         equ     PROGCNT+2           ;2-byte failed program count
  00000021            00089 DINV_STATE      equ     FAILCNT+2           ;NZ means EPROM data is inverted
                      00090 
  00000022            00091 CE_TABLE        equ     DINV_STATE+1        ;custom EPROM definition table
  00000004            00092 CEPROM_COUNT    equ     4                   ;max supported custom EPROMs
  00000090            00093 CE_TABLEN       equ CEPROM_COUNT*ET_RLENGTH ;table length
                      00094 ;*==============================================================================*
                      00095 ; Print an error message in the listing if EEPROM variables exceed the EEPROM
                      00096 ;*==============================================================================*
                      00097     if  CE_TABLE+CE_TABLEN > 256
                      00098     error   "Martin sez: EEPROM Overflow!"
                      00099     endif
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE  9
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00100 
                      00070 
000800                00071     org LOADED_CODE
                      00072 
                      00073 ;disable all interrupts while we set things up
                      00074 
000800 6AF2           00075             clrf    INTCON                  ;disable interrupts while we work
                      00076 
                      00077 ;################################################################################
                      00078 ;# Initialization Routine                                                       #
                      00079 ;# Mainly what the Kernel didn't initialize                                     #
                      00080 ;################################################################################
                      00081 
                      00082 ;Clear 8K-byte EPROM buffer in the external serial RAM (all of it)
000802 6805           00083 init:       setf    ADDRESSL,0                  ;address counter low byte
000804 0E1F           00084             movlw   high(SRAM_SIZE-1)
000806 6E06           00085             movwf   ADDRESSH,0                  ;address counter high byte
                      00086 
000808 0E00           00087 clr_sram:       movlw   0
00080A DC12           00088                 rcall   K_WRSRAM                ;write W to SRAM at ADDRESSH:ADDRESSL
                      00089 
00080C 0E01           00090                 movlw   0x01
00080E 5E05           00091                 subwf   ADDRESSL,F,0
000810 E2FB           00092                 bc      clr_sram
000812 5E06           00093                 subwf   ADDRESSH,F,0
000814 E2F9           00094                 bc      clr_sram
                      00095 
                      00096 ;Initialize variables that need it
000816 6A22           00097             clrf    ADR_OFFSET                  ;file address offset
000818 6A17           00098             clrf    BUF_OFFSET                  ;buffer address offset
00081A 6A20           00099             clrf    FLAGS1
                      00100 
                      00101 ;Set up timer 0 as a 15.625 KHz timer, for use with the pacifier
00081C 9AF2           00102             bcf     INTCON,TMR0IE               ;make sure timer 0 interrupt is off
00081E 0E87           00103             movlw   (1<<TMR0ON)+0x07            ;enable timer, prescaler=256
000820 6ED5           00104             movwf   T0CON,0                     ;(page 145)
                      00105 
                      00106 ;Set up the ADC for over-current Vpp shutdown
000822 0E05           00107             movlw   0x05                        ;Fosc/16 for a 1 uS Tad, and an 11 uS acquisition time
000824 6EC0           00108             movwf   ADCON2,0                    ;the correct value when Fosc=16 MHz (page 251)
                      00109 
                      00110 ;Re-initialize the receive queue in case of trash from the loader
000826 0E00           00111             movlw   low(RX_QUEUE)
000828 6E00           00112             movwf   RQ_IPTR,0
00082A 6E01           00113             movwf   RQ_OPTR,0
                      00114 
                      00115 ;Re-initialize the transmit queue in case of trash from the loader
00082C 0EE0           00116             movlw   low(TX_QUEUE)
00082E 6E02           00117             movwf   TQ_IPTR,0
000830 6E03           00118             movwf   TQ_OPTR,0
                      00119 
                      00120 ;Initialize interrupt flags: queues are empty
000832 0E02           00121             movlw   (1 << TQ_EMPTY)
000834 6E0B           00122             movwf   INT_FLAGS,0
                      00123 
000836 50AE           00124             movf    RCREG,W,0                   ;chuck any junk in the UART receiver
000838 50AE           00125             movf    RCREG,W,0                   ;it's a double-buffer
                      00126 
                      00127 ;Enable interrupts - we're ready to go
00083A 0EC0           00128             movlw   (1 << PEIE) | (1 << GIE)    ;peripheral ints & global enable only
00083C 6EF2           00129             movwf   INTCON,0
                      00130 
                      00131 ;Verify that this firmware matches the programmer
00083E EC02 F000      00132             call    K_PROG_ID
000842 0A00           00133             xorlw   ME2700ID
000844 A4D8           00134             btfss   STATUS,Z,0
000846 EF3C F011      00135             goto    wrong_programmer
                      00136 
                      00137 ;Verify that this firmware version matches the kernel in FLASH. We only care about
                      00138 ;the major revision level - minor revision levels shouldn't affect compatibility.
                      00139 ;(This will work so long as the wrong kernel's K_PRINTF hasn't changed.) Continue
                      00140 ;running even with the wrong kernel revision.
00084A EE0A F07A      00141             lfsr    0,wrongkern_msg-sstrings
00084E EC01 F000      00142             call    K_KERN_REV                  ;returns revision in W
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 10
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000852 0BF0           00143             andlw   0xf0                        ;only care about major revision
000854 0A10           00144             xorlw   REQUIRED_KERN_REV
000856 A4D8           00145             btfss   STATUS,Z,0
000858 DA42           00146             rcall   cr_printf2
                      00147 
                      00148 ;Print the sign-on message
00085A EE0B F068      00149             lfsr    0,signon_msg-sstrings
00085E DA3F           00150             rcall   cr_printf2                  ;print the signon message
                      00151 
                      00152 ;Set up for the currently-selected EPROM, and report that
000860 ECE9 F00A      00153             call    etype_setup                 ;set up Vpp supply, etc.
000864 ECA2 F00A      00154             call    rep_etype                   ;report EPROM type
000868 DA23           00155             rcall   rep_dinvert                 ;report the data inversion state
00086A EE00 F000      00156             lfsr    0,cmdlst_msg-sstrings       ;"? for command list"
00086E DA37           00157             rcall   cr_printf2
                      00158 
000870 ECDD F009      00159             call    epower_off                  ;in particular, turn off busy light
                      00160 
                      00161 ;Fall into main
                      00162 
                      00163 ;################################################################################
                      00164 ;# Main Program Loop                                                            #
                      00165 ;#   Wait for a complete (CR-terminated) line of input from the user, and stash #
                      00166 ;#     the entire line in the Line Buffer                                       #
                      00167 ;#   Parse the line for commands and variables                                  #
                      00168 ;#   Branch to the appropriate command-processing routine based on the first    #
                      00169 ;#     character from the user. (Further decoding is done in the first-level    #
                      00170 ;#     command processing routines.)                                            #
                      00171 ;#   All command processing routines return to main except the two hex download #
                      00172 ;#     routines, which branch back to no_prompt between hex records.            #
                      00173 ;#   The stack gets reset here, in case of aborts to main.                      #
                      00174 ;################################################################################
000874 6AFC           00175 main:           clrf    STKPTR                  ;fix stack in case we aborted
000876 D801           00176                 rcall   do_main                 ;push main return address on stack
000878 D7FD           00177                 bra     main
                      00178 
                      00179 ;Print prompt on a new line
00087A EE00 F01A      00180 do_main:        lfsr    0,prompt_msg-sstrings
00087E DA2F           00181                 rcall   cr_printf2
                      00182 
                      00183 ;Clear counters used for intel hex and motorola S-record file downloads
                      00184 ;and other variables
000880 6A08           00185                 clrf    RECOUNTH                ;RECOUNTH:RECOUNTL counts received records
000882 6A07           00186                 clrf    RECOUNTL
000884 6A0A           00187                 clrf    ERRCNTH                 ;ERRCNTH:ERRCNTL counts bad hex records
000886 6A09           00188                 clrf    ERRCNTL
000888 6A19           00189                 clrf    COUNTH                  ;COUNTH:COUNTL counts records loaded into buffer
00088A 6A18           00190                 clrf    COUNTL
                      00191 
00088C 9E20           00192                 bcf     FLAGS1,TEST             ;tell ewrite_byte that we are not testing
                      00193 
                      00194 ;-----------------------------------------------------------------
                      00195 ; Get a complete, CR-terminated line into the line buffer
                      00196 ;
                      00197 ; Entry at no-prompt is used after receiving a hex data record, so
                      00198 ; that a prompt does not get printed between records, and so that
                      00199 ; the error and record counters continue to accumulate.
                      00200 ;-----------------------------------------------------------------
00088E 9420           00201 no_prompt:      bcf     FLAGS1,B_STATE,0        ;not yet a blank-check, S5 record, or a checksum command
                      00202 
000890 0E4F           00203                 movlw   MAXLIN-1                ;max input line size
000892 EC0E F000      00204                 call    K_GETLIN                ;get a line from the user into the LINEBUF
000896 E0F1           00205                 bz      do_main                 ;no input or control-C: start over
                      00206         
                      00207 ;------------------------------------------------------
                      00208 ; Get the 1st character from the command line, and
                      00209 ; test for hex download command immediately, for speed.
                      00210 ;------------------------------------------------------
000898 EC11 F000      00211                 call    K_GETUCHR               ;get uppercase chr in W and R0
                      00212 
00089C 0A3A           00213                 xorlw   ':'                     ;beginning of Intel Hex record?
00089E B4D8           00214                 btfsc   STATUS,Z,0
0008A0 D0A9           00215                 bra     cmd_intel
                      00216 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 11
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0008A2 0A69           00217                 xorlw   ':' ^ 'S'               ;beginning of Motorola S-record record?
0008A4 B4D8           00218                 btfsc   STATUS,Z,0
0008A6 D07D           00219                 bra     cmd_motorola
                      00220 
0008A8 B60C           00221                 btfsc   KERN_FLAGS,CR_FLAG,0    ;is this line just a CR?
0008AA D7E7           00222                 bra     do_main                 ;yes: just ignore the line.
                      00223 
0008AC 50E5           00224                 movf    POSTDEC1,W,0            ;back up to beginning of input line
                      00225 
                      00226 ;--------------------------------------------------------------
                      00227 ; Search command table for match, get its command index into R4
                      00228 ;--------------------------------------------------------------
0008AE 0E22           00229                 movlw   high(main_cmds)
0008B0 6EF7           00230                 movwf   TBLPTRH,0
0008B2 0E8E           00231                 movlw   low(main_cmds)
0008B4 6EF6           00232                 movwf   TBLPTRL,0
                      00233 
0008B6 EC0F F000      00234                 call    K_PARSE                 ;returns W=command index
0008BA 6E11           00235                 movwf   R4,0                    ;remember index
                      00236             
                      00237 ;--------------------------------------------------------------------------
                      00238 ; Get the first two 16-bit hex parameters that came with the 2-character
                      00239 ; command. gethex4 will return default 0x0000  and INP_FLAG=0 if no
                      00240 ; parameter was provided, and will abort directly to main on bogus hex.
                      00241 ;--------------------------------------------------------------------------
                      00242 ;Get the first parameter and store it in ADDRESSH:ADDRESSL. Set INP_FLAG if a
                      00243 ;parameter was provided, and clear it if not. The first parameter is usually the
                      00244 ;address, though sometimes it is an 8-bit parameter.
                      00245 
0008BC 8620           00246                 bsf     FLAGS1,DFLT_FLAG,0      ;assume we will default
                      00247 
0008BE EC14 F000      00248                 call    K_GETHEX4               ;get the 1st parameter into R2:R1
0008C2 B00C           00249                 btfsc   KERN_FLAGS,ERR_FLAG     ;Bogus input?
0008C4 D20A           00250                 bra     cmd_error
                      00251 
0008C6 B20C           00252                 btfsc   KERN_FLAGS,INP_FLAG,0   ;any input provided?
0008C8 9620           00253                 bcf     FLAGS1,DFLT_FLAG,0      ;y: do not default
                      00254 
0008CA C00E F005      00255                 movff   R1,ADDRESSL             ;put first parameter into ADDRESSH:ADDRESSL
0008CE C00F F006      00256                 movff   R2,ADDRESSH
                      00257 
                      00258 ;Test to see if the first parameter (the address) is greater than the max allowed
0008D2 5006           00259                 movf    ADDRESSH,W,0
0008D4 081F           00260                 sublw   (high(SRAM_SIZE))-1     ;carry cleared if ADDRESSH > high(SRAM_SIZE)-1
0008D6 A0D8           00261                 btfss   STATUS,C,0
0008D8 D200           00262                 bra     cmd_error               ;error if greater than max address
                      00263 
                      00264 ;Get second parameter, which is a byte count, if it exists. Store it in COUNTH and COUNTL.
                      00265 ;Note that 0000 means to use the entire EPROM or the entire buffer.
0008DA EC14 F000      00266                 call    K_GETHEX4               ;get the 1st parameter
0008DE B00C           00267                 btfsc   KERN_FLAGS,ERR_FLAG     ;Bogus input?
0008E0 D1FC           00268                 bra     cmd_error
                      00269 
0008E2 C00E F018      00270                 movff   R1,COUNTL               ;2nd parameter to COUNT
0008E6 C00F F019      00271                 movff   R2,COUNTH
                      00272 
                      00273 ;If count is 0000 then set it to the buffer size and set FULL_FLAG to remember that
                      00274 ;the range is an entire EPROM
0008EA 9820           00275                 bcf     FLAGS1,FULL_FLAG,0      ;assume partial EPROM operation
                      00276 
0008EC 5019           00277                 movf    COUNTH,W,0
0008EE 1018           00278                 iorwf   COUNTL,W,0              ;set Z if both bytes were 00
                      00279 
0008F0 0E20           00280                 movlw   high(SRAM_SIZE)         ;limit to buffer size
0008F2 B4D8           00281                 btfsc   STATUS,Z,0
0008F4 6E19           00282                 movwf   COUNTH,0
                      00283 
                      00284 ;Test to see if second parameter (the count) is greater than the entire buffer
0008F6 5019           00285                 movf    COUNTH,W,0
0008F8 0820           00286                 sublw   high(SRAM_SIZE)         ;W = high(SRAM_SIZE)- COUNTH
0008FA A0D8           00287                 btfss   STATUS,C,0
0008FC D1EE           00288                 bra     cmd_error               ;Carry clear if COUNTH > high(SRAM_SIZE)
0008FE E104           00289                 bnz     param2_ok
                      00290 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 12
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000900 1018           00291                 iorwf   COUNTL,W,0              ;exactly equal to max?
000902 A4D8           00292                 btfss   STATUS,Z,0
000904 D1EA           00293                 bra     cmd_error               ;no: count is too big
                      00294 
000906 8820           00295                 bsf     FLAGS1,FULL_FLAG,0      ;complete buffer operation (no 'range' in messages)
000908                00296 param2_ok:
                      00297 
                      00298 ;-----------------------------------------------------------------------
                      00299 ; Go execute a command
                      00300 ; R4 = command index, 0 means not found
                      00301 ; ADDRESSH:ADDRESSL = 1st parameter that came with the command
                      00302 ; COUNTH:COUNTL = 2nd  parameter that came with the command
                      00303 ; DFLT_FLAG = 1 if no parameters came with the command.
                      00304 ; FULL_FLAG is cleared unless COUNTH:COUNTL = 8K
                      00305 ; All of these command-processing routines return to main when done
                      00306 ;-----------------------------------------------------------------------
000908 50F9           00307 jmptab1:    movf    PCL,W,0             ;force a load of the PCLATH register (page 62)
00090A 5011           00308             movf    R4,W,0              ;command index (a multiple of 2)
00090C 26F9           00309             addwf   PCL,F,0
                      00310 
00090E D1E5           00311             bra     cmd_error           ;Command not found  
000910 D224           00312             bra     cmd_blankchk        ;EB
000912 D1B4           00313             bra     cmd_dispeprom       ;ED
000914 D026           00314             bra     cmd_ceedit          ;EE
000916 D1C4           00315             bra     cmd_dinvert         ;DI
000918 D23E           00316             bra     cmd_eplist          ;EL
00091A D26E           00317             bra     cmd_program         ;EP
00091C D2B6           00318             bra     cmd_read            ;ER
00091E D211           00319             bra     cmd_compare         ;EC
000920 D1DF           00320             bra     cmd_etype           ;ET
000922 D0D3           00321             bra     cmd_boffset         ;BAO
000924 D0DC           00322             bra     cmd_foffset         ;FAO
000926 D2D1           00323             bra     cmd_uploadi         ;UI
000928 D2CE           00324             bra     cmd_uploads         ;US
00092A D0EC           00325             bra     cmd_bdisplay        ;BD
00092C D126           00326             bra     cmd_bedit           ;BE
00092E D14C           00327             bra     cmd_fill            ;BF
000930 D15D           00328             bra     cmd_dstate          ;DS
000932 D223           00329             bra     cmd_echo            ;ECHO
000934 00FF           00330             reset                       ;RESET (just reset here)
000936 D312           00331             bra     cmd_avpp            ;AVPP
000938 D38D           00332             bra     cmd_tas             ;TAS
00093A D32E           00333             bra     cmd_vbbvdd          ;VBD
00093C D33B           00334             bra     cmd_tvcc            ;VCC
00093E D383           00335             bra     cmd_toe             ;TOE
000940 D342           00336             bra     cmd_tpgm            ;TPGM
000942 D3BA           00337             bra     cmd_tprog           ;TPROG
000944 D3CE           00338             bra     cmd_tread           ;TREAD
000946 D347           00339             bra     cmd_tcs             ;TCS
000948 D356           00340             bra     cmd_tvpp            ;TVPP
00094A D34D           00341             bra     cmd_thi             ;THI
00094C D31B           00342             bra     cmd_rdata           ;RD
00094E D3B3           00343             bra     cmd_waddress        ;WA
000950 D3AB           00344             bra     cmd_wdata           ;WD
000952 D009           00345             bra     cmd_help            ;?
000954 D00C           00346             bra     cmd_bhelp           ;?B
000956 D00F           00347             bra     cmd_nhelp           ;?N
000958 D012           00348             bra     cmd_dhelp           ;?D
00095A D015           00349             bra     cmd_ehelp           ;?E
00095C D018           00350             bra     cmd_fhelp           ;?F
00095E D01B           00351             bra     cmd_lhelp           ;?L
                      00352 
                      00353     if  !DEBUG
000960 D293           00354 jmpend1:    bra     cmd_cksum           ;ES
                      00355     endif
                      00356 
                      00357     if  DEBUG
                      00358 jmpend1:    bra     cmd_cksum
                      00359             goto    cmd_pw              ;extra debug cmd for tuning the switcher's pulse width
                      00360     endif
                      00361 
                      00362 ;********************************************************************************
                      00363 ; The above jump table must not span a 256-byte page boundary.
                      00364 ;********************************************************************************
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 13
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00365     if high(jmptab1)^ high(jmpend1)
                      00366     error "Martin sez: Main command jump table spans a page boundary"
                      00367     endif
                      00368 
                      00369 ;******=========================================================================*
                      00370 ;* EE *  Invoke Custom EPROM Editor Command
                      00371 ;******
                      00372 ;*==============================================================================*
000962 EFE1 F00C      00373 cmd_ceedit:     goto    do_ceedit       ;long jump
                      00374 
                      00375 ;*****==========================================================================*
                      00376 ;* ? *  General Help Command
                      00377 ;*****
                      00378 ; No parameters
                      00379 ;*==============================================================================*
000966 0EA6           00380 cmd_help:       movlw   low(help_msg)
000968 6EF6           00381                 movwf   TBLPTRL,0
00096A 0E3C           00382                 movlw   high(help_msg)
00096C D017           00383                 bra     print_help
                      00384                 
                      00385 ;******=========================================================================*
                      00386 ;* ?B *  Help with Buffer Commands
                      00387 ;******
                      00388 ; No parameters
                      00389 ;*==============================================================================*
00096E 0EDC           00390 cmd_bhelp:      movlw   low(bhelp_msg)
000970 6EF6           00391                 movwf   TBLPTRL,0
000972 0E46           00392                 movlw   high(bhelp_msg)
000974 D013           00393                 bra     print_help
                      00394                 
                      00395 ;******=========================================================================*
                      00396 ;* ?N *  General notes on ME2700
                      00397 ;******
                      00398 ; No parameters
                      00399 ;*==============================================================================*
000976 0ECC           00400 cmd_nhelp:      movlw   low(notes2700)
000978 6EF6           00401                 movwf   TBLPTRL,0
00097A 0E4A           00402                 movlw   high(notes2700)
00097C D00F           00403                 bra     print_help
                      00404                 
                      00405 ;******=========================================================================*
                      00406 ;* ?D *  Help with Diagnostic Commands
                      00407 ;******
                      00408 ; No parameters
                      00409 ;*==============================================================================*
00097E 0E78           00410 cmd_dhelp:      movlw   low(dhelp_msg)
000980 6EF6           00411                 movwf   TBLPTRL,0
000982 0E42           00412                 movlw   high(dhelp_msg)
000984 D00B           00413                 bra     print_help
                      00414                 
                      00415 ;******=========================================================================*
                      00416 ;* ?E *  Help with EPROM Commands
                      00417 ;******
                      00418 ; No parameters
                      00419 ;*==============================================================================*
000986 0E00           00420 cmd_ehelp:      movlw   low(ehelp_msg)
000988 6EF6           00421                 movwf   TBLPTRL,0
00098A 0E51           00422                 movlw   high(ehelp_msg)
00098C D007           00423                 bra     print_help
                      00424                 
                      00425 ;******=========================================================================*
                      00426 ;* ?F *  Help with File Transfer Commands
                      00427 ;******
                      00428 ; No parameters
                      00429 ;*==============================================================================*
00098E 0E0A           00430 cmd_fhelp:      movlw   low(fhelp_msg)
000990 6EF6           00431                 movwf   TBLPTRL,0
000992 0E56           00432                 movlw   high(fhelp_msg)
000994 D003           00433                 bra     print_help
                      00434                 
                      00435 ;******=========================================================================*
                      00436 ;* ?L *  Help with Loader
                      00437 ;******
                      00438 ; No parameters
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 14
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00439 ;*==============================================================================*
000996 0E14           00440 cmd_lhelp:      movlw   low(lhelp_msg)
000998 6EF6           00441                 movwf   TBLPTRL,0
00099A 0E5B           00442                 movlw   high(lhelp_msg)
                      00443 
00099C 6EF7           00444 print_help:     movwf   TBLPTRH,0
00099E EF07 F000      00445                 goto    K_PRINTF            ;print the message, return to main
                      00446 
                      00447 ;*****==========================================================================*
                      00448 ;* S *  Incoming Motorola S-Record Command
                      00449 ;*****
                      00450 ; Valid Motorola S-record follows. ('S' already received)
                      00451 ; This routine validates a Motorola S-record, puts the payload into the buffer,
                      00452 ; and checks the checksum. The prompt is not printed after a data record, so
                      00453 ; that we can keep up with reception.
                      00454 ; Supports S1 (data), S5 (record count), and S9 (end-of-file) record types.
                      00455 ; S9 records can be either a complete S9 record, or just 'S9', as you find
                      00456 ; in some S-record files for (for example) the Altair 680
                      00457 ; B_STATE flag is used to remember that we are doing an S5 record
                      00458 ; On Entry:
                      00459 ;   RECOUNTH:RECOUNTL = count of received records so far
                      00460 ;   ERRCNTH:ERRCNTL = count of bad hex records so far
                      00461 ;   COUNTH:COUNTL = count of records loaded into buffer so far
                      00462 ;   B_STATE = 0: not yet a blank-check, S5 record,  or a checksum command
                      00463 ;   ERR_FLAG = 0
                      00464 ;   AO_MANUAL = 1 if the address offset is manual, 0 if automatic
                      00465 ;   AO_INIT = 1 if the automatic address offset has been set
                      00466 ;   ADDR_OFFSET = the address offset
                      00467 ;   EPROM power is off
                      00468 ; On Exit:
                      00469 ;   W,R0,R1,R2,R3,FSR1 trashed
                      00470 ;   RECOUNTH:RECOUNTL = count of received records so far
                      00471 ;   ERRCNTH:ERRCNTL = count of bad hex records so far
                      00472 ;   COUNTH:COUNTL = count of records loaded into buffer so far
                      00473 ;*==============================================================================*
0009A2 9020           00474 cmd_motorola:   bcf     FLAGS1,INTEL_STATE,0    ;not Intel, but Motorola
                      00475 
                      00476 ;Start Motorola checksum at 1 so that 00 is a good result at the end
0009A4 0E01           00477                 movlw   0x01
0009A6 6E04           00478                 movwf   CHECKSUM,0
                      00479 
                      00480 ;Get & validate single-character Motorola record type
0009A8 EC10 F000      00481                 call    K_GETCHR                ;get W = record type from line buffer
                      00482 
0009AC 0A31           00483                 xorlw   '1'                     ;S1 data record?
0009AE E016           00484                 bz      mot_s1
                      00485 
0009B0 0A08           00486                 xorlw   '1' ^ '9'               ;S9 EOF record?
0009B2 E05C           00487                 bz      mot_s9
                      00488 
0009B4 0A0C           00489                 xorlw   '9' ^ '5'               ;S5 record-count record?
0009B6 E105           00490                 bnz     rec_error               ;no: unsupported record type
                      00491 
                      00492 ;*------------------------------------------------------------------------------*
                      00493 ; This is a Motorola S5 Record-Count record
                      00494 ; Get the rest of the record. B_STATE will tell us to check the record-count
                      00495 ; when done.
                      00496 ;*------------------------------------------------------------------------------*
0009B8 8420           00497 mot_s5:         bsf     FLAGS1,B_STATE,0        ;remember that this is an S5 record
                      00498 
                      00499 ;Get byte count and subtract 3 to account for address and checksum bytes
                      00500 ;The actual number of data bytes for S5 and S9 records must be 0
0009BA D814           00501 mot_nodatarec:  rcall   get_byte_cksum          ;get a hex byte into W & R1
                      00502 
0009BC 0E03           00503                 movlw   0x03
0009BE 5C0E           00504                 subwf   R1,W,0                  ;W has record byte count
0009C0 E01C           00505                 bz      download_rec            ;0 data bytes: good S5 or S9 record so far
                      00506 
                      00507 ;fall into rec_error if not 0 data bytes
                      00508 
                      00509 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                      00510 ; Common Hex Loader Error Routines: Report bad hex record of some sort, and go
                      00511 ; get another record
                      00512 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 15
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0009C2 EE00 F028      00513 rec_error:      lfsr    0,recerror_msg-sstrings     ;indicate record error
0009C6 D005           00514                 bra     ha_error
                      00515 
0009C8 EE00 F040      00516 s5_error:       lfsr    0,rcnterror_msg-sstrings    ;indicate bad S5 record
0009CC D002           00517                 bra     ha_error
                      00518 
0009CE EE00 F038      00519 cksum_error:    lfsr    0,cksumerror_msg-sstrings   ;indicate checksum error
                      00520 
0009D2 4A09           00521 ha_error:       infsnz  ERRCNTL,F,0                 ;bump bad record count
0009D4 2A0A           00522                 incf    ERRCNTH,F,0
0009D6 ECF8 F009      00523                 call    printf                      ;print error msg without leading CR
                      00524 
0009DA D044           00525                 bra     dr_next_record
                      00526 
                      00527 ;*------------------------------------------------------------------------------*
                      00528 ; This is a Motorola S1 (data) record 
                      00529 ; Get the byte count and subtract 3 to account for address and checksum bytes
                      00530 ;*------------------------------------------------------------------------------*
0009DC D803           00531 mot_s1:         rcall   get_byte_cksum              ;get a hex byte into W & R1
                      00532 
0009DE 0E03           00533                 movlw   0x03
0009E0 5C0E           00534                 subwf   R1,W,0                      ;W has record byte count                
0009E2 D00B           00535                 bra     download_rec
                      00536 
                      00537 ;*==============================================================================*
                      00538 ; Subroutine to get an exactly 2-character hex value from the Line Buffer, and
                      00539 ; also add the result to CHECKSUM
                      00540 ; This is as fast as possible so we can keep up with hex record loading
                      00541 ; This routine *IS* cases sensitive - lowercase will cause an error.
                      00542 ; This routine also does not skip over white space.
                      00543 ; Subroutine located here to facilitate rcall access.
                      00544 ; On Entry:
                      00545 ;    FSR1 points to the next chr in the line buffer
                      00546 ; On Exit:
                      00547 ;    FSR1 incremented twice
                      00548 ;    R0 trashed
                      00549 ;    Result in W and R1
                      00550 ;    Result added to CHECKSUM
                      00551 ;    Z set if checksum = 0
                      00552 ;    Abort rudely to ha_error if non-hex character found
                      00553 ; (45 cycles, worst case)
                      00554 ; Trashes R0
                      00555 ;*==============================================================================*
0009E4 EC13 F000      00556 get_byte_cksum: call    K_GETHEX2               ;get hex byte, compute checksum
                      00557 
0009E8 A00C           00558                 btfss   KERN_FLAGS,ERR_FLAG     ;hex error?
0009EA 0012           00559                 return
                      00560 
0009EC EE00 F030      00561                 lfsr    0,hexerror_msg-sstrings ;indicate hex error
0009F0 0006           00562                 pop                             ;chuck return address
0009F2 D7EF           00563                 bra     ha_error
                      00564 
                      00565 ;*****==========================================================================*
                      00566 ;* : * Incoming Intel Record Command
                      00567 ;*****
                      00568 ; Valid Intel Hex record follows. (Colon already received)
                      00569 ; Supports 00 (data) and 01 (end-of-file) record types. 0-byte data records
                      00570 ; are also treated as end-of-file records.
                      00571 ; This routine validates an Intel Hex record, puts the payload into the buffer,
                      00572 ; and checks the checksum. The prompt is not printed after a data record, so
                      00573 ; that we can keep up with reception. 
                      00574 ; On Entry:
                      00575 ;   RECOUNTH:RECOUNTL = count of received records so far
                      00576 ;   ERRCNTH:ERRCNTL = count of bad hex records so far
                      00577 ;   COUNTH:COUNTL = count of records loaded into buffer so far
                      00578 ;   B_STATE = 0
                      00579 ;   ERR_FLAG = 0
                      00580 ;   AO_MANUAL = 1 if the address offset is manual, 0 if automatic
                      00581 ;   AO_INIT = 1 if the automatic address offset has been set
                      00582 ;   ADDR_OFFSET = the address offset
                      00583 ;   EPROM power is off
                      00584 ; On Exit:
                      00585 ;   W,R0,R1,R2,R3,FSR1 trashed
                      00586 ;   RECOUNTH:RECOUNTL = count of received records so far
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 16
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00587 ;   ERRCNTH:ERRCNTL = count of bad hex records so far
                      00588 ;   COUNTH:COUNTL = count of records loaded into buffer so far
                      00589 ;*==============================================================================*
0009F4 8020           00590 cmd_intel:      bsf     FLAGS1,INTEL_STATE,0    ;Intel, not Motorola
0009F6 6A04           00591                 clrf    CHECKSUM,0              ;start Intel checksum at 0
                      00592 
                      00593 ;get record data byte count into W
0009F8 DFF5           00594                 rcall   get_byte_cksum          ;get a hex byte into W & R1
                      00595 
                      00596 ;fall into download_rec
                      00597 
                      00598 ;*********----------------------------------------------------------------------*
                      00599 ;* S & : * Common Hex Record Download Routine
                      00600 ;*********
                      00601 ; On Entry:
                      00602 ;   W= number of data bytes expected in the record
                      00603 ;   RECOUNTH:RECOUNTL = count of received records so far
                      00604 ;   ERRCNTH:ERRCNTL = count of bad hex records so far
                      00605 ;   COUNTH:COUNTL = count of records loaded into buffer so far
                      00606 ;   CHECKSUM is initialized for the particular record type
                      00607 ;   EPROM power is off
                      00608 ;   INTEL_STATE = 1 for Intel Hex record, 0 for S-Record
                      00609 ;   B_STATE = 1 for Motorola S5 Record, 0 otherwise
                      00610 ;   ERR_FLAG = 0, meaning that so far, this record fits in the buffer
                      00611 ;   AO_MANUAL = 1 if the address offset is manual, 0 if automatic
                      00612 ;   AO_INIT = 1 if the automatic address offset has been set
                      00613 ;   ADDR_OFFSET = the address offset
                      00614 ; On Exit:
                      00615 ;   Record data payload is in the specified place in the buffer
                      00616 ;   W,R0,R1,R2,R3,ADDRESSH:ADDRESSL,FSR1 trashed
                      00617 ;   RECOUNTH:RECOUNTL = count of received records so far
                      00618 ;   ERRCNTH:ERRCNTL = count of bad hex records so far
                      00619 ;   COUNTH:COUNTL = count of records loaded into buffer so far
                      00620 ; (Around 320 cycles = 80 uS for a worst-case 1-byte record. 9600 baud = 1000
                      00621 ; chr/sec, or about 1mS per character. We can parse an entire record between 2
                      00622 ; received characters, no problem.)
                      00623 ;*------------------------------------------------------------------------------*
0009FA 6E10           00624 download_rec:   movwf   R3,0                        ;save this record's byte count
0009FC 4A07           00625                 infsnz  RECOUNTL,F,0                ;bump hex record count
0009FE 2A08           00626                 incf    RECOUNTH,F,0
                      00627 
                      00628 ;Get the high address byte. If the address offset is set for automatic and is
                      00629 ;uninitialized, then set it to be the same as this record's high address byte,
                      00630 ;and remember that the address offset is now initialized.
000A00 DFF1           00631                 rcall   get_byte_cksum              ;get a hex byte into W & R1
                      00632 
000A02 BA20           00633                 btfsc   FLAGS1,AO_MANUAL,0          ;manually-set address offset?
000A04 D003           00634                 bra     d_rec1                      ;y: address offset is okay
                      00635 
000A06 AC20           00636                 btfss   FLAGS1,AO_INIT,0            ;automatic address offset initialized?
000A08 6E22           00637                 movwf   ADR_OFFSET,0                ;n: set it to this record's address
                      00638 
000A0A 8C20           00639                 bsf     FLAGS1,AO_INIT,0            ;address offset is now initialized  
000A0C                00640 d_rec1:
                      00641 
                      00642 ;Subtract off the address offset, and save the result in ADDRESSH.
                      00643 ;We will test the address of each received byte later, so that we
                      00644 ;can tolerate records that have some data within range, and some not.
000A0C 5022           00645                 movf    ADR_OFFSET,W,0
000A0E 5C0E           00646                 subwf   R1,W,0                      ;W= high(record address) minus offset
000A10 6E06           00647                 movwf   ADDRESSH,0
                      00648 
                      00649 ;Get address low byte and save it in ADDRESSL, preparing to load data
000A12 DFE8           00650                 rcall   get_byte_cksum              ;get address low byte into W & R1
000A14 6E05           00651                 movwf   ADDRESSL,0                  ;ADDRESSH:ADDRESSL will be used to move data
                      00652 
                      00653 ;If this is an Intel Hex record, get and validate record-type byte
000A16 A020           00654                 btfss   FLAGS1,INTEL_STATE,0
000A18 D007           00655                 bra     dr_get_data                 ;no record-type byte for S-records
                      00656 
000A1A DFE4           00657                 rcall   get_byte_cksum              ;get Intel Hex record type byte into R1
                      00658 
000A1C 520E           00659                 movf    R1,F,0                      ;test record type for type 0
000A1E E004           00660                 bz      dr_get_data                 ;zero is normal data record
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 17
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00661 
000A20 2E0E           00662                 decfsz  R1,F,0
000A22 D7CF           00663                 bra     rec_error                   ;any type higher than 1 is an error
                      00664 
                      00665 ;Validate Intel type 1 record
000A24 6610           00666                 tstfsz  R3,0                        ;byte count must be 0 for type 1 records
000A26 D7CD           00667                 bra     rec_error
                      00668 
                      00669 ;If this is a 0-byte record, then don't load any data. Just check its checksum and call it done.
000A28 5010           00670 dr_get_data:    movf    R3,W,0                      ;record byte count
000A2A E013           00671                 bz      dr_ckcum
                      00672 
000A2C 6E0F           00673                 movwf   R2,0                        ;R2 will be our loop counter
000A2E 9220           00674                 bcf     FLAGS1,A_STATE,0            ;Fits in buffer so far
                      00675 ;Loop to get R2 bytes of data in this record. If any of this record's data bytes
                      00676 ;do not fit in the buffer, then set ERR_FLAG.
000A30 DFD9           00677 dr_data_loop:       rcall   get_byte_cksum          ;get a hex data byte into W & R1
                      00678 
                      00679                     ;test to see if this byte will miss the buffer. Clear C and set ERR_FLAG if so
000A32 5006           00680                     movf    ADDRESSH,W,0
000A34 0820           00681                     sublw   high(SRAM_SIZE)         ;C cleared if high(EPROM address) > high(SRAM_SIZE)
000A36 A0D8           00682                     btfss   STATUS,C,0
000A38 8220           00683                     bsf     FLAGS1,A_STATE,0        ;remember not to count this page as sucessful
                      00684 
000A3A 500E           00685                     movf    R1,W,0                  ;recover received byte
000A3C B0D8           00686                     btfsc   STATUS,C,0              ;don't write if wrong page for this byte
000A3E EC18 F000      00687                     call    K_WRSRAM                ;write byte to buffer (trashes W, R0, R1)
                      00688 
000A42 4A05           00689                     infsnz  ADDRESSL,F,0            ;16-bit increment address pointer
000A44 2A06           00690                     incf    ADDRESSH,F,0
                      00691 
000A46 060F           00692                     decf    R2,F,0                  ;bump & test loop pointer
000A48 E1F3           00693                     bnz     dr_data_loop
                      00694 
                      00695 ;If all bytes in this record landed in the buffer, then count it as a successfully-loaded record.
000A4A B220           00696                 btfsc   FLAGS1,A_STATE,0        ;any data in this record not fit in the buffer?
000A4C D002           00697                 bra     dr_noload
                      00698 
000A4E 4A18           00699                 infsnz  COUNTL,F,0                  ;bump count of successfully-loaded records
000A50 2A19           00700                 incf    COUNTH,F,0
000A52                00701 dr_noload:
                      00702 
                      00703 ;Get and validate the record checksum
000A52 DFC8           00704 dr_ckcum:       rcall   get_byte_cksum              ;get checksum into Z
000A54 E1BC           00705                 bnz     cksum_error
                      00706 
                      00707 ;If this is a 0-byte record, then treat it as the eof. Otherwise, go get another record
000A56 5210           00708                 movf    R3,F,0                      ;record byte count
000A58 E105           00709                 bnz     dr_next_record              ;not 0 bytes: go get another record
                      00710 
000A5A A420           00711                 btfss   FLAGS1,B_STATE,0            ;is this an S5 record?
000A5C D00C           00712                 bra     dr_eof_rec                  ;no: this 0-byte record is the end of file
                      00713 
                      00714 ;S5 record is done - compare the number of records we have received (in COUNTH:COUNTL)
                      00715 ;to the value in ADDRESSL - the low byte of the address field, which is the record count
000A5E 0418           00716                 decf    COUNTL,W,0                  ;don't count this S5 record
000A60 6205           00717                 cpfseq  ADDRESSL,0                  ;compare to the S5 record's record count
000A62 DFB2           00718                 rcall   s5_error                    ;report S5 record count mismatch
                      00719 
                      00720 ;------------------------------------------------------------
                      00721 ; This record is done, and we expect another one. Print
                      00722 ; CR-LF, and go get another record, without printing a prompt
                      00723 ;------------------------------------------------------------
000A64 0E0D           00724 dr_next_record: movlw   CR                          ;K_CONOUT will add the LF
000A66 EC06 F000      00725                 call    K_CONOUT
000A6A D711           00726                 bra     no_prompt                   ;done with command, no prompt
                      00727 
                      00728 ;*------------------------------------------------------------------------------*
                      00729 ; This is a Motorola  S9 record (which specifies the record count) 
                      00730 ; It may be just 'S9', or may be complete S9 record.
                      00731 ;*------------------------------------------------------------------------------*
000A6C EC10 F000      00732 mot_s9:         call    K_GETCHR                ;test for CR
000A70 06E1           00733                 decf    FSR1L,F,0               ;put pointer back
000A72 A60C           00734                 btfss   KERN_FLAGS,CR_FLAG,0    ;was it the CR?
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 18
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000A74 D7A2           00735                 bra     mot_nodatarec           ;no: go get the rest of the rest of the record
                      00736 
                      00737 ;Fall into dr_eof_rec to finish download
                      00738 ;-----------------------------------------------------
                      00739 ; End of File record encountered.
                      00740 ; Report results
                      00741 ;-----------------------------------------------------
000A76 EE00 F080      00742 dr_eof_rec:     lfsr    0,reccount_msg-sstrings     ;'Records: '
000A7A D931           00743                 rcall   cr_printf2
000A7C C008 F00E      00744                 movff   RECOUNTH,R1                 ;total record count
000A80 C007 F00D      00745                 movff   RECOUNTL,R0
000A84 EC0B F000      00746                 call    K_PRINTDEC
                      00747 
000A88 EE00 F062      00748                 lfsr    0,errorcount_msg-sstrings   ;', Bad Records: '
000A8C ECF8 F009      00749                 call    printf
000A90 C00A F00E      00750                 movff   ERRCNTH,R1                  ;bad record count
000A94 C009 F00D      00751                 movff   ERRCNTL,R0
000A98 EC0B F000      00752                 call    K_PRINTDEC
                      00753 
000A9C 0E0D           00754                 movlw   CR
000A9E EC06 F000      00755                 call    K_CONOUT                    ;new line
                      00756 
000AA2 C019 F00E      00757                 movff   COUNTH,R1                   ;records loaded into buffer
000AA6 C018 F00D      00758                 movff   COUNTL,R0
000AAA EC0B F000      00759                 call    K_PRINTDEC
                      00760 
000AAE EE00 F08C      00761                 lfsr    0,loadcount_msg-sstrings    ;'records loaded in buffer with Address Offset: '
000AB2 ECF8 F009      00762                 call    printf
                      00763 
000AB6 5022           00764                 movf    ADR_OFFSET,W,0              ;current address offset
000AB8 EC0A F000      00765                 call    K_PRINTHEX2                 ;print address offset in hex
                      00766 
000ABC 0E68           00767                 movlw   'h'                         ;note that this is in hex
000ABE EC06 F000      00768                 call    K_CONOUT
                      00769 
                      00770 ;-------------------------------------------------------------------------
                      00771 ;Reset automatic address offset settings for next file, and return to main
                      00772 ;-------------------------------------------------------------------------
000AC2 AA20           00773                 btfss   FLAGS1,AO_MANUAL,0      ;automatic address offset mode?
000AC4 6A22           00774                 clrf    ADR_OFFSET,0            ;y:prepare for next file load
000AC6 9C20           00775                 bcf     FLAGS1,AO_INIT,0        ;de-initialize address offset
                      00776 
000AC8 0012           00777                 return                          ;finally return to main
                      00778 
                      00779 ;################################################################################
                      00780 ;#                      Main Command Execution Routines                         #
                      00781 ;################################################################################
                      00782 ;*******========================================================================*
                      00783 ;* BAO * Set Buffer Address Offset Command
                      00784 ;*******
                      00785 ; Sets an offset for the upper 8 bits of address for uploads and downloads
                      00786 ; On Entry:
                      00787 ;   DFLT_FLAG = 1 if the user did not provide an address offset value.
                      00788 ;   ADDRESSL = buffer address offset
                      00789 ;*==============================================================================*
000ACA 6606           00790 cmd_boffset:    tstfsz  ADDRESSH,0              ;no high byte allowed
000ACC D106           00791                 bra     cmd_error
                      00792 
000ACE C005 F017      00793                 movff   ADDRESSL,BUF_OFFSET     ;save input as the new buffer address offset
                      00794 
                      00795 ;Fall into rep_ba_offset to print the address offset, return to main
                      00796 
                      00797 ;*==============================================================================*
                      00798 ; Subroutine to report the buffer address offset
                      00799 ; On Entry:
                      00800 ;*==============================================================================*
000AD2 EE00 F048      00801 rep_ba_offset:  lfsr    0,boffset_msg-sstrings  ;'Buffer Address Offset: '
000AD6 D903           00802                 rcall   cr_printf2
                      00803 
000AD8 5017           00804                 movf    BUF_OFFSET,W,0          ;buffer address offset
000ADA EF0A F000      00805                 goto    K_PRINTHEX2             ;print buffer address offset and return
                      00806 
                      00807 ;*******========================================================================*
                      00808 ;* FAO * Set File Address Offset Command
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 19
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00809 ;*******
                      00810 ; Sets an offset for the upper 8 bits of address for uploads and downloads
                      00811 ; On Entry:
                      00812 ;   DFLT_FLAG = 1 if the user did not provide an address offset value.
                      00813 ;   ADDRESSL = file address offset
                      00814 ;*==============================================================================*
000ADE 6606           00815 cmd_foffset:    tstfsz  ADDRESSH,0              ;no high byte allowed
000AE0 D0FC           00816                 bra     cmd_error
                      00817 
000AE2 C005 F022      00818                 movff   ADDRESSL,ADR_OFFSET     ;save input as the new address offset
                      00819 
000AE6 9A20           00820                 bcf     FLAGS1,AO_MANUAL,0      ;assume automatic address offset
000AE8 9C20           00821                 bcf     FLAGS1,AO_INIT,0        ;address offset is no longer initialized    
                      00822 
000AEA A620           00823                 btfss   FLAGS1,DFLT_FLAG,0      ;was a parameter provided?
000AEC 8A20           00824                 bsf     FLAGS1,AO_MANUAL,0      ;y: address offset is now manual    
                      00825 
                      00826 ;Fall into rep_fa_offset to print the address offset, return to main
                      00827 
                      00828 ;*==============================================================================*
                      00829 ; Subroutine to report the file address offset, which may either be
                      00830 ; a value or 'automatic'
                      00831 ; On Entry:
                      00832 ;   AO_MANUAL  = 1 if manual address offset mode selected
                      00833 ;              = 0 if automatic address offset mode
                      00834 ;   ADR_OFFSET = address offset if manual mode
                      00835 ;*==============================================================================*
000AEE EE00 F0AC      00836 rep_fa_offset:  lfsr    0,foffset_msg-sstrings  ;'File Address Offset: '
000AF2 D8F5           00837                 rcall   cr_printf2
                      00838 
000AF4 5022           00839                 movf    ADR_OFFSET,W,0          ;manually-set address offset
                      00840 
000AF6 BA20           00841                 btfsc   FLAGS1,AO_MANUAL        ;manual address offset mode?
000AF8 EF0A F000      00842                 goto    K_PRINTHEX2             ;y: print file address offset and return
                      00843 
                      00844 ;File address offset is automatic
000AFC EE01 F072      00845                 lfsr    0,auto_msg-sstrings     ;'automatic'
000B00 EFF8 F009      00846                 goto    printf                  ;return from there
                      00847 
                      00848 ;*******========================================================================*
                      00849 ;* BD *  Display Buffer Command
                      00850 ;******
                      00851 ; Displays the specified range of buffer contents in human-readable form,
                      00852 ; followed by the checksum of the displayed range
                      00853 ; On Entry:
                      00854 ;    ADDRESSH:ADDRESSL = address
                      00855 ;    COUNTH:COUNTL = byte count
                      00856 ;    DFLT_FLAG = 1 if no parameters came with the command.
                      00857 ;    FULL_FLAG is cleared unless COUNTH:COUNTL = 8K
                      00858 ;*==============================================================================*
000B04 6A04           00859 cmd_bdisplay:   clrf    CHECKSUM,0              ;start buffer (range) checksum
                      00860 
                      00861 ;Print the address, (The first one may not be on a 16-byte boundary)
000B06 EC0A F00A      00862 bd_newline:         call    check_pause         ;give user a chance to pause (CTRL-S will pause too)
                      00863 
000B0A ECED F009      00864                     call    print_addr          ;start each line with its address
000B0E EC5F F00A      00865                     call    save_params         ;save address and count for ASCII
                      00866 
000B12 0E31           00867                     movlw   0x10*3+1            ;# of chrs for hex portion of line +1
000B14 6E10           00868                     movwf   R3,0
                      00869 
                      00870 ;Loop to print hex for every byte on this row. The row end when the address of the
                      00871 ;next byte has bits <3:0> = 0.
000B16 EC17 F000      00872 bd_loop:                call    K_RDSRAM        ;get a buffer byte into W
000B1A EC25 F00A      00873                         call    print_hex_csum  ;print it in hex, accumulate checksum
                      00874 
000B1E 0E20           00875                         movlw   ' '             ;print a space between hex bytes
000B20 EC06 F000      00876                         call    K_CONOUT
                      00877 
000B24 0E03           00878                         movlw   0x03            ;account for printed hex byte and space
000B26 5E10           00879                         subwf   R3,F,0          ;..so fewer spaces are required later
                      00880 
000B28 EC3C F00A      00881                         call    next_a_count    ;bump ADDRESSH:ADDRESSL, decrement COUNT, test
000B2C E003           00882                         bz      bd_ascii        ;all done? then finish up the ASCII too.
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 20
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00883 
000B2E 0E0F           00884                         movlw   0fh             ;test for least-sig nibble = 0
000B30 1405           00885                         andwf   ADDRESSL,W,0    ;Z set if the row is done
000B32 E1F1           00886                         bnz     bd_loop
000B34                00887 bd_ascii:
                      00888 
                      00889 ;Space over to the same column (column 56), regardless of how many hex characters were
                      00890 ;printed on this line. R3 has the number of required spaces.
000B34 0E20           00891 bd_sploop:              movlw   ' ';
000B36 EC06 F000      00892                         call    K_CONOUT
000B3A 0610           00893                         decf    R3,F,0
000B3C E1FB           00894                         bnz     bd_sploop           
                      00895 
                      00896 ;Loop to print ASCII characters for the line. Replace unprintable characters (below space,
                      00897 ;and also DEL=0x7F) with dots
000B3E EC68 F00A      00898                     call    restore_params      ;beginning of row and count
                      00899 
000B42 EC17 F000      00900 bd_aloop:               call    K_RDSRAM        ;get a buffer byte into W
000B46 0F01           00901                         addlw   0x01            ;because 0x7F is also not printable
000B48 0B7F           00902                         andlw   0x7F            ;strip parity
000B4A 0820           00903                         sublw   ' '             ;unprintable chr? carry set if unprintable
000B4C B0D8           00904                         btfsc   STATUS,C,0
000B4E 0EF1           00905                         movlw   ' '-'.'-0x01    ;dot, pre-distorted
                      00906 
000B50 081F           00907                         sublw   ' '-0x01        ;restore chr or dot
                      00908 
000B52 EC06 F000      00909                         call    K_CONOUT        ;print chr or dot
                      00910 
000B56 EC3C F00A      00911                         call    next_a_count    ;bump ADDRESSH:ADDRESSL, decrement COUNT, test
000B5A E004           00912                         bz      bd_sum          ;All done with entire BD?
                      00913 
000B5C 0E0F           00914                         movlw   0fh             ;test for least-sig nibble = 0
000B5E 1405           00915                         andwf   ADDRESSL,W,0    ;Z set if the ASCII for this row is done
000B60 E1F0           00916                         bnz     bd_aloop        ;finish ASCII for this row
                      00917 
000B62 D7D1           00918                     bra     bd_newline          ;next line
                      00919 
                      00920 ;Print buffer sum and quit. 
000B64 EE01 F022      00921 bd_sum:         lfsr    0,buffer_msg-sstrings   ;'Buffer '
000B68 EC59 F00A      00922                 call    prange                  ;print string, then 'range ' as needed
                      00923 
000B6C EE01 F02C      00924                 lfsr    0,csum_msg-sstrings     ;'checksum: '
000B70 ECF8 F009      00925                 call    printf                  ;print message
                      00926 
000B74 5004           00927                 movf    CHECKSUM,W,0            ;get buffer checksum
000B76 EF0A F000      00928                 goto    K_PRINTHEX2             ;print & return to main
                      00929 
                      00930 ;******=========================================================================*
                      00931 ;* BE * Edit Buffer Command
                      00932 ;******
                      00933 ; Allows user to interactively modify data in the buffer.
                      00934 ; Second command chr (in R4) must be 'B'
                      00935 ; On Entry:
                      00936 ;   ADDRESSH:ADDRESSL = address
                      00937 ; On Exit:
                      00938 ;   Normal exit is via ^C, detected by K_GETLIN
                      00939 ;*==============================================================================*
000B7A 84D8           00940 cmd_bedit:      bsf     STATUS,Z,0
                      00941                     
                      00942 ;If Z set, print buffer address, followed by ': '
000B7C B4D8           00943 mb_loop:            btfsc   STATUS,Z,0
000B7E ECED F009      00944                     call    print_addr
                      00945 
                      00946 ;print buffer data followed by a space
000B82 EC17 F000      00947                     call    K_RDSRAM                ;get buffer data
000B86 EC0A F000      00948                     call    K_PRINTHEX2             ;..and print it
000B8A 0E20           00949                     movlw   ' '                     ;space seperator
000B8C EC06 F000      00950                     call    K_CONOUT
                      00951 
                      00952 ;Get user input - either CR to skip, new hex value for this location, or ^C/ESC to quit
000B90 0E02           00953                     movlw   0x02                    ;max 2 characters
000B92 EC0E F000      00954                     call    K_GETLIN                ;get user input into buffer (trashes FSR0 & FSR1)
000B96 B00C           00955                     btfsc   KERN_FLAGS,ERR_FLAG,0   ;control-C or ESC?
000B98 0012           00956                     return                          ;y: abort (done)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 21
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00957 
000B9A EC14 F000      00958                     call    K_GETHEX4               ;get the 1st parameter
000B9E B00C           00959                     btfsc   KERN_FLAGS,ERR_FLAG     ;Bogus input?
000BA0 D09C           00960                     bra     cmd_error
                      00961 
000BA2 A20C           00962                     btfss   KERN_FLAGS,INP_FLAG,0   ;clear if no byte found
000BA4 D00C           00963                     bra     mb_nxtbyte              ;Z set if no input  
                      00964 
000BA6 C00E F011      00965                     movff   R1,R4                   ;temp save new value in R4
                      00966 
000BAA EC14 F000      00967                     call    K_GETHEX4               ;there shouldn't be anything more   
000BAE B20C           00968                     btfsc   KERN_FLAGS,INP_FLAG,0   ;clear if no byte found
000BB0 D094           00969                     bra     cmd_error               ;huh?
                      00970 
000BB2 5011           00971                     movf    R4,W,0                  ;recover user input
000BB4 EC18 F000      00972                     call    K_WRSRAM                ;overwrite buffer data with new user data
                      00973 
000BB8 0E20           00974                     movlw   ' '                     ;space separator
000BBA EC06 F000      00975                     call    K_CONOUT            
000BBE                00976 mb_nxtbyte:
                      00977 ;Every 8 bytes, print CR and address again.
                      00978 ;This will wrap to the beginning of the buffer if you keep going.
000BBE EC3C F00A      00979                     call    next_a_count            ;next address, with wrap
000BC2 0E07           00980                     movlw   0x07                    ;test for every 8th byte
000BC4 1405           00981                     andwf   ADDRESSL,W,0            ;set Z flag if we need to print the address
000BC6 D7DA           00982                     bra     mb_loop
                      00983 
                      00984 ;******=========================================================================*
                      00985 ;* BF * Fill EPROM Buffer Command
                      00986 ;******
                      00987 ; Fills all 8K of the EPROM buffer with the given value
                      00988 ; On Entry:
                      00989 ;   The second command chr (in R4) must be 'B'
                      00990 ;   ADDRESSL = fill value, defaulting to 0.
                      00991 ;   Undocumented: COUNT is the number of bytes to fill, starting at buffer
                      00992 ;   FULL_FLAG is cleared unless COUNTH:COUNTL = 8K
                      00993 ;   address 0
                      00994 ;*==============================================================================*
000BC8 6606           00995 cmd_fill:       tstfsz  ADDRESSH,0              ;no high byte allowed
000BCA D087           00996                 bra     cmd_error
                      00997 
000BCC C005 F00F      00998                 movff   ADDRESSL,R2             ;remember fill value
                      00999 
000BD0 EE01 F05C      01000                 lfsr    0,buffill_msg-sstrings  ;'Buffer filled with '
000BD4 D884           01001                 rcall   cr_printf2
                      01002 
000BD6 6A05           01003                 clrf    ADDRESSL,0              ;point to beginning of buffer
000BD8 6A06           01004                 clrf    ADDRESSH,0
                      01005 
                      01006 ;Loop to fill EPROM buffer
000BDA 500F           01007 fill_buf_loop:      movf    R2,W,0              ;get fill value
000BDC EC18 F000      01008                     call    K_WRSRAM            ;write to buffer
                      01009 
000BE0 EC3C F00A      01010                     call    next_a_count        ;bump address pointer, dec COUNT
000BE4 E1FA           01011                     bnz     fill_buf_loop       ;Z set when COUNT is 0000
                      01012 
000BE6 500F           01013                 movf    R2,W,0                  ;get fill value again
000BE8 EF0A F000      01014                 goto    K_PRINTHEX2             ;tell user fill value, return to main
                      01015 
                      01016 ;******=========================================================================*
                      01017 ;* DS *  Display Programmer State Command
                      01018 ;******
                      01019 ; Displays:
                      01020 ;  Kernel Loader revision
                      01021 ;  Curent EPROM type
                      01022 ;  Data invert state
                      01023 ;  Vpp setting
                      01024 ;  External voltage required
                      01025 ;  Address Offset
                      01026 ;  Echo State
                      01027 ; On Entry:
                      01028 ;    R4 = 2nd character of command
                      01029 ;===============================================================================*
000BEC EC0C F000      01030 cmd_dstate:     call    K_PRINTSN                   ;Print this unit's serial number
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 22
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01031 
000BF0 EE00 F0E8      01032                 lfsr    0,loaderrev_msg-sstrings    ;loader rev
000BF4 D874           01033                 rcall   cr_printf2
                      01034 
000BF6 EC01 F000      01035                 call    K_KERN_REV                  ;return loader revision in W
000BFA 6E0D           01036                 movwf   R0,0
000BFC 380D           01037                 swapf   R0,W,0                      ;print the major revision first
000BFE EC09 F000      01038                 call    K_PRINTHEX1
000C02 0E2E           01039                 movlw   '.'                         ;decimal point seperator
000C04 EC06 F000      01040                 call    K_CONOUT
000C08 EC01 F000      01041                 call    K_KERN_REV                  ;return loader revision in W
000C0C EC09 F000      01042                 call    K_PRINTHEX1                 ;now print the minor revision
                      01043 
000C10 EE01 F004      01044                 lfsr    0,fwrev_msg-sstrings        ;firmware revision message
000C14 DBF7           01045                 rcall   cr_printf
                      01046 
000C16 ECA2 F00A      01047                 call    rep_etype                   ;report current EPROM type
000C1A ECD1 F00A      01048                 call    rep_vpp                     ;Report the Vpp setting
                      01049 
000C1E 6A0F           01050                 clrf    R2,0                        ;no formatting
000C20 0E15           01051                 movlw   ET_VPPMSG
000C22 BC21           01052                 btfsc   FLAGS2,EXT_VPP,0            ;external supply required?
000C24 ECAF F00A      01053                 call    eds_print                   ;print the adjustment message
                      01054 
000C28 DF62           01055                 rcall   rep_fa_offset               ;file address offset
000C2A DF53           01056                 rcall   rep_ba_offset               ;buffer address offset
000C2C D841           01057                 rcall   rep_dinvert                 ;report data invert state
                      01058 
000C2E D8AA           01059                 rcall   rep_echo                    ;report echo state
                      01060 
                      01061  if DEBUG
                      01062                 lfsr    0,shared_msg-sstrings
                      01063                 rcall   cr_printf
                      01064                 movf    SHARED,W,0
                      01065                 call    K_PRINTHEX2
                      01066  endif
                      01067 
                      01068 ;Report successful and unsuccessful programmings
000C30 0E0D           01069                 movlw   CR
000C32 EC06 F000      01070                 call    K_CONOUT
                      01071 
000C36 0E1D           01072                 movlw   PROGCNT                     ;successful EPROM programmings
000C38 EC19 F000      01073                 call    K_RDEEPROM
000C3C 6E0D           01074                 movwf   R0,0
000C3E 0E1E           01075                 movlw   PROGCNT+1                   ;high byte
000C40 EC19 F000      01076                 call    K_RDEEPROM
000C44 6E0E           01077                 movwf   R1,0
000C46 EC0B F000      01078                 call    K_PRINTDEC                  ;print R1:R0 in decimal
                      01079 
000C4A EE06 F0F2      01080                 lfsr    0,ep_msg-sstrings           ;" EPROMS programmed "
000C4E DBD0           01081                 rcall   printf
                      01082 
000C50 EE07 F00A      01083                 lfsr    0,eps_msg-sstrings          ;"successfully"
000C54 DBCD           01084                 rcall   printf
                      01085 
000C56 0E0D           01086                 movlw   CR
000C58 EC06 F000      01087                 call    K_CONOUT
                      01088 
000C5C 0E1F           01089                 movlw   FAILCNT                     ;unsuccessful EPROM programmings
000C5E EC19 F000      01090                 call    K_RDEEPROM
000C62 6E0D           01091                 movwf   R0,0
000C64 0E20           01092                 movlw   FAILCNT+1                   ;high byte
000C66 EC19 F000      01093                 call    K_RDEEPROM
000C6A 6E0E           01094                 movwf   R1,0
000C6C EC0B F000      01095                 call    K_PRINTDEC                  ;print R1:R0 in decimal
                      01096 
000C70 EE06 F0F2      01097                 lfsr    0,ep_msg-sstrings           ;" EPROMS programmed "
000C74 DBBD           01098                 rcall   printf
                      01099 
000C76 EE07 F008      01100                 lfsr    0,epf_msg-sstrings          ;"unsuccessfully"
000C7A D3BA           01101                 bra     printf                      ;print, return to main
                      01102 
                      01103 ;******==========================================================================*
                      01104 ;* ED * Display EPROM Specifications Command (with pretty picture)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 23
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01105 ;******
                      01106 ; On Entry:
                      01107 ;   DFLT_FLAG set if no parameters came with this command
                      01108 ;   ADDRESSL = requested EPROM
                      01109 ;===============================================================================*
000C7C 6606           01110 cmd_dispeprom:  tstfsz  ADDRESSH,0              ;no high byte allowed 
000C7E D02D           01111                 bra     cmd_error
                      01112 
000C80 EC7F F00A      01113                 call    save_etype              ;save ETYPE while we work
                      01114 
000C84 B620           01115                 btfsc   FLAGS1,DFLT_FLAG,0      ;any value from user?
000C86 C01E F005      01116                 movff   ETYPE_SAVE,ADDRESSL     ;n: use the current EPROM
000C8A 5005           01117                 movf    ADDRESSL,W,0
                      01118 
000C8C 082B           01119                 sublw   FEPROM_COUNT+CEPROM_COUNT-1 ;legal value?
000C8E A0D8           01120                 btfss   STATUS,C,0              ;Carry set if ADDRESS <= max allowed EPROM
000C90 D024           01121                 bra     cmd_error
                      01122 
000C92 5005           01123                 movf    ADDRESSL,W,0            ;temp set ETYPE to user input
000C94 EC1A F000      01124                 call    K_WREEPROM              ;K_RDEEPROM left EEADR pointing to ETYPE
                      01125 
000C98 EC49 F00F      01126                 call    dispeprom
                      01127 
000C9C EF84 F00A      01128                 goto    restore_etype           ;Done: restore ETYPE and go to main
                      01129 
                      01130 ;******=========================================================================*
                      01131 ;* DI * Set EPROM Data Invert State Command
                      01132 ;******
                      01133 ; Turns EPROM data invert off/on
                      01134 ; On Entry:
                      01135 ;   ADDRESSL = 0 or 1 for off or on
                      01136 ;===============================================================================*
000CA0 DA2B           01137 cmd_dinvert:    rcall   test_01                 ;check for valid user input
                      01138 
000CA2 0E21           01139                 movlw   DINV_STATE              ;this variable is in EEPROM
000CA4 6EA9           01140                 movwf   EEADR,0                 ;..at this location
                      01141 
000CA6 5005           01142                 movf    ADDRESSL,W,0            ;result to W, set Z if 0
000CA8 A4D8           01143                 btfss   STATUS,Z,0              ;if not zero, make it FF
000CAA 0EFF           01144                 movlw   0xFF
                      01145 
000CAC EC1A F000      01146                 call    K_WREEPROM
                      01147 
                      01148 ;Fall into rep_dinvert to report data invert state, return to main
                      01149 
                      01150 ;*==============================================================================*
                      01151 ; Subroutine to report the EPROM data invert state
                      01152 ; Trashes W,R2
                      01153 ;*==============================================================================*
000CB0 0E01           01154 rep_dinvert:    movlw   0x01                    ;print always
000CB2 D001           01155                 bra     rep_di
                      01156 
                      01157 ;*==============================================================================*
                      01158 ; Subroutine to report the EPROM data invert state only if it is on
                      01159 ; Trashes W,R2
                      01160 ;*==============================================================================*
000CB4 0E00           01161 rep_dion:       movlw   0x00                    ;print always
                      01162 
                      01163 ;Fall into rep_di
                      01164 
                      01165 ;*==============================================================================*
                      01166 ; Local subroutine to report the EPROM data invert state
                      01167 ; On Entry:
                      01168 ;    W=0: only report invert state if it is on
                      01169 ;    W<>0: Always report invert state
                      01170 ; Trashes W,R2
                      01171 ;*==============================================================================*
000CB6 6E0F           01172 rep_di:         movwf   R2,0                    ;temp save input
                      01173 
000CB8 EE01 F048      01174                 lfsr    0,dinvert_msg-sstrings  ;"EPROM data invert"
                      01175 
000CBC 0E21           01176                 movlw   DINV_STATE              ;this variable is in EEPROM
000CBE EC19 F000      01177                 call    K_RDEEPROM              ;Z set if 0
000CC2 E004           01178                 bz      rep_di1
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 24
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01179 
000CC4 DB9F           01180                 rcall   cr_printf
000CC6 EE04 F036      01181                 lfsr    0,on_msg-sstrings
000CCA D392           01182                 bra     printf                  ;always print if invert is on
                      01183 
                      01184 ;Data invert is off, and hterefore only printed if R2<>0
000CCC 520F           01185 rep_di1:        movf    R2,F,0                  ;print if invert is off?
000CCE B4D8           01186                 btfsc   STATUS,Z,0
000CD0 0012           01187                 return                          ;n: done
                      01188 
000CD2 DB98           01189                 rcall   cr_printf
000CD4 EE04 F03C      01190                 lfsr    0,off_msg-sstrings
000CD8 D38B           01191                 bra     printf
                      01192 
                      01193 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                      01194 ; Common Routine
                      01195 ;   Bad command of some sort - print command error message and return to main
                      01196 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
000CDA EE00 F01E      01197 cmd_error:      lfsr    0,bad_input_msg-sstrings    ;indicate error
                      01198 
                      01199 ;Fall into cr_printf2 to print and return to main
                      01200 
                      01201 ;this is here just to allow rcall's instead of calls
000CDE D392           01202 cr_printf2:     bra     cr_printf
                      01203 
                      01204 ;******=========================================================================*
                      01205 ;* ET * Set EPROM Type Command
                      01206 ;******
                      01207 ; selects the EPROM type
                      01208 ; On Entry:
                      01209 ;   DFLT_FLAG set if no parameters came with this command
                      01210 ;   ADDRESSL = EPROM type, 0 means none selected
                      01211 ; On Exit:
                      01212 ;   ETYPE is set for the selected EPROM
                      01213 ;   Vpp power supply is set to the correct voltage
                      01214 ;   EXT_VPP is set (and Vpp=0V) iff an external supply is required
                      01215 ;   ADJ_VPP is set iff the onboard supply requires manual adjustment
                      01216 ;   ADJ_VCC is set iff hte programming Vcc requires manual adjustment
                      01217 ;   PMODE1:PMODE0 are set for this EPROM
                      01218 ;   PROGPULSE set for this EPROM (note: this is a 16-bit value)
                      01219 ;*==============================================================================*
000CE0 B620           01220 cmd_etype:      btfsc   FLAGS1,DFLT_FLAG,0      ;any value with the command?
000CE2 EFA2 F00A      01221                 goto    rep_etype               ;no: just report 
                      01222 
000CE6 6606           01223                 tstfsz  ADDRESSH,0              ;no high byte allowed
000CE8 D7F8           01224                 bra     cmd_error
                      01225 
000CEA 5005           01226                 movf    ADDRESSL,W,0
000CEC 082B           01227                 sublw   FEPROM_COUNT+CEPROM_COUNT-1 ;legal value?
000CEE E3F5           01228                 bnc     cmd_error               ;Carry set if ADDRESS <= max allowed EPROM
                      01229 
                      01230 ;See if previous EPROM type had custom Vcc or Vpp
000CF0 0E22           01231                 movlw   ET_SPECIAL
000CF2 EC61 F00C      01232                 call    etype_getval            ;result in W and R0
000CF6 6E13           01233                 movwf   R6,0                    ;remember for later 
                      01234 
                      01235 ;Save old ETYPE in case this one's bogus
000CF8 EC7F F00A      01236                 call    save_etype              ;save ETYPE while we work
                      01237                                                 ;..and set EEADR to ETYPE
                      01238 ;Set the new ETYPE, and make sure it is defined
000CFC 5005           01239                 movf    ADDRESSL,W,0            ;remember EPROM type
000CFE EC1A F000      01240                 call    K_WREEPROM              ;write to address EEADR=ETYPE
                      01241 
000D02 0E00           01242                 movlw   ET_NAME
000D04 EC61 F00C      01243                 call    etype_getval            ;first chr of the name=0 means invalid entry
000D08 0900           01244                 iorlw   0x00
000D0A E017           01245                 bz      etype_invalid
                      01246 
                      01247 ;Set up programming parameters for this EPROM
000D0C ECA2 F00A      01248                 call    rep_etype               ;report new EPROM type
000D10 ECE9 F00A      01249                 call    etype_setup             ;set up Vpp supply, etc.
                      01250 
                      01251 ;Remind user to readjust Vpp and/or Vcc, and remove Intersil jumper, if necessary.
                      01252 ;R6 = previous EPROM type's ET_SPECIAL value
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 25
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000D14 0E22           01253                 movlw   ET_SPECIAL
000D16 EC61 F00C      01254                 call    etype_getval            ;does new EPROM type have custom voltages?
000D1A 0B03           01255                 andlw   0x03                    ;just custom Vpp and Vcc bits
000D1C 0A03           01256                 xorlw   0x03                    ;invert bits
000D1E 1613           01257                 andwf   R6,F,0                  ;was custom and is no longer custom?
                      01258 
000D20 EE05 F016      01259                 lfsr    0,readjvcc_msg-sstrings ;"Readjust 6.2V suppy to 6.20V"
000D24 B013           01260                 btfsc   R6,0x00,0
000D26 DB6E           01261                 rcall   cr_printf
                      01262 
000D28 EE05 F03A      01263                 lfsr    0,readjvp_msg-sstrings  ;"Readjust Vpp suppy to nominal"
000D2C B213           01264                 btfsc   R6,0x01,0
000D2E DB6A           01265                 rcall   cr_printf
                      01266 
000D30 EE05 F05E      01267                 lfsr    0,removej_msg-sstrings  ;"Remove Intersil jumper and external supply"
000D34 B413           01268                 btfsc   R6,0x02,0
000D36 DB66           01269                 rcall   cr_printf
                      01270 
000D38 D340           01271                 bra     epower_off
                      01272 
                      01273 ;--------------------------------------------------------------------------
                      01274 ; The requested etype entry is invalid. Put the old one back and error-exit
                      01275 ;--------------------------------------------------------------------------
000D3A DBE6           01276 etype_invalid:  rcall   restore_etype           ;Restore ETYPE
                      01277 
000D3C EE03 F068      01278                 lfsr    0,undef_msg-sstrings    ;"Error: Undefined custom EPROM"
000D40 D361           01279                 bra     cr_printf               ;print message, return to main
                      01280 
                      01281 ;******=========================================================================*
                      01282 ;* EC * EPROM Compare to Buffer Command
                      01283 ;******
                      01284 ; Compares EPROM data to buffer data and reports differences
                      01285 ; On Entry:
                      01286 ;   ADDRESSH:ADDRESSL = starting buffer address & EPROM address
                      01287 ;   COUNT_LOW:COUNT_HIGH = byte count of region to checksum
                      01288 ;   FULL_FLAG is cleared unless COUNTH:COUNTL = 8K
                      01289 ;   ERR_FLAG is cleared
                      01290 ;   B_STATE is cleared, telling rep_mismatch this is not an EPROM blank-check
                      01291 ; On Exit:
                      01292 ;    EPROM is powered off
                      01293 ;*==============================================================================*
000D42 DB86           01294 cmd_compare:    rcall   limit_count         ;limit the count to a full EPROM, max
                      01295 
                      01296 ;Tell the user about the buffer address offset and invert state
000D44 DEC6           01297                 rcall   rep_ba_offset
000D46 DFB6           01298                 rcall   rep_dion            ;only mention invert state if it is set
                      01299 
                      01300 ;Fall into eb_compare
                      01301 
                      01302 ;*==============================================================================*
                      01303 ; Subroutine to compare EPROM data to buffer data and report differences
                      01304 ; On Entry:
                      01305 ;   ADDRESSH:ADDRESSL = starting buffer address & EPROM address
                      01306 ;   COUNT_LOW:COUNT_HIGH = byte count of region to compare
                      01307 ;   ERR_FLAG is cleared
                      01308 ;   B_STATE is cleared, telling rep_mismatch this is not an EPROM blank-check
                      01309 ; On Exit:
                      01310 ;   ERR_FLAG set if any errors detected
                      01311 ;   The EPROM is powered off
                      01312 ; Trashes W,R0,R3,FSR0
                      01313 ;*==============================================================================*
000D48 DB28           01314 eb_compare:     rcall   epower_read             ;power up the EPROM for reading
                      01315 
000D4A DBA0           01316                 rcall   ep_compare
                      01317 
000D4C EE01 F09A      01318                 lfsr    0,cmpgood_msg-sstrings  ;good compare message, just in case
000D50 B00C           01319                 btfsc   KERN_FLAGS,ERR_FLAG     ;any errors?
000D52 EE01 F0C2      01320                 lfsr    0,fail_msg-sstrings     ;then don't print success message       
000D56 DB4C           01321                 rcall   printf                  ;finish success/fail message
                      01322 
000D58 D330           01323                 bra     epower_off              ;power down, return from there
                      01324 
                      01325 ;******=========================================================================*
                      01326 ;* EB * EPROM Blank Check Command
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 26
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01327 ;******
                      01328 ; Verify that the specified region of the EPROM is erased (all bytes=FF)
                      01329 ; On Entry:
                      01330 ;   ADDRESSH:ADDRESSL = starting buffer address & EPROM address
                      01331 ;   COUNT_LOW:COUNT_HIGH = byte count of region to checksum
                      01332 ;   FULL_FLAG is cleared unless COUNTH:COUNTL = 8K
                      01333 ;   ERR_FLAG is cleared
                      01334 ;   EPROM is already powered up for reading
                      01335 ; On Exit:
                      01336 ;   EPROM is powered off
                      01337 ;*==============================================================================*
000D5A DB1F           01338 cmd_blankchk:   rcall   epower_read             ;power up the EPROM
000D5C DB79           01339                 rcall   limit_count             ;limit the count to a full EPROM, max
                      01340 
000D5E 0E21           01341                 movlw   DINV_STATE              ;Get invert state
000D60 EC19 F000      01342                 call    K_RDEEPROM
000D64 6E11           01343                 movwf   R4,0
000D66 1E11           01344                 comf    R4,F,0                  ;invert unless eread_byte will be inverting
                      01345 
                      01346 ;Go blank check the EPROM, with R4 being what a blank EPROM byte contains
000D68 8420           01347                 bsf     FLAGS1,B_STATE,0        ;tell ep_compare this is an EPROM blank-check
000D6A DB90           01348                 rcall   ep_compare
                      01349 
                      01350 ;Finish printing results
000D6C EE01 F0AA      01351                 lfsr    0,isblank_msg-sstrings  ;message if blank
000D70 B00C           01352                 btfsc   KERN_FLAGS,ERR_FLAG     ;any errors?
000D72 EE01 F0C2      01353                 lfsr    0,fail_msg-sstrings     ;then don't print success message
000D76 DB3C           01354                 rcall   printf
                      01355 
000D78 D320           01356                 bra     epower_off              ;power off, return to main
                      01357 
                      01358 ;********=======================================================================*
                      01359 ;* ECHO * Set Terminal Echo State Command
                      01360 ;********
                      01361 ; Turns Echo off/on
                      01362 ; On Entry:
                      01363 ;   DFLT_FLAG set if no parameters came with this command
                      01364 ;     (in which case, turn echo on.)
                      01365 ;   ADDRESSL = 0 or 1 for off or on
                      01366 ;*==============================================================================*
000D7A D9BE           01367 cmd_echo:       rcall   test_01                     ;test for legal input value
000D7C 940C           01368                 bcf     KERN_FLAGS,ECHO_FLAG,0      ;turn echo off for the moment
                      01369 
000D7E A620           01370                 btfss   FLAGS1,DFLT_FLAG,0          ;default to on if no value given
000D80 B005           01371                 btfsc   ADDRESSL,0x00,0
000D82 840C           01372                 bsf     KERN_FLAGS,ECHO_FLAG,0      ;turn echo on
                      01373 
                      01374 ;Fall into rep_echo to report echo state, return to main
                      01375 
                      01376 ;*==============================================================================*
                      01377 ; Subroutine to report the echo state
                      01378 ;*==============================================================================*
000D84 EE01 F040      01379 rep_echo:       lfsr    0,echostate_msg-sstrings    ;echo state
000D88 DB3D           01380                 rcall   cr_printf
                      01381             
000D8A EE04 F03C      01382                 lfsr    0,off_msg-sstrings
000D8E B40C           01383                 btfsc   KERN_FLAGS,ECHO_FLAG,0
000D90 EE04 F036      01384                 lfsr    0,on_msg-sstrings
000D94 D32D           01385                 bra     printf                      ;return from there
                      01386 
                      01387 ;******=========================================================================*
                      01388 ;* EL * List Supported EPROM Types Command
                      01389 ;******
                      01390 ; Print list of supported EPROMs in up to 3 columns. This assumes that the
                      01391 ; total number of EPROMs supported is less than or equal to 3*LISTROWS.
                      01392 ;*==============================================================================*
000D96 EE02 F0F8      01393 cmd_eplist:     lfsr    0,elist_msg-sstrings    ;"Supported EPROMs:"
000D9A DB34           01394                 rcall   cr_printf
                      01395 
000D9C DBB0           01396                 rcall   save_etype              ;save ETYPE while we work
                      01397 
000D9E 6A11           01398                 clrf    R4,0                    ;walk through all known EPROM types
000DA0 0E10           01399                 movlw   LISTROWS                ;print this many rows
000DA2 6E12           01400                 movwf   R5,0                    ;row counter                
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 27
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01401 
000DA4 D80E           01402 le_loop:            rcall   le_eprom            ;print the 1st column EPROM
                      01403 
000DA6 0E10           01404                     movlw   LISTROWS
000DA8 2611           01405                     addwf   R4,F,0              ;2nd column
000DAA D80B           01406                     rcall   le_eprom            ;print the 2nd column EPROM
                      01407 
000DAC 0E10           01408                     movlw   LISTROWS
000DAE 2611           01409                     addwf   R4,F,0              ;3rd column
000DB0 D808           01410                     rcall   le_eprom            ;print the 3rd column EPROM
                      01411 
000DB2 0E1F           01412                     movlw   (2*LISTROWS)-1      ;next row, 1st column
000DB4 5E11           01413                     subwf   R4,F,0
                      01414 
000DB6 0E0D           01415                     movlw   CR                  ;next line
000DB8 EC06 F000      01416                     call    K_CONOUT
                      01417 
000DBC 0612           01418                     decf    R5,F,0
000DBE E1F2           01419                     bnz     le_loop
                      01420 
000DC0 D3A3           01421                 bra     restore_etype           ;Done: restore ETYPE and go to main
                      01422                 
                      01423 ;-----------------------------------------------------------------------
                      01424 ; Local suproutine to print the type & name of an EPROM
                      01425 ; If the number is greater than the max, then just return. If the
                      01426 ; first character of the EPROM name is 0 then print "Unassigned".
                      01427 ; On Entry:
                      01428 ;   R4 = the EPROM number
                      01429 ;-----------------------------------------------------------------------
000DC2 5011           01430 le_eprom:       movf    R4,W,0                      ;EPROM number
000DC4 082B           01431                 sublw   FEPROM_COUNT+CEPROM_COUNT-1 ;legal EPROM number?
000DC6 A0D8           01432                 btfss   STATUS,C,0                  ;Carry set if ADDRESS <= max allowed EPROM
000DC8 0012           01433                 return                              ;n: just return
                      01434 
000DCA 0E1C           01435                 movlw   ETYPE                       ;set ETYPE for etype_getval & eds_print
000DCC 6EA9           01436                 movwf   EEADR,0
000DCE 5011           01437                 movf    R4,W,0
000DD0 EC1A F000      01438                 call    K_WREEPROM
                      01439 
000DD4 5011           01440                 movf    R4,W,0                      ;Print the EPROM number
000DD6 EC0A F000      01441                 call    K_PRINTHEX2
                      01442 
000DDA EE03 F03C      01443                 lfsr    0,colonspace_msg-sstrings   ;colon and space
000DDE DB08           01444                 rcall   printf
                      01445 
000DE0 EE03 F086      01446                 lfsr    0,unassgn_msg-sstrings      ;"Unassigned"
                      01447 
000DE4 0E00           01448                 movlw   ET_NAME
000DE6 EC61 F00C      01449                 call    etype_getval                ;read the first chr of the name string
000DEA 0900           01450                 iorlw   0x00                        ;0 means unassigned EPROM type
000DEC B4D8           01451                 btfsc   STATUS,Z,0                  ;if first chr is zero
000DEE D300           01452                 bra     printf                      ;..then print "unassigned" and return
                      01453 
000DF0 0E0C           01454                 movlw   .12                         ;print in 16-wide field
000DF2 6E0F           01455                 movwf   R2,0
000DF4 0E00           01456                 movlw   ET_NAME
000DF6 D3B3           01457                 bra     eds_print                   ;print the EPROM name string & return
                      01458 
                      01459 ;******=========================================================================*
                      01460 ;* EP * EPROM Program Command
                      01461 ;******
                      01462 ; Programs EPROM from buffer, with verify
                      01463 ; On Entry:
                      01464 ;   ET_PROGREPS has the required number of programming cycles
                      01465 ;     (cycle limit if smart)
                      01466 ;   ADDRESSH:ADDRESSL=starting buffer address
                      01467 ;   COUNTH:COUNTL=number of bytes to program
                      01468 ;   B_STATE is cleared, so rep_mismatch will know this is not a blank-check
                      01469 ;   ERR_FLAG is cleared
                      01470 ;   EPROM is already powered up for reading
                      01471 ;   Unassigned pins are at 0V
                      01472 ;*==============================================================================*
000DF8 DAD0           01473 cmd_program:    rcall   epower_read             ;power up the EPROM for reading
000DFA DB2A           01474                 rcall   limit_count             ;limit the count to a full EPROM, max
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 28
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000DFC DB60           01475                 rcall   save_params             ;make copies of ADDRESSH:ADDRESSL and COUNTH:COUNT
                      01476 
                      01477 ;Tell the user about the buffer address offset and data invert state
000DFE DE69           01478                 rcall   rep_ba_offset
000E00 DF59           01479                 rcall   rep_dion                ;only mention invert state if it is set
                      01480 
                      01481 ;Ask the user if s/he is ready, warning him/her about the danger of a backwards EPROM etc.
000E02 EE0A F0D4      01482                 lfsr    0,ready2prog_msg-sstrings
000E06 DB1C           01483                 rcall   ask_yn                  ;ask if the user is ready
                      01484 
                      01485 ;-------------------------------------------------------------------------------
                      01486 ; Blank-check the selected region of the EPROM, unless it's an EEPROM. We don't
                      01487 ; use the same loop as th EC command because we don't report which bytes fail
                      01488 ; here - we just want a yes/no is the region blank.
                      01489 ; A blank EPROM byte reads as 0xFF, which eread_byte will invert if DINV_STATE
                      01490 ; is set.
                      01491 ;-------------------------------------------------------------------------------
000E08 0E22           01492                 movlw   ET_SPECIAL              ;check for EEPROM bit
000E0A EC61 F00C      01493                 call    etype_getval
000E0E 0B08           01494                 andlw   0x08                    ;this bit means don't blank check
000E10 E10E           01495                 bnz     epbc_blank
                      01496 
000E12 0E21           01497                 movlw   DINV_STATE              ;Get invert state
000E14 EC19 F000      01498                 call    K_RDEEPROM
000E18 6E11           01499                 movwf   R4,0
000E1A 1E11           01500                 comf    R4,F,0                  ;invert unless eread_byte will be inverting
                      01501 
000E1C DA7D           01502 epbc_loop:          rcall   eread_byte          ;read a byte, which may have been inverted
000E1E 1811           01503                     xorwf   R4,W,0              ;invert unless it is already
000E20 E103           01504                     bnz     epbc_notblank
000E22 DB2A           01505                     rcall   next_a_count        ;bump address pointer, dec count
000E24 E1FB           01506                     bnz     epbc_loop
000E26 D003           01507                     bra     epbc_blank
                      01508 
                      01509 ;If non-blank programming range, ask the user should we continue?
000E28 EE05 F08E      01510 epbc_notblank:  lfsr    0,notblank_msg-sstrings ;Not blank. Program anyway?
000E2C DB09           01511                 rcall   ask_yn                  ;abort if user says no
000E2E                01512 epbc_blank:
                      01513 
                      01514 ;------------------------
                      01515 ; Set up for programming
                      01516 ;-----------------------
000E2E DA8B           01517                 rcall   epower_prog                 ;set power supplies for programming
                      01518 
000E30 6AD7           01519                 clrf    TMR0H,0                     ;restart the pacifier timer(not really necessary) 
000E32 6AD6           01520                 clrf    TMR0L,0                     ;TMR0L must be written after TMR0H (page 146)
                      01521 
000E34 EE02 F0CE      01522                 lfsr    0,programing_msg-sstrings   ;Announce programming
000E38 DAE5           01523                 rcall   cr_printf
000E3A DB7F           01524                 rcall   wait_txempty                ;finish printing message before blocking ints
                      01525 
                      01526 ;---------------------------------------------------
                      01527 ; Programming Phase 1:
                      01528 ; If we are using the simple programming algorithm
                      01529 ; then loop through the EPROM range PROGREPS times.
                      01530 ;Otherwise, loop through the range just once.
                      01531 ;---------------------------------------------------
000E3C 5027           01532                 movf    PROGREPS,W,0            ;R7 counts cycles for simple programming
000E3E 6628           01533                 tstfsz  SMART1,0                ;SMART1 = 0 means not smart
000E40 0E01           01534                 movlw   0x01                    ;just one pass for smart programming
                      01535 
000E42 6E14           01536                 movwf   R7,0                    ;R7 counts passes for Phase 1
                      01537 
000E44 C028 F013      01538 prog_loop1:         movff   SMART1,R6           ;get 1st pass programming mode
000E48 D95E           01539                     rcall   ewrite_range        ;write the range once (trashes R0-R5)
000E4A 0614           01540                     decf    R7,F,0
000E4C E1FB           01541                     bnz     prog_loop1
                      01542 
                      01543 ;---------------------------------------------------
                      01544 ; Programming Phase 2:
                      01545 ; Once more through the EPROM, if specified
                      01546 ;---------------------------------------------------
000E4E 5029           01547                 movf    SMART2,W,0              ;get & test 2nd pass programming mode
000E50 6E13           01548                 movwf   R6,0
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 29
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000E52 A4D8           01549                 btfss   STATUS,Z,0              ;there may not be a 2nd pass.
000E54 D958           01550                 rcall   ewrite_range            ;write the range once (trashes R0-R5)
                      01551 
000E56 DAB1           01552                 rcall   epower_off              ;turn off the programming voltages etc.
                      01553 
                      01554 ;----------------------------
                      01555 ; Verify the programmed range
                      01556 ;----------------------------
000E58 EE02 F0EC      01557                 lfsr    0,verifying_msg-sstrings    ;announce verify step
000E5C DAD3           01558                 rcall   cr_printf
                      01559 
                      01560 ;Compare the EPROM to the buffer, and report errors to the console
000E5E DB38           01561                 rcall   restore_params          ;recover original starting address & byte count         
                                    
                      01562 
000E60 DF73           01563                 rcall   eb_compare              ;compare EPROM to buffer
                      01564 
                      01565 ;Bump either the successful program or the unsucessful program counter
000E62 0E1D           01566                 movlw   PROGCNT 
000E64 B00C           01567                 btfsc   KERN_FLAGS,ERR_FLAG     ;any errors?
000E66 0E1F           01568                 movlw   FAILCNT
000E68 6E0E           01569                 movwf   R1,0                    ;temp save
                      01570 
000E6A EC19 F000      01571                 call    K_RDEEPROM              ;load counter low byte
                      01572                                                 ;..and set EEADR to PROGCNT or FAILCNT
000E6E 0F01           01573                 addlw   0x01                    ;bump
000E70 6E0F           01574                 movwf   R2,0                    ;temp save
                      01575 
000E72 EC1A F000      01576                 call    K_WREEPROM              ;write W at address EEADR
                      01577 
000E76 520F           01578                 movf    R2,F,0                  ;need to bump high byte?
000E78 E106           01579                 bnz     ep_bumpdone
                      01580 
000E7A 280E           01581                 incf    R1,W,0                  ;point to high byte
000E7C EC19 F000      01582                 call    K_RDEEPROM              ;load counter low byte
                      01583                                                 ;..and set EEADR to PROGCNT+1 or FAILCNT+1
000E80 0F01           01584                 addlw   0x01                    ;bump
000E82 EC1A F000      01585                 call    K_WREEPROM              ;write W at address EEADR
                      01586 
000E86 0012           01587 ep_bumpdone:    return                          ;to main
                      01588                 
                      01589 ;******=========================================================================*
                      01590 ;* ES * EPROM Checksum Command
                      01591 ;******
                      01592 ; Compute and report the low byte of the sum of the entire EPROM's data
                      01593 ; On Entry:
                      01594 ;   ADDRESSH:ADDRESSL = starting buffer address & EPROM address
                      01595 ;   COUNTH:COUNTL = byte count of region to checksum
                      01596 ;   FULL_FLAG is cleared unless COUNTH:COUNTL = 8K
                      01597 ;   ERR_FLAG is cleared
                      01598 ; On Exit:
                      01599 ;   EPROM is powered off
                      01600 ;*==============================================================================*
000E88 8420           01601 cmd_cksum:      bsf     FLAGS1,B_STATE,0        ;indicate checksum pass
                      01602 
                      01603 ;Fall into cmd_read to recycle code
                      01604 
                      01605 ;******=========================================================================*
                      01606 ;* ER * EPROM Read Command
                      01607 ;******
                      01608 ; EPROM Checksum just computes and reports the low byte of the sum of the entire
                      01609 ;  EPROM's data. EPROM Read also writes the EPROM data into the buffer.
                      01610 ; On Entry:
                      01611 ;   B_STATE cleared for read command, set for checksum command
                      01612 ;   ADDRESSH:ADDRESSL = starting EPROM address
                      01613 ;   (ADDRESSH+BUF_OFFSET):ADDRESSL = starting buffer address
                      01614 ;   COUNTH:COUNTL = byte count of region to checksum
                      01615 ;   FULL_FLAG is cleared unless COUNTH:COUNTL = 8K
                      01616 ;   ERR_FLAG is cleared
                      01617 ; On Exit:
                      01618 ;   EPROM is powered off
                      01619 ;*==============================================================================*
000E8A DA87           01620 cmd_read:       rcall   epower_read             ;power up the EPROM
000E8C DAE1           01621                 rcall   limit_count             ;limit the count to a full EPROM, max
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 30
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000E8E 6A04           01622                 clrf    CHECKSUM,0              ;accumulate checksum here
                      01623 
                      01624 ;Tell the user about the buffer address offset for read-buffer only
000E90 A420           01625                 btfss   FLAGS1,B_STATE,0        ;read or checksum?
000E92 DE1F           01626                 rcall   rep_ba_offset           ;read: report buffer address offset
                      01627 
                      01628 ;Tell the user about the data invert state if it is on
000E94 DF0F           01629                 rcall   rep_dion                ;only mention invert state if it is set
                      01630 
                      01631 ;Read EPROM, and add up the data for the checksum
000E96 DA40           01632 esum_rd_loop:       rcall   eread_byte          ;read EPROM at ADDRESSH:ADDRESSL,
                      01633                                                 ;..result in W & R2
000E98 2604           01634                     addwf   CHECKSUM,F,0
                      01635 
000E9A 5017           01636                     movf    BUF_OFFSET,W,0      ;buffer address offset
000E9C 2606           01637                     addwf   ADDRESSH,F,0        ;compute buffer address
                      01638     
000E9E 500F           01639                     movf    R2,W,0              ;recover EPROM data
                      01640 
000EA0 A420           01641                     btfss   FLAGS1,B_STATE,0    ;read or checksum?
000EA2 EC18 F000      01642                     call    K_WRSRAM            ;read: write EPROM data to buffer
                      01643                                                 ;..at ADDRESSH:ADDRESSL
                      01644 
000EA6 5017           01645                     movf    BUF_OFFSET,W,0      ;buffer address offset
000EA8 5E06           01646                     subwf   ADDRESSH,F,0        ;restore EPROM address
                      01647 
000EAA DAE6           01648                     rcall   next_a_count        ;bump address pointer, decrement & test count
000EAC E1F4           01649                     bnz     esum_rd_loop
                      01650 
                      01651 ;Print results
000EAE DAFF           01652                 rcall   eprange                 ;print 'EPROM, then 'range ' if needed
                      01653 
000EB0 EE01 F086      01654                 lfsr    0,read_msg-sstrings     ;'read into buffer. '
000EB4 A420           01655                 btfss   FLAGS1,B_STATE,0        ;EPROM read?
000EB6 DA9C           01656                 rcall   printf                  ;print message
                      01657 
000EB8 EE01 F02C      01658                 lfsr    0,csum_msg-sstrings     ;'checksum: '
000EBC DA99           01659                 rcall   printf                  ;print message
000EBE 5004           01660                 movf    CHECKSUM,W,0            ;print checksum
000EC0 EC0A F000      01661                 call    K_PRINTHEX2                 
                      01662 
000EC4 D27A           01663                 bra     epower_off              ;power EPROM off and return to main
                      01664 
                      01665 ;******=========================================================================*
                      01666 ;* US *  Upload as S-Records Command
                      01667 ;******
                      01668 ; Transmit COUNTH:COUNTL bytes of EPROM buffer contents, starting at address
                      01669 ; ADDRESSH:ADDRESSL, in one of two formats:
                      01670 ; On Entry:
                      01671 ;   ADDRESSH:ADDRESSL = starting address
                      01672 ;   COUNTH:COUNTL = byte count. 0000 means do the whole buffer.
                      01673 ;   FULL_FLAG means limit count to the size of the EPROM
                      01674 ;*==============================================================================*
000EC6 9020           01675 cmd_uploads:    bcf     FLAGS1,INTEL_STATE,0    ;Set for Motorola
000EC8 D001           01676                 bra     upload_buf
                      01677 
                      01678 ;******=========================================================================*
                      01679 ;* UI *  Upload as Intel Hex Records Command
                      01680 ;******
                      01681 ; Transmit COUNTH:COUNTL bytes of EPROM buffer contents, starting at address
                      01682 ; ADDRESSH:ADDRESSL, in one of two formats:
                      01683 ; On Entry:
                      01684 ;   ADDRESSH:ADDRESSL = starting address
                      01685 ;   COUNTH:COUNTL = byte count. 0000 means do the whole buffer.
                      01686 ;   FULL_FLAG means limit count to the size of the EPROM
                      01687 ;*==============================================================================*
000ECA 8020           01688 cmd_uploadi:    bsf     FLAGS1,INTEL_STATE,0    ;Set for intel
                      01689 
                      01690 ;Fall into upload_buf
                      01691 
                      01692 ;***********--------------------------------------------------------------------*
                      01693 ;* UI & US * Common Upload Routine
                      01694 ;***********
                      01695 ; Transmit COUNTH:COUNTL bytes of EPROM buffer contents, starting at address
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 31
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01696 ; ADDRESSH:ADDRESSL, in a Hex format
                      01697 ; On entry:   
                      01698 ;   INTEL_STATE = 1 for Intel Hex, 0 for S-record
                      01699 ;   ADDRESSH:ADDRESSL = starting address
                      01700 ;   COUNTH:COUNTL = byte count. 0000 means do the whole buffer.
                      01701 ;   FULL_FLAG means limit count to the size of the EPROM
                      01702 ;*------------------------------------------------------------------------------*
                      01703 ;If no count provided, then limit COUNTH:COUNTL to the maximum size of the
                      01704 ;currently-selected EPROM
000ECC B820           01705 upload_buf:     btfsc   FLAGS1,FULL_FLAG,0          ;default?
000ECE DAC0           01706                 rcall   limit_count                 ;y: set it to the EPROM size
                      01707 
                      01708 ;Test for COUNTH:COUNTL exceeding the end of the buffer, and adjust to the end of the
                      01709 ;buffer if so. Note that COUNTH:COUNTL = 0 means do the whole buffer.
000ED0 5005           01710                 movf    ADDRESSL,W,0                ;compute max allowed byte count
000ED2 0800           01711                 sublw   low(SRAM_SIZE)              ;W := low(SRAM_SIZE) - ADDRESSL
000ED4 6E0D           01712                 movwf   R0,0
000ED6 0E20           01713                 movlw   high(SRAM_SIZE)
000ED8 5406           01714                 subfwb  ADDRESSH,W,0                ;W := high(SRAM_SIZE) - ADDRESSH - borrow
000EDA 6E0E           01715                 movwf   R1,0                        ;R1:R0 = max byte count
                      01716 
000EDC 9E19           01717                 bcf     COUNTH,0x07,0               ;guarantee no carries - certainly not >32K
000EDE 5019           01718                 movf    COUNTH,W,0                  ;whole buffer?
000EE0 1018           01719                 iorwf   COUNTL,W,0
000EE2 0E4F           01720                 movlw   0x4F                        ;much more than the whole buffer
000EE4 B4D8           01721                 btfsc   STATUS,Z,0
000EE6 6E19           01722                 movwf   COUNTH,0                    ;this will force a whole buffer upload
                      01723 
000EE8 5018           01724                 movf    COUNTL,W,0                  ;compare COUNTH:COUNTL to the max allowed count
000EEA 5C0D           01725                 subwf   R0,W,0                      ;W := R0 - COUNTL
000EEC 5019           01726                 movf    COUNTH,W,0
000EEE 580E           01727                 subwfb  R1,W,0                      ;W := R1 - COUNTH - borrow
                      01728 
000EF0 E204           01729                 bc      ul_countok  
                      01730 
000EF2 C00E F019      01731                 movff   R1,COUNTH                   ;adjust count to the end of the buffer
000EF6 C00D F018      01732                 movff   R0,COUNTL                               
000EFA                01733 ul_countok:
                      01734 
                      01735 ;Compute byte count for this record: the smaller of the remaining count and 16
000EFA 0E10           01736 upload_loop:        movlw   0x10                    ;16 bytes per line
000EFC 6E10           01737                     movwf   R3,0                    ;R3 is loop count
                      01738 
000EFE 5219           01739                     movf    COUNTH,F,0              ;more than 256 left?
000F00 E105           01740                     bnz     full_record
                      01741 
000F02 5018           01742                     movf    COUNTL,W,0              ;at least 16 left?
000F04 0BF0           01743                     andlw   0x0F0
000F06 B4D8           01744                     btfsc   STATUS,Z,0
000F08 C018 F010      01745                     movff   COUNTL,R3
000F0C                01746 full_record:
                      01747 
000F0C 6A04           01748                     clrf    CHECKSUM,0              ;start row checksum at 00
                      01749 
                      01750 ;Print CR LF, and either ':', or 'S1'
000F0E EE00 F0D6      01751                     lfsr    0,mot_start_rec-sstrings
000F12 B020           01752                     btfsc   FLAGS1,INTEL_STATE,0
000F14 EE00 F0C4      01753                     lfsr    0,int_start_rec-sstrings
000F18 DA75           01754                     rcall   cr_printf
                      01755 
                      01756 ;Send byte count for this record                
000F1A 0E00           01757                     movlw   0x00                    ;adjust byte count for S-records
000F1C A020           01758                     btfss   FLAGS1,INTEL_STATE,0
000F1E 0E03           01759                     movlw   0x03                    ;S-record: account for address, checksum bytes
000F20 2410           01760                     addwf   R3,W,0                  ;bytes per record
                      01761 
000F22 DA93           01762                     rcall   print_hex_csum          ;compute checksum along the way
                      01763 
                      01764 ;Compute & send high byte of this record's address
000F24 5006           01765                     movf    ADDRESSH,W,0
000F26 2422           01766                     addwf   ADR_OFFSET,W,0          ;add on address offset
000F28 DA90           01767                     rcall   print_hex_csum          ;send & accumulate checksum along the way
                      01768 
                      01769 ;Send low byte of this record's address
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 32
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000F2A 5005           01770                     movf    ADDRESSL,W,0            ;low byte of address
000F2C DA8E           01771                     rcall   print_hex_csum          ;accumulate checksum along the way
                      01772 
                      01773 ;If this is an Intel Hex record, send 00 record type
000F2E 0E00           01774                     movlw   0x00
000F30 B020           01775                     btfsc   FLAGS1,INTEL_STATE,0
000F32 DA8B           01776                     rcall   print_hex_csum
                      01777 
                      01778 ;Loop to send R3 bytes of data from ADDRESSH:ADDRESSL
000F34 EC17 F000      01779 up_byte_loop:           call    K_RDSRAM            ;get a byte from the buffer
000F38 DA88           01780                         rcall   print_hex_csum      ;send data byte, accumulate checksum
000F3A DA9E           01781                         rcall   next_a_count        ;bump ADDRESSH:ADDRESSL
                      01782                                                     ;..and decrement COUNTH:COUNTL
000F3C 2E10           01783                         decfsz  R3,F,0
000F3E D7FA           01784                         bra     up_byte_loop
                      01785 
                      01786 ;Compute this record's checksum: 
                      01787 ;  for Intel hex, checksum = 2's compliment of the sum
                      01788 ;  for Motorola s-records, checksum = 1's compliment of the sum
000F40 1E04           01789                     comf    CHECKSUM,F,0            ;compliment sum of bytes
000F42 B020           01790                     btfsc   FLAGS1,INTEL_STATE,0    ;add one if Intel hex
000F44 2A04           01791                     incf    CHECKSUM,F,0
                      01792 
000F46 5004           01793                     movf    CHECKSUM,W,0            ;get the final checksum
000F48 DA80           01794                     rcall   print_hex_csum          ;set CHECKSUM up for next record too
                      01795 
                      01796 ;See if we have more data to send
                      01797 
000F4A 5019           01798                     movf    COUNTH,W,0
000F4C 1018           01799                     iorwf   COUNTL,W,0
000F4E E1D5           01800                     bnz     upload_loop 
                      01801 
                      01802 ;All done sending data. Send appropriate eof record and quit
000F50 EE00 F0C8      01803                 lfsr    0,int_end_rec-sstrings
000F54 A020           01804                 btfss   FLAGS1,INTEL_STATE,0
000F56 EE00 F0DA      01805                 lfsr    0,mot_end_rec-sstrings
000F5A D254           01806                 bra     cr_printf                       ;print, return to main
                      01807 
                      01808 ;################################################################################
                      01809 ;#                          Diagnostic Commands                                 #
                      01810 ;################################################################################
                      01811 ;********=======================================================================*
                      01812 ;* AVPP * Adjust Vpp Voltage Command
                      01813 ;********
                      01814 ; Selects one of the possible Vpp voltages for adjustment form the Vpp test point
                      01815 ; On Entry:
                      01816 ;   DFLT_FLAG = 1 if the user did not provide an address offset value.
                      01817 ;   ADDRESSL:
                      01818 ;     0 = (off) sets Pulse Width to 0, which will produce 12V.
                      01819 ;     1 = 12.75V
                      01820 ;     2 = 13.15V
                      01821 ;     3 = 21V
                      01822 ;     4 = 25.1V (Note that 26V is just 1 diode drop above the 25V seting.)
                      01823 ;*==============================================================================*
000F5C 0E05           01824 cmd_avpp:   movlw   0x05                    ;max legal value is 4
000F5E DAC4           01825             rcall   tcmd_setup              ;test, become busy
                      01826 
000F60 5005           01827             movf    ADDRESSL,W,0            ;go set the value according to W
000F62 DBA1           01828             rcall   set_vpp
000F64 DB1E           01829             rcall   rep_vpp                 ;report the setting
                      01830 
000F66 5005           01831             movf    ADDRESSL,W,0            ;is switcher off?
000F68 E009           01832             bz      avpp_done               ;y: no further messages
                      01833 
000F6A EE03 F092      01834             lfsr    0,testvpp_msg-sstrings  ;"(Measure at TP3)"
000F6E DA40           01835             rcall   printf
                      01836 
                      01837 ;Determine if Vpp is on pin 18 or not. If so, remind the user that
                      01838 ;Vpp will be 0.8V higher on pin 18 (for 2708-type EPROMs)
000F70 0E1A           01839             movlw   ET_PGMVPP               ;look up Vpp pin for this EPROM
000F72 EC61 F00C      01840             call    etype_getval
000F76 0B07           01841             andlw   0x07                    ;just the Vpp bits
000F78 6E0D           01842             movwf   R0,0
000F7A 2E0D           01843             decfsz  R0,F,0                  ;0x01 means pin 18
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 33
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01844 
000F7C 0012           01845 avpp_done:  return                          ;no final message for pins 19-21
                      01846 
000F7E EE03 F0B4      01847             lfsr    0,vp18_msg-sstrings     ;note about pin 18
000F82 D240           01848             bra     cr_printf               ;print & return to main
                      01849 
                      01850 ;******=========================================================================*
                      01851 ;* RD * Read EPROM Data Pins Command
                      01852 ;******
                      01853 ; simply reads the eprom data pins and reports the results - 
                      01854 ; this is a test command, not meant for reading the EPROM in general.
                      01855 ; EPROM power, address, etc. are not set up prior to a read.
                      01856 ; On Exit:
                      01857 ;   The data buffer direction is set for reading
                      01858 ;   The data buffer outputs are disabled
                      01859 ;   Port D is tristated
                      01860 ;*==============================================================================*
000F84 6895           01861 cmd_rdata:      setf    TRISD                   ;tristate port D
000F86 9C8A           01862                 bcf     LATB,DBUFDIR,0          ;set buffer output direction 
000F88 9E8A           01863                 bcf     LATB,DBUFOEn,0          ;enable data buffer output      
000F8A EE03 F040      01864                 lfsr    0,dataread_msg-sstrings ;print banner
000F8E DA3A           01865                 rcall   cr_printf
                      01866 
                      01867 ;Read the EPROM data pins data and report result
000F90 5083           01868                 movf    PORTD,W,0               ;read the EPROM data pins
                      01869 
000F92 8E8A           01870                 bsf     LATB,DBUFOEn,0          ;disable data buffer outputs
000F94 EF0A F000      01871                 goto    K_PRINTHEX2             ;print it, return to main
                      01872 
                      01873 ;********=======================================================================*
                      01874 ;* TVBD * Test Vbb and Vdd pins
                      01875 ;********
                      01876 ;  TC <0-1> sets the Vbb and Vdd pins to off or on for this EPROM type
                      01877 ; On Entry:
                      01878 ;   ETYPE = current EPROM type
                      01879 ;   ADDRESSL = {0-1} from the user
                      01880 ;*==============================================================================*
000F98 0E02           01881 cmd_vbbvdd:     movlw   0x02                    ;User input limit+1
000F9A DAA6           01882                 rcall   tcmd_setup              ;get user input into W & R4, test for valid,
                      01883                                                 ;light busy light
                      01884 
000F9C DBBD           01885                 rcall   vbbvdd2pins             ;set the Vbb and Vdd pins according to W
                      01886                                                 ;returns R1=0 of no Vbb or Vdd pins
                      01887                                                 ;returns R1=1 if Vdd is 12V on pin 19
                      01888                                                 ;and Vbb is -5V on pin 21
                      01889 
000F9E EE04 F06A      01890                 lfsr    0,novbbvdd_msg-sstrings ;"\rVbb and Vdd do not exist"
000FA2 520E           01891                 movf    R1,F,0
000FA4 B4D8           01892                 btfsc   STATUS,Z,0
000FA6 D224           01893                 bra     printf                  ;print, return to main
                      01894 
000FA8 EE04 F084      01895                 lfsr    0,vbb_msg-sstrings      ;"\r-5V Vbb pin 21 and +12V Vdd"
                      01896     
000FAC 0E02           01897                 movlw   .19-.17                 ;Vdd is on pin 19
000FAE 6E0E           01898                 movwf   R1,0
000FB0 6A12           01899                 clrf    R5,0                    ;these pins are on/off
000FB2 D056           01900                 bra     print_pin               ;print pin number from R1, on/off from R4           
                      01901 
                      01902 ;********=======================================================================*
                      01903 ;* TVCC * Test Vcc pin
                      01904 ;********
                      01905 ;  TC <0-2> sets the Vcc pin to {0V,+5V,Programming Vcc for this EPROM type}
                      01906 ; On Entry:
                      01907 ;   ETYPE = current EPROM type
                      01908 ;   ADDRESSL = {0-2} from the user
                      01909 ;*==============================================================================*
000FB4 0E03           01910 cmd_tvcc:   movlw   0x03                ;User input limit+1
000FB6 DA98           01911             rcall   tcmd_setup          ;get user input into W & R4, test for valid,
                      01912                                         ;light busy light
                      01913 
000FB8 DB9A           01914             rcall   vcc2pin             ;set the Vcc pin according to W
                      01915                                         ;returns R1=pin number-17 or 0 for none
000FBA EE04 F030      01916             lfsr    0,tvcc_msg-sstrings ;"Vcc"
000FBE 0E07           01917             movlw   .24-.17             ;set up for print_pin
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 34
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000FC0 6E0E           01918             movwf   R1,0                ;Vcc is always pin 24   
000FC2 6A12           01919             clrf    R5,0                ;this pin is on/off
000FC4 D04D           01920             bra     print_pin           ;print the pin number and state from R1 & R4
                      01921 
                      01922 ;********=======================================================================*
                      01923 ;* TPGM * Test PGM pin
                      01924 ;********
                      01925 ;  TC <0/1> sets the PGM pin low/high
                      01926 ; On Entry:
                      01927 ;   ETYPE = current EPROM type
                      01928 ;   ADDRESSL = {0-1} from the user
                      01929 ;*==============================================================================*
000FC6 0E02           01930 cmd_tpgm:   movlw   0x02                    ;User input limit+1
000FC8 DA8F           01931             rcall   tcmd_setup              ;get user input int W & R4, test for valid,
                      01932                                             ;light busy light
                      01933 
000FCA ECF4 F00B      01934             call    pgm2pin                 ;set the PGM pin according to W
                      01935                                             ;returns R1=pin number-17 or 0 for none
                      01936 
000FCE EE08 F05F      01937             lfsr    0,pgm_msg-sstrings+1    ;"PGM" (skipping slash)
000FD2 6812           01938             setf    R5,0                    ;this pin is active/inactive
000FD4 D045           01939             bra     print_pin               ;print pin number from R1, on/off from R4           
                      01940 
                      01941 ;*******========================================================================*
                      01942 ;* TCS * Test CS (or (-CS) pin
                      01943 ;*******
                      01944 ; TCS <0-1> sets the -CS pin to {inactive,active}
                      01945 ; Note that active may be high or low, depending on the EPROM
                      01946 ; Note that CS may also be the PGM or Vpp pin
                      01947 ; On Entry:
                      01948 ;   ETYPE = current EPROM type
                      01949 ;   ADDRESSL = {0-2} from the user
                      01950 ;*==============================================================================*
000FD6 0E02           01951 cmd_tcs:    movlw   0x02                ;User input limit+1
000FD8 DA87           01952             rcall   tcmd_setup          ;get user input into W & R4, test for valid,
                      01953                                         ;light busy light
                      01954 
000FDA EC40 F00C      01955             call    cs2pin              ;set the -CS pin according to R3
                      01956                                         ;returns R1=pin number-17 or 0 for none
                      01957 
000FDE EE08 F052      01958             lfsr    0,cs_msg-sstrings   ;"CS"   
000FE2 6812           01959             setf    R5,0                ;this pin is active/inactive
000FE4 D03D           01960             bra     print_pin           ;print pin number and state from R1 & R4
                      01961 
                      01962 ;*******========================================================================*
                      01963 ;* THI * Test stuck-high pin
                      01964 ;*******
                      01965 ; THI <0-1> sets the stuck-high pin to {low/high}
                      01966 ; On Entry:
                      01967 ;   ETYPE = current EPROM type
                      01968 ;   ADDRESSL = {0-1} from the user
                      01969 ;*==============================================================================*
000FE6 0E02           01970 cmd_thi:    movlw   0x02                    ;User input limit+1
000FE8 DA7F           01971             rcall   tcmd_setup              ;get user input int W & R4, test for valid,
                      01972                                             ;light busy light
                      01973 
000FEA EC37 F00C      01974             call    hi2pin                  ;set correct pin high or low as requested
                      01975                 
000FEE EE08 F038      01976             lfsr    0,stuckhi_msg-sstrings  ;"Stuck-high"   
000FF2 6A12           01977             clrf    R5,0                    ;this pin is off/on
000FF4 D035           01978             bra     print_pin               ;print pin number and state from R1 & R4
                      01979 
                      01980 ;********=======================================================================*
                      01981 ;* TVPP * Test Vpp pin
                      01982 ;********
                      01983 ;  TV <0-3> sets the Vpp pin:
                      01984 ;       0 = 0V (off)
                      01985 ;       1 = read mode level
                      01986 ;       2 = programming mode inactive level
                      01987 ;       3 = programming active level
                      01988 ;  Note that Vpp may be from the onboard supply or the external negative supply.
                      01989 ; On Entry:
                      01990 ;   ETYPE = current EPROM type
                      01991 ;   ADDRESSL = {0-2} from the user
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 35
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01992 ;*==============================================================================*
000FF6 0E04           01993 cmd_tvpp:   movlw   0x04                        ;User input limit+1
000FF8 DA77           01994             rcall   tcmd_setup                  ;get user input int W & R4, test for valid,
                      01995                                                 ;light busy light
                      01996 
000FFA DBA0           01997             rcall   vpp2pin                     ;Set Vpp pin according to W
000FFC C00E F012      01998             movff   R1,R5                       ;returns R1=pin number-17 or 0 for none
                      01999 
001000 EE04 F024      02000             lfsr    0,tvpp_msg-sstrings         ;"Vpp pin "
001004 D9FF           02001             rcall   cr_printf
                      02002 
001006 EE04 F05A      02003             lfsr    0,nonexist_msg-sstrings     ;" does not exist"
00100A 5212           02004             movf    R5,F,0                      ;test for 0 = no Vpp pin
00100C E014           02005             bz      tvpp_print
                      02006 
00100E DB47           02007             rcall   eset_vpp                    ;turn on the switching power supply
                      02008                                                 ;for this EPROM's Vpp voltage
                      02009 
001010 0E11           02010             movlw   .17                         ;compute pin number
001012 2412           02011             addwf   R5,W,0
001014 6E0D           02012             movwf   R0,0                        ;set up for K_PRINTDEC
001016 6A0E           02013             clrf    R1,0
001018 EC0B F000      02014             call    K_PRINTDEC
                      02015 
00101C EE03 F0E4      02016             lfsr    0,pwroff_msg-sstrings       ;" powered off"
001020 0611           02017             decf    R4,F,0
001022 E609           02018             bn      tvpp_print
                      02019 
001024 EE03 F0F2      02020             lfsr    0,rmode_msg-sstrings        ;" read mode"
001028 E006           02021             bz      tvpp_print
                      02022 
00102A EE04 F000      02023             lfsr    0,pmode_msg-sstrings        ; programming mode "
00102E D9E0           02024             rcall   printf
                      02025 
001030 EE04 F014      02026             lfsr    0,pinactive_msg-sstrings    ;"inactive state"
001034 4E11           02027             dcfsnz  R4,F,0
                      02028 
001036 D1DC           02029 tvpp_print: bra     printf                      ;print, return to main
                      02030 
                      02031 ;Figure out and print the programming voltage
001038 0E1C           02032             movlw   ET_VPPSETUP
00103A EC61 F00C      02033             call    etype_getval                ;get the programming voltage in W and R0
00103E C012 F00F      02034             movff   R5,R2                       ;pin number minus 17 (since pin 18
                      02035                                                 ;..has higher voltages)
                      02036 
001042 EF89 F00C      02037             goto    pvpp_voltage                ;print the voltage & return to main
                      02038 
                      02039 ;*******========================================================================*
                      02040 ;* TOE * Test -OE pin
                      02041 ;*******
                      02042 ;  TC <0-2> sets the -OE pin to (inactive,active,programming level)
                      02043 ; On Entry:
                      02044 ;   ETYPE = current EPROM type
                      02045 ;   ADDRESSL = {0-2} from the user
                      02046 ;*==============================================================================*
001046 0E03           02047 cmd_toe:    movlw   0x03                ;User input limit+1
001048 DA4F           02048             rcall   tcmd_setup          ;get user input int W & R4, test for valid,
                      02049                                         ;light busy light
                      02050 
00104A DBB1           02051             rcall   oen2pin             ;Set -OE pin according to W
                      02052                                         ;returns R1=pin number-17 or 0 for none
                      02053 
00104C EE08 F04A      02054             lfsr    0,oe_msg-sstrings   ;"-OE"  
001050 6812           02055             setf    R5,0                ;this pin is active/inactive
001052 D006           02056             bra     print_pin           ;print the pin number and state from R1 & R4
                      02057 
                      02058 ;*******========================================================================*
                      02059 ;* TAS * Test -AS pin
                      02060 ;*******
                      02061 ;  TC <0-1> sets the -AS pin to (inactive,active)
                      02062 ; On Entry:
                      02063 ;   ETYPE = current EPROM type
                      02064 ;   ADDRESSL = {0-1} from the user
                      02065 ;*==============================================================================*
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 36
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001054 0E02           02066 cmd_tas:    movlw   0x02                ;User input limit+1
001056 DA48           02067             rcall   tcmd_setup          ;get user input int W & R4, test for valid,
                      02068                                         ;light busy light
                      02069 
001058 DBCE           02070             rcall   asn2pin             ;Set -AS pin according to W
                      02071                                         ;returns R1=pin number-17 or 0 for none
00105A EE08 F044      02072             lfsr    0,as_msg-sstrings   ;"-AS"  
00105E 6812           02073             setf    R5,0                ;this pin is active/inactive
                      02074 
                      02075 ;Fall into print_pin to print the pin number and state according to R1 & R4
                      02076 
                      02077 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                      02078 ; Common message routine for test routines
                      02079 ;  R1=0:  Prints "<xxx> pin does not exist"
                      02080 ;  R1<>0: Prints "<xxx> pin nn <off/on/at programming level>
                      02081 ; On Entry:
                      02082 ;   FSR0 points to initial message identifying the pin
                      02083 ;   R1 = pin number nn - 17, 0 means does not exist
                      02084 ;   R4 = 0 for off, 1 for on, 2 for at programming level
                      02085 ;   R5 = 0 if this is an on/off pin, not 0 it is an active/inactive pin
                      02086 ; Trashes W,R0,R1,R2,PRODH,PRODL,FSR0
                      02087 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
001060 D9D1           02088 print_pin:      rcall   cr_printf
                      02089 
001062 EE04 F028      02090                 lfsr    0,pin_msg-sstrings          ;" pin "
001066 D9C4           02091                 rcall   printf
                      02092 
001068 EE04 F05A      02093                 lfsr    0,nonexist_msg-sstrings     ;" does not exist"
00106C 520E           02094                 movf    R1,F,0                      ;test for 0
00106E B4D8           02095                 btfsc   STATUS,Z,0
001070 D1BF           02096                 bra     printf                      ;done if no such pin - print, return to main
                      02097 
001072 0E11           02098                 movlw   .17                         ;compute pin number
001074 240E           02099                 addwf   R1,W,0
001076 6E0D           02100                 movwf   R0,0                        ;set up for K_PRINTDEC
001078 6A0E           02101                 clrf    R1,0
00107A EC0B F000      02102                 call    K_PRINTDEC
                      02103 
00107E EE04 F042      02104                 lfsr    0,apl_msg-sstrings          ;" at programming level"
001082 B211           02105                 btfsc   R4,0x01,0                   ;R3 = 2?
001084 D1B5           02106                 bra     printf                      ;y: print this message, return to main
                      02107 
001086 5212           02108                 movf    R5,F,0                      ;is this an on/off pin?
001088 E009           02109                 bz      print_onoff                 ;y: print on or off     
                      02110 
00108A 0E20           02111                 movlw   ' '
00108C EC06 F000      02112                 call    K_CONOUT
                      02113 
001090 EE04 F016      02114                 lfsr    0,pactive_msg-sstrings      ;"active state"
001094 A011           02115                 btfss   R4,0x00,0
001096 EE04 F014      02116                 lfsr    0,pinactive_msg-sstrings    ;"inactive state"
00109A D1AA           02117                 bra     printf                      ;print and then done with command, return to main
                      02118 
00109C EE04 F036      02119 print_onoff:    lfsr    0,on_msg-sstrings           ;' on'
0010A0 A011           02120                 btfss   R4,0x00,0
0010A2 EE04 F03C      02121                 lfsr    0,off_msg-sstrings          ;' off'
0010A6 D1A4           02122                 bra     printf                      ;done with command, return to main
                      02123 
                      02124 ;******=========================================================================*
                      02125 ;* WD * Write EPROM Data Pins Command
                      02126 ;******
                      02127 ; Writes first parameter (in ADDRESSL) to the EPROM data pins (For
                      02128 ; testing purposes.)
                      02129 ; On Entry:
                      02130 ;   ADDRESSL = (low byte of) user input. (The high byte is just ignored.)
                      02131 ; On Exit:
                      02132 ;   Port D is set up for output
                      02133 ;*==============================================================================*
0010A8 0EFF           02134 cmd_wdata:      movlw   0xFF                ;all values legal
0010AA DA1E           02135                 rcall   tcmd_setup          ;get user input, turn Busy light on
                      02136 
0010AC 6E83           02137                 movwf   PORTD,0             ;write data to PIC pins
0010AE 8C8A           02138                 bsf     LATB,DBUFDIR,0      ;set external data buffer direction 
0010B0 6A95           02139                 clrf    TRISD,0             ;enable PIC output
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 37
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0010B2 9E8A           02140                 bcf     LATB,DBUFOEn,0      ;enable external data buffer output     
                      02141 
0010B4 0012           02142                 return                      ;..to main
                      02143 
                      02144 ;******=========================================================================*
                      02145 ;* WA * Write EPROM Address Pins Command
                      02146 ;******
                      02147 ; Writes first parameter (in ADDRESSH:ADDRESS) to the EPROM address pins,
                      02148 ; based on the selected EPROM type. (For testing purposes.)
                      02149 ; On Entry:
                      02150 ;   ADDRESSH:ADDRESSL = user input address
                      02151 ;*==============================================================================*
0010B6 D3EA           02152 cmd_waddress:       bra     address2pins        ;..and return to main
                      02153 
                      02154 ;*********======================================================================*
                      02155 ;* TPROG * Test Programming Command
                      02156 ;*********
                      02157 ; Loops writing the buffer to the EPROM until the user says to stop. This is for
                      02158 ; testing purposes only.
                      02159 ; On Entry:
                      02160 ;   ADDRESSH:ADDRESSL = 0
                      02161 ;*==============================================================================*
0010B8 D946           02162 cmd_tprog:      rcall   epower_prog             ;power everything up for programming
                      02163 
0010BA EE04 F0A2      02164                 lfsr    0,pulsing_msg-sstrings  ;"Pulsing  "
0010BE D9A2           02165                 rcall   cr_printf
                      02166 
0010C0 DA3C           02167                 rcall   wait_txempty            ;print message before blocking ints
                      02168 
0010C2 8E20           02169                 bsf     FLAGS1,TEST             ;tell ewrite_byte that we are testing
                      02170 
0010C4 9EF2           02171 tp_loop:            bcf     INTCON,GIE,0        ;no interrupts during pulse
0010C6 C028 F013      02172                     movff   SMART1,R6           ;get 1st pass programming mode
0010CA D83D           02173                     rcall   ewrite_byte         ;Write a byte
0010CC 5029           02174                     movf    SMART2,W,0          ;get & test 2nd pass programming mode
0010CE 6E13           02175                     movwf   R6,0
0010D0 A4D8           02176                     btfss   STATUS,Z,0          ;there may not be a 2nd pass.
0010D2 D839           02177                     rcall   ewrite_byte         ;Write a byte
0010D4 8EF2           02178                     bsf     INTCON,GIE,0        ;reenable interrupts
                      02179 
0010D6 D9D0           02180                     rcall   next_a_count        ;bump address
                      02181 
0010D8 D81F           02182                     rcall   pacify              ;print pacifier if it's time
                      02183 
0010DA EC16 F000      02184                     call    K_CHKABORT          ;user abort?
0010DE E0F2           02185                     bz      tp_loop             ;Z if no user input
                      02186 
0010E0 D16C           02187                 bra     epower_off              ;everything off & return
                      02188 
                      02189 ;*********======================================================================*
                      02190 ;* TREAD * Test Reading Command
                      02191 ;*********
                      02192 ; Loops reading the EPROM into the bit bucket until the user says to stop. This
                      02193 ; is for testing purposes only.
                      02194 ; On Entry:
                      02195 ;   ADDRESSH:ADDRESSL = 0
                      02196 ;*==============================================================================*
0010E2 D95B           02197 cmd_tread:      rcall   epower_read             ;power up the EPROM
                      02198 
0010E4 EE04 F0AE      02199                 lfsr    0,reading_msg-sstrings  ;"Reading  "
0010E8 D98D           02200                 rcall   cr_printf
                      02201 
                      02202 ;Read EPROM until user aborts
0010EA D916           02203 tread_loop:         rcall   eread_byte          ;read EPROM at ADDRESSH:ADDRESSL,
                      02204                                                 ;..result in W & R2
                      02205 
0010EC D815           02206                     rcall   pacify              ;print pacifier if it's time
                      02207 
0010EE D9C4           02208                     rcall   next_a_count        ;bump address pointer
                      02209 
0010F0 EC16 F000      02210                     call    K_CHKABORT          ;user abort?
0010F4 E0FA           02211                     bz      tread_loop          ;Z if no user input
                      02212 
0010F6 D161           02213                 bra     epower_off              ;power EPROM off & return
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 38
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02214 
                      02215 ;################################################################################
                      02216 ;#                              Subroutines                                     #
                      02217 ;################################################################################
                      02218 
                      02219 ;*==============================================================================*
                      02220 ; Subroutine to test for legal 0/1 input
                      02221 ; On Entry:
                      02222 ;   ADDRESSH:ADDRESSL = user input
                      02223 ; exit to pop_cmderr if input
                      02224 ;*==============================================================================*
0010F8 6606           02225 test_01:        tstfsz  ADDRESSH,0              ;no high byte allowed
0010FA D004           02226                 bra     error_01
                      02227 
0010FC 5005           02228                 movf    ADDRESSL,W,0            ;low byte of user input
0010FE 0BFE           02229                 andlw   0xFE                    ;anything but 0 or 1?
001100 E101           02230                 bnz     error_01
001102 0012           02231                 return
                      02232 
001104 D1EE           02233 error_01:       bra     pop_cmderr
                      02234 
                      02235 ;*==============================================================================*
                      02236 ; Subroutine to write one pass through the  EPROM
                      02237 ; Check for control-C after each byte, abort if control-C found
                      02238 ; Print a pacifier as needed
                      02239 ; On Entry:
                      02240 ;   R6 = smart programming mode
                      02241 ;   ADDRESSH_SAVE:ADDRESSL_SAVE=EPROM address
                      02242 ;   (ADDRESSH_SAVE+BUF_OFFSET):ADDRESSL_SAVE=buffer address
                      02243 ;   COUNTH_SAVE,COUNTL_SAVE = number of bytes to program
                      02244 ;   ETYPE has the EPROM type
                      02245 ;   DINV_STATE = FF if the EPROM data is to be inverted
                      02246 ;   EPROM is powered up and ready for writing. If this EPROM requires a
                      02247 ;     pulsed Vpp then Vpp is at the programming-low (inactive) level
                      02248 ;   PGM is at its inactive state
                      02249 ;   EPROM is chip-selected and write-enabled.
                      02250 ;   PROGPULSE, PMODE1 & PMODE2 are valid for the current EPROM
                      02251 ;
                      02252 ; On Exit:
                      02253 ;   EPROM is still powered up for programming
                      02254 ;   trashes W,R1,R2,R3,R4,R5,FSR0, ADDRESSH:ADDRESSL, COUNTH:COUNTL
                      02255 ;   Interrupts are enabled
                      02256 ;
                      02257 ; Numbers in parenthesis are time in uS
                      02258 ; Trashes W,R0,R1,R2,R3,R4,R5
                      02259 ;*==============================================================================*
001106 D9E4           02260 ewrite_range:   rcall   restore_params      ;recover original starting address & byte count
                      02261 
                      02262 ;Loop once through the entire EPROM range. Check for user abort before each byte.
                      02263 ;The pacifier is controlled by a hardware timer - check if it's time for the next
                      02264 ;pacifier step.
001108 D990           02265 ewrite_loop:        rcall   flush_abort     ;(.5 + 5.5)abort on ^C or ESC
00110A D806           02266                     rcall   pacify          ;(1+.5)print pacifier if it's time
                      02267 
                      02268 ;Write the EPROM byte from ADDRESSH:ADDRESSL
00110C 9EF2           02269                     bcf     INTCON,GIE,0    ;(.25)global interrupt masked while we write
00110E D81B           02270                     rcall   ewrite_byte     ;write a byte to the EPROM (int's are masked)
001110 8EF2           02271                     bsf     INTCON,GIE,0    ;(.25)let Rx and Tx interrupts in
                      02272 
                      02273 ;Move on to next location and test for done
001112 D9B2           02274                     rcall   next_a_count    ;(.5+2.5)bump address, dec and test count
001114 E1F9           02275                     bnz     ewrite_loop     ;(0.50)
                      02276 
001116 0012           02277                 return
                      02278 
                      02279 ;*==============================================================================*
                      02280 ; Subroutine to check the pacifier timer, and print the next pacifier propellor
                      02281 ; step if it's time to do so.
                      02282 ; On Entry:
                      02283 ;  Timer 0 (TMR0H) has been set up such that its high byte increments at 61 Hz.
                      02284 ;  Bit 5 toggles at about 1 Hz
                      02285 ;
                      02286 ; On Exit:
                      02287 ;   Interrupts are masked
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 39
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02288 ; Trashes W,R0
                      02289 ; 1 uS, normally (when the pacifier is not updated)
                      02290 ;*==============================================================================*
001118 50D6           02291 pacify:         movf    TMR0L,W,0       ;(.25)must read TMR0L to read TMR0H
00111A AAD7           02292                 btfss   TMR0H,0x05,0    ;(.25)time for a pacifier?
00111C 0012           02293                 return                  ;(.5)
                      02294 
                      02295 ;Restart the pacifier timer
00111E 6AD7           02296                 clrf    TMR0H           ;Restart timer. Must clear high first
001120 6AD6           02297                 clrf    TMR0L
                      02298 
                      02299 ;Print the next pacifier propeller step
001122 0E08           02300                 movlw   BS              ;back up on the screen
001124 EC06 F000      02301                 call    K_CONOUT
                      02302 
001128 2A2A           02303                 incf    PACINDEX,F,0    ;bump pointer to next pacifier character
00112A 0E03           02304                 movlw   0x03            ;modula 4
00112C 162A           02305                 andwf   PACINDEX,F,0
                      02306 
00112E C02A F00D      02307                 movff   PACINDEX,R0
                      02308 
001132 0E2F           02309                 movlw   '/'             ;4th pacifier chr
001134 4E0D           02310                 dcfsnz  R0,F,0
001136 0E2D           02311                 movlw   '-'             ;1st pacifier chr
001138 4E0D           02312                 dcfsnz  R0,F,0
00113A 0E5C           02313                 movlw   0x5C            ;2nd pacifier chr is a slash '\'
00113C 4E0D           02314                 dcfsnz  R0,F,0
00113E 0E7C           02315                 movlw   '|'             ;3rd pacifier chr
                      02316 
001140 EC06 F000      02317                 call    K_CONOUT        ;print the pacifier
001144 D1FA           02318                 bra     wait_txempty    ;finish printing pacifier, and return
                      02319 
                      02320 ;*==============================================================================*
                      02321 ; Subroutine to write one byte to the EPROM
                      02322 ; On Entry:
                      02323 ;   ETYPE has the EPROM type
                      02324 ;   R6=programming mode:
                      02325 ;      00 means just program once.
                      02326 ;      80 means program until match
                      02327 ;      <6:4> Phase 1 type
                      02328 ;        0: program until match, then program n times
                      02329 ;        1: program until match, then 1 pulse that is n*ET_PROGPULSE long
                      02330 ;        2: program until match (P), then nP times
                      02331 ;        3: program until match, then 1 pulse that is n*P*ET_PROGPULSE long
                      02332 ;        4: Program n times
                      02333 ;        5: Program once, pulse time = n*ET_PROGPULSE
                      02334 ;      <3> set means program data=FF (EEPROM erase)
                      02335 ;      <2:0> Phase n
                      02336 ;   ADDRESSH:ADDRESSL = EPROM address
                      02337 ;   (ADDRESSH+BUF_OFFSET):ADDRESSL = data buffer address
                      02338 ;   SRAM(ADDRESSH:ADDRESSL) = data to be written
                      02339 ;   DINV_STATE = FF if the EPROM data is to be inverted
                      02340 ;   EPROM is powered up and ready for writing. If this EPROM requires a
                      02341 ;     pulsed Vpp then Vpp is at the programming-low (inactive) level
                      02342 ;   PGM signal is at its inactive state (high or low depending on its polarity)
                      02343 ;   EPROM is chip-selected and write-enabled
                      02344 ;   RAM variables are all valid for the current EPROM
                      02345 ;   TEST is set if this subroutine was called from the TPROG command. In this
                      02346 ;     case (and if the selected EPROM type does Smart programming) then we
                      02347 ;     behave as though the byte verified on the last possible try.
                      02348 ; Trashes W,R0,R1,R2,R3,R4,R5
                      02349 ;*==============================================================================*
                      02350 
                      02351 ;Put ADDRESSH:ADDRESSL onto the EPROM's address pins. This must be done before writing
                      02352 ;the data to the EPROM's data pins, because writing to the external low address latch
                      02353 ;requires PIC Port D, which is also the data output port.
001146 DBA2           02354 ewrite_byte:    rcall   address2pins        ;(about 53.5)
                      02355 
                      02356 ;Disable, and then enable the address strobe pin, to strobe the new address into the EPROM.
                      02357 ;Note that pin 20 (which has a 0.047 uF cap) may be the -AS pin, and therefore will be slow.
                      02358 ;Get the buffer data (inverting as required) in the middle, to give the -AS pin time to
                      02359 ;transition.
001148 0E00           02360                 movlw   0x00                ;(.25)high-going edge of -AS
00114A DB55           02361                 rcall   asn2pin             ;(11.5+.5)(just returns if there is no -AS pin)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 40
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02362 
00114C 0E21           02363                 movlw   DINV_STATE          ;(.25)is the data supposed to get inverted?
00114E EC19 F000      02364                 call    K_RDEEPROM          ;(1.5+.5)
001152 6E11           02365                 movwf   R4,0                ;(.25) temp save inverter
                      02366 
001154 5017           02367                 movf    BUF_OFFSET,W,0      ;(.25)buffer address offset
001156 2606           02368                 addwf   ADDRESSH,F,0        ;(.25)compute buffer address
                      02369 
001158 EC17 F000      02370                 call    K_RDSRAM            ;(about 16) read SRAM at ADDRESSH:ADDRESSL, trash R0
00115C 1A11           02371                 xorwf   R4,F,0              ;(.5) invert buffer data if it needs it, save in R4
                      02372 
00115E B613           02373                 btfsc   R6,0x03,0           ;(.5) EEPROM erase?
001160 6811           02374                 setf    R4,0                ;y: write FF instead of buffer data
                      02375 
001162 5017           02376                 movf    BUF_OFFSET,W,0      ;(.25)buffer address offset
001164 5E06           02377                 subwf   ADDRESSH,F,0        ;(.25)restore EPROM address
                      02378 
001166 0E01           02379                 movlw   0x01                ;(.25)low-going (active) edge -AS, leave pin active
001168 DB46           02380                 rcall   asn2pin             ;(11.5+.5)(just returns if there is no -AS pin)
                      02381 
                      02382 ;Actually write the data in R4 to the EPROM data pins
00116A 8C8A           02383                 bsf     LATB,DBUFDIR,0      ;(.25)point the data buffer toward the EPROM
00116C C011 FF8C      02384                 movff   R4,LATD             ;(.5)put the data on the PIC pins
001170 6A95           02385                 clrf    TRISD,0             ;(.25)enable the PIC outputs
001172 9E8A           02386                 bcf     LATB,DBUFOEn,0      ;(.25)enable the data buffer outputs
                      02387 
                      02388 ;-------------------------------------------------------------------------
                      02389 ; Program the byte using ((PPULSEH:PPULSEL x 10) + 30) uS pulse(s)
                      02390 ; Note that PULSEH:PPULSEL has already been reduced by 3 to account
                      02391 ; for the 30 uS overhead of the pulse_byte loop.
                      02392 ; On Entry:
                      02393 ;   R6=programming mode:
                      02394 ;      00 means just program once.
                      02395 ;      80 means program until match
                      02396 ;      <6:4> Phase 1 type
                      02397 ;        0: program until match, then program n times
                      02398 ;        1: program until match, then 1 pulse that is n*ET_PROGPULSE long
                      02399 ;        2: program until match (P), then nP times
                      02400 ;        3: program until match, then 1 pulse that is n*P*ET_PROGPULSE long
                      02401 ;        4: Program n times
                      02402 ;        5: Program once, pulse time = n*ET_PROGPULSE
                      02403 ;      <3> set means program data=FF (EEPROM erase)
                      02404 ;      <2:0> Phase n
                      02405 ;-------------------------------------------------------------------------
001174 5013           02406                 movf    R6,W,0              ;(.25)Smart programming of some sort?
001176 B4D8           02407                 btfsc   STATUS,Z,0          ;(.25)any smart mode enabled?
001178 D059           02408                 bra     pulse_byte          ;(.5)n: write it once and return
                      02409 
00117A 0B07           02410                 andlw   0x07                ;get n
00117C 6E12           02411                 movwf   R5,0
                      02412 
00117E BC13           02413                 btfsc   R6,0x06,0           ;write until match first?
001180 D036           02414                 bra     smart_n             ;n: no write-until-match phase
                      02415 
                      02416 ;----------------------------------------------------------------
                      02417 ; Single-byte Smart programming loop
                      02418 ; Write the EPROM byte until the EPROM data matches the written
                      02419 ; data. Abort the entire write operation if the data does not
                      02420 ; match after PROGREPS tries.
                      02421 ;----------------------------------------------------------------
001182 C027 F011      02422                 movff   PROGREPS,R4             ;R4 counts programming tries
                      02423 
                      02424 ;Write the byte once
001186 D852           02425 retry_pulse:        rcall   pulse_byte          ;(18.5 uS min before pulse) write the byte once
                      02426 
                      02427 ;Set up to read the EPROM back
001188 6895           02428                     setf    TRISD,0             ;(.25)tristate the PIC's data buffers
00118A 9C8A           02429                     bcf     LATB,DBUFDIR,0      ;(.25)point the external data buffer toward PIC
                      02430 
                      02431 ;If the CS pin is also the Vpp pin, then set the CS pin active (turning Vpp off)
                      02432 ;so that the EPROM may be read
00118C 0E01           02433                     movlw   0x01
00118E B21F           02434                     btfsc   SHARED,CSVPP,0
001190 DB77           02435                     rcall   cs2pin              ;set CS active, potentially turning Vpp off
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 41
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02436 
                      02437 ;Enable the EPROM output
001192 0E01           02438                     movlw   0x01                ;active state for -OE so we can read
001194 DB0C           02439                     rcall   oen2pin             ;(1.5 uS from pin-write through return)
                      02440 
001196 0E02           02441                     movlw   .2                  ;(.25)stall because -OE signal is slow
001198 EC1F F000      02442                     call    K_STALL1U           ;(3)
                      02443 
00119C 0E02           02444                     movlw   0x02                ;(.25)prepare to put the EPROM back in program mode
                      02445 
                      02446 ;Sample the EPROM data 5 uS after the -OE signal was asserted.
00119E CF83 F00F      02447                     movff   PORTD,R2            ;(.5)read the EPROM data, temp save in R2
                      02448 
                      02449 ;Turn off the EPROM's -OE signal. If -OE is also Vpp, then it will be put back to its programming-inacti
                            ve
                      02450 ;level. Otherwise, it will be set high (the -OE inactive level).
0011A2 DB05           02451                     rcall   oen2pin             ;(1.5 from off)disable EPROM's output buffer. Trashes W,
                            R0,R1,R3
                      02452 
                      02453 ;If the CS pin is also the Vpp pin, then turn Vpp back on. If Vpp is the pulsed signal,
                      02454 ;then set it to its programming-inactive state. Otherwise, turn it on.
0011A4 0E02           02455                     movlw   0x02                ;(.25)Vpp programming-inactive state (this order for del
                            ay)
0011A6 B221           02456                     btfsc   FLAGS2,PMODE1,0     ;(.5)0 means Vpp pulses (and should now be inactive)
0011A8 0E03           02457                     movlw   0x03                ;Vpp programming-active state
                      02458 
0011AA B21F           02459                     btfsc   SHARED,CSVPP,0      ;(.5)
0011AC DAC7           02460                     rcall   vpp2pin             ;(.5+.5 from pin write)turn Vpp back on
                      02461 
0011AE 0E01           02462                     movlw   .1                  ;(.25)stall because -OE signal and Vpp are slow
0011B0 EC1F F000      02463                     call    K_STALL1U           ;(2)
                      02464 
                      02465 ;Verify written data. Here, we only look for bits that should be 0, but are still 1, since an
                      02466 ;erased EPROM is all FF's. (Other errors will be caught during verify.)
0011B4 500F           02467                     movf    R2,W,0              ;(.25)W = EPROM data
0011B6 6E10           02468                     movwf   R3,0                ;(.25)R3 = EPROM data, in place for rep_mismatch
0011B8 CF8C F00F      02469                     movff   LATD,R2             ;(.5)R2 = written data (buffer data), in place for rep_m
                            ismatch
0011BC 180F           02470                     xorwf   R2,W,0              ;(.25)compare, non-zero bits are mismatches
0011BE 1410           02471                     andwf   R3,W,0              ;(.25)only care about mismatched bits that are still 1 i
                            n EPROM
                      02472                                                 ;Z set if all bits that should be 0 are 0
                      02473 ;Turn data buffer 6 uS min after -OE signal was removed
0011C0 8C8A           02474                     bsf     LATB,DBUFDIR,0      ;(.25)point the external data buffer toward the EPROM
0011C2 6A95           02475                     clrf    TRISD,0             ;(.25)un-tristate the PIC's data buffers
                      02476 
                      02477 ;Move on to overprogramming if the data matches. Abort if too many tries. Otherweise, try again.
0011C4 AE20           02478                     btfss   FLAGS1,TEST,0       ;(.25)If this is TPROG testing, then always fail the mat
                            ch
0011C6 E009           02479                     bz      overprog            ;(.25)done with Smart loop if match
                      02480 
0011C8 0611           02481                     decf    R4,F,0              ;(.25)enough retries yet?
0011CA E1DD           02482                     bnz     retry_pulse         ;(.5)n: try again
                      02483 
0011CC BE20           02484                 btfsc   FLAGS1,TEST,0           ;is this TPROG testing?
0011CE D005           02485                 bra     overprog                ;If so, always pass on the last try
                      02486 
                      02487 ;----------------------------------------------------
                      02488 ; Smart programming failure. Report failure and quit. 
                      02489 ;----------------------------------------------------
0011D0 8EF2           02490                 bsf     INTCON,GIE,0            ;reenable interrupts for rep_mismatch
0011D2 D99F           02491                 rcall   rep_mismatch            ;report failing address
0011D4 EE06 F0D8      02492                 lfsr    0,sfail_msg-sstrings    ;"Smart programming failed"
0011D8 D074           02493                 bra     prog_abort              ;power off, return to main
                      02494 
                      02495 ;--------------------------------------------------------------------------------
                      02496 ; Smart programming success. Now for some over-programming.
                      02497 ; On Entry:
                      02498 ;   PROGREPS-(R4-1) = number of tries from previous step (P)
                      02499 ;   R6=programming mode:
                      02500 ;      <6:4> Phase 1 type
                      02501 ;        0: program until match, then program n times
                      02502 ;        1: program until match, then 1 pulse that is n*ET_PROGPULSE long
                      02503 ;        2: program until match (P), then nP times
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 42
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02504 ;        3: program until match, then 1 pulse that is n*P*ET_PROGPULSE long
                      02505 ;        4: Program n times
                      02506 ;        5: Program once, pulse time = n*ET_PROGPULSE
                      02507 ;    R5 =  n
                      02508 ;--------------------------------------------------------------------------------
0011DA 5212           02509 overprog:   movf    R5,F,0                  ;test n
0011DC E00D           02510             bz      smart_n0                ;n=0? then done
                      02511 
                      02512 ;Calculate R5 = n or R5 = nP, depending on R6<5>
0011DE 0411           02513             decf    R4,W,0                  ;count final write
0011E0 5C27           02514             subwf   PROGREPS,W,0            ;calculate P
                      02515 
0011E2 0212           02516             mulwf   R5,0                    ;compute nP
0011E4 66F4           02517             tstfsz  PRODH,0                 ;overflow?
0011E6 68F3           02518             setf    PRODL,0                 ;y: limit to 255
                      02519 
0011E8 BA13           02520             btfsc   R6,0x05,0               ;nP type algorithm?
0011EA CFF3 F012      02521             movff   PRODL,R5                ;y: replace n with nP
                      02522 
                      02523 ;Fall into smart_n
                      02524 
                      02525 ;---------------------------------------------------------------
                      02526 ; Overprogramming phase
                      02527 ; On Entry:
                      02528 ;   R5 = n or nP, depending on algorithm
                      02529 ;   R6<4> = 0 causes the byte to be written R5 times
                      02530 ;   R6<4> = 1 causes the byte to be written once, with a pulse
                      02531 ;             that is R5*(PPULSEH:PPULSEHL) long   
                      02532 ;---------------------------------------------------------------
                      02533 ;Fat overprogramming pulse or many pulses?
0011EE B813           02534 smart_n:        btfsc   R6,0x04,0
0011F0 D004           02535                 bra     op_fatpulse
                      02536 
                      02537 ;----------------------------------------------------------
                      02538 ; Write the byte R5 times
                      02539 ;----------------------------------------------------------
0011F2 D81C           02540 smart_nloop:        rcall   pulse_byte
0011F4 0612           02541                     decf    R5,F,0
0011F6 E1FD           02542                     bnz     smart_nloop
                      02543 
0011F8 0012           02544 smart_n0:       return
                      02545 
                      02546 ;-------------------------------------------------------------
                      02547 ; Write once with a pulse that is R5*(PPULSEH:PPULSEHL) long
                      02548 ;-------------------------------------------------------------
0011FA C023 F015      02549 op_fatpulse:    movff   PPULSEL,R8          ;temp save PPULSE value
0011FE C024 F016      02550                 movff   PPULSEH,R9
                      02551 
                      02552 ;Calculate pulse width = R5*(PPULSEH:PPULSEHL), with a max value of 64K
001202 5012           02553                 movf    R5,W,0              ;compute pulse width
001204 0223           02554                 mulwf   PPULSEL             ;8X16 multiply
001206 CFF3 F023      02555                 movff   PRODL,PPULSEL       ;low byte of result
00120A CFF4 F011      02556                 movff   PRODH,R4            ;partial high byte
                      02557 
00120E 0224           02558                 mulwf   PPULSEH
001210 50F3           02559                 movf    PRODL,W,0           ;add in cross-product
001212 2411           02560                 addwf   R4,W,0
001214 6E24           02561                 movwf   PPULSEH             ;result in PPULSEH:PPULSEHL
                      02562     
001216 E202           02563                 bc      opf_ovflow          ;should be no carry
001218 50F4           02564                 movf    PRODH,W             ;should be nothing in PRODH
00121A E002           02565                 bz      opf_novflow
                      02566 
00121C 6823           02567 opf_ovflow:     setf    PPULSEL             ;overflow:make it max
00121E 6824           02568                 setf    PPULSEH
001220                02569 opf_novflow:
                      02570 
                      02571 ;Overprogram now
001220 D805           02572                 rcall   pulse_byte          ;program now with fat pulse
                      02573 
                      02574 ;Restore and return
001222 C015 F023      02575                 movff   R8,PPULSEL          ;restore pulse width
001226 C016 F024      02576                 movff   R9,PPULSEH
                      02577 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 43
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00122A 0012           02578                 return
                      02579 
                      02580 ;*==============================================================================*
                      02581 ; Subroutine to write one EPROM byte once
                      02582 ; On Entry:
                      02583 ;   the address and data are already on the EPROM pins
                      02584 ;   The EPROM is powered up for programming and chip-selected as needed
                      02585 ;  PMODE bits tell programming pulse type
                      02586 ;  PPULSEH:PPULSEH + 30 = pulse width in units of 10 uS (0 means <1 uS pulse)
                      02587 ; (18.5 uS min before initiating strobe pulse)
                      02588 ; Trashes W,R0,R1,R3,EEADR,TBLPTR
                      02589 ;*==============================================================================*
00122C B621           02590 pulse_byte:     btfsc   FLAGS2,FAST_PULSE,0 ;(.5) less than 1 uS pulse?
00122E D04E           02591                 bra     fast_pgmpulse       ;(always on PGM pin)
                      02592 
001230 A221           02593                 btfss   FLAGS2,PMODE1,0     ;(.5)Vpp or PGM?
001232 D034           02594                 bra     vpp_pulse           ;cleared means Vpp
                      02595 
001234 0E01           02596                 movlw   0x01                ;(.25)PGM to active
001236 DAD8           02597                 rcall   pgm2pin             ;(.5)start the PGM pulse
                      02598 
                      02599 ;Delay for (PPULSEH:PPULSEL * 10) + 12 uS
001238 D838           02600                 rcall   stall_ppulse        ;(.5 + (PPULSEH:PPULSEL * 10) + 12.5 uS)
                      02601 
                      02602 ;End the PGM pulse
00123A 0000           02603                 nop                         ;(.25)stall to add up to 30 uS
00123C 0000           02604                 nop                         ;(.25)
00123E 0000           02605                 nop                         ;(.25)
001240 0E00           02606                 movlw   0x00                ;(.25)inactive PGM
001242 DAD2           02607                 rcall   pgm2pin             ;(.5+15.5 min) end pulse
                      02608 ;Total overhead = 30 uS
                      02609 
                      02610 ;Fall into stall_between
                      02611 
                      02612 ;*==============================================================================*
                      02613 ; Subroutine to stall between pulses
                      02614 ; On Entry:
                      02615 ;   PPDELH:PPDELL = 0000 means no delay
                      02616 ;   PPDELH:PPDELL = 0001 means EEPROM-style data polling
                      02617 ;   PPDELH:PPDELL > 0001: stall for (PPDELH:PPDELL * 10) + 12.75 uS
                      02618 ;   LATD = data written to EPROM
                      02619 ; Trashes R1,R0
                      02620 ;*==============================================================================*
001244 5025           02621 stall_between:  movf    PPDELL,W,0          ;(25)
001246 1026           02622                 iorwf   PPDELH,W,0          ;(.25)
001248 E013           02623                 bz      no_stall            ;(.25) 0000 means no delay
                      02624 
00124A 0425           02625                 decf    PPDELL,W,0          ;(.25)EEPROM wait?
00124C 1026           02626                 iorwf   PPDELH,W,0          ;(.25)
00124E E011           02627                 bz      eepoll              ;(.25)y: go poll the EEPROM
                      02628 
001250 0E09           02629                 movlw   0x09                ;(.5)stall to match stall_pulse's delay
001252 EC1F F000      02630                 call    K_STALL1U           ;(10)
                      02631 
001256 C026 F00E      02632                 movff   PPDELH,R1           ;(.25) stall between pulses
00125A C025 F00D      02633                 movff   PPDELL,R0           ;(.25)
                      02634 
                      02635 ;Fall into stall_r1r0
                      02636 
                      02637 ;--------------------------------------------------------------------------------
                      02638 ; Local subroutine to stall for ((R1:R0+1) * 10) + .25 uS
                      02639 ; Trashes R1,R0
                      02640 ;--------------------------------------------------------------------------------
00125E 0E07           02641 stall_r1r0:         movlw   0x07            ;(.25)
001260 EC1F F000      02642                     call    K_STALL1U       ;(8)
001264 0000           02643                     nop                     ;(.25)
001266 0E01           02644                     movlw   0x01            ;(.25)
001268 5E0D           02645                     subwf   R0,F,0          ;(.25)
00126A A0D8           02646                     btfss   STATUS,C,0      ;(.25)
00126C 5E0E           02647                     subwf   R1,F,0          ;(.25)
00126E E2F7           02648                     bc      stall_r1r0      ;(.5/.25)
                      02649 
001270 0012           02650 no_stall:       return                      ;(.5)
                      02651 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 44
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02652 ;--------------------------------------------------------------------------------
                      02653 ; EEPROM-style data polling, with timeout
                      02654 ; (Some EEPROMs invert data bit 7 until programming completes.)
                      02655 ; Trashes W,R0,R1,R2,R3,R4
                      02656 ;--------------------------------------------------------------------------------
001272 6895           02657 eepoll:         setf    TRISD,0             ;tristate the PIC's data buffers
001274 9C8A           02658                 bcf     LATB,DBUFDIR,0      ;point the external data buffer toward PIC
                      02659 
001276 6A11           02660                 clrf    R4,0                ;set up timeout timer for about 9 mS
                      02661 
                      02662 ;Poll data (particularly bit 7) until it matches or timeout
001278 0611           02663 poll_loop:          decf    R4,F,0          ;(.25)timeout?
00127A E00D           02664                     bz      poll_timeout    ;(.25)this loop takes 31.5 uS per pass                  
00127C 0E01           02665                     movlw   0x01            ;(.25)active state for -OE so we can read
00127E DA97           02666                     rcall   oen2pin         ;(14+.5) Trashes W,R0,R1,R3
                      02667 
001280 0E02           02668                     movlw   2               ;(.25)Stall for slow -OE signal
001282 EC1F F000      02669                     call    K_STALL1U       ;(3)
                      02670 
001286 0E00           02671                     movlw   0x00            ;(.25)prepare to disable output
001288 CF83 F00F      02672                     movff   PORTD,R2        ;(.5)read the EPROM data, temp save in R2
00128C DA90           02673                     rcall   oen2pin         ;(14+.5)disable EPROM's output buffer. Trashes W,R0,R1,R3
                      02674 
00128E 500F           02675                     movf    R2,W,0          ;(.25)compare written data to EPROM data
001290 188C           02676                     xorwf   LATD,W,0        ;(.25)data bit 7 does not match until done
001292 E1F2           02677                     bnz     poll_loop       ;(.5)
                      02678 
001294 0012           02679                 return
                      02680 
                      02681 ;Timeout waiting for EEPROM to complete the write
001296 EE01 F0DA      02682 poll_timeout:   lfsr    0,pto_msg-sstrings  ;"\rAbort: EEPROM polling timeout"
00129A D0CE           02683                 bra     msg_abort
                      02684 
                      02685 ;--------------------------------------------------------------------------------
                      02686 ; Local subroutine to program the byte using a ((PPULSEH:PPULSEL x 10) + 30)
                      02687 ; uS Vpp pulse
                      02688 ; Note that PULSEH:PPULSEL has already been reduced by 3 to account
                      02689 ; for the 30 uS overhead of this loop.
                      02690 ;--------------------------------------------------------------------------------
                      02691 ;Start a Vpp pulse
00129C 0E03           02692 vpp_pulse:      movlw   0x03                ;Vpp on to programming level
00129E DA4E           02693                 rcall   vpp2pin             ;[(.5 + .5) since Vpp on]
                      02694 
                      02695 ;Delay for PPULSEH:PPULSEL * 10) + 12 uS
0012A0 D804           02696                 rcall   stall_ppulse        ;((PPULSEH:PPULSEL * 10) + 12 uS)
                      02697 
                      02698 ;Put Vpp at programming-inactive level
0012A2 0E02           02699                 movlw   0x02                ;(.25) Vpp to programming-inactive level
0012A4 EC9E F00B      02700                 call    vpp2pin             ;(16 + .5) turn off pulse & return
                      02701 
                      02702 ;Stall as required
0012A8 D7CD           02703                 bra     stall_between       ;(.5)
                      02704 
                      02705 ;Total overhead = 30 uS
                      02706 
                      02707 ;*==================================================================================*
                      02708 ; Subroutine to stall for (PPULSEH:PPULSEL * 10) + 12.5 uS (including the call to
                      02709 ; check Vpp for under-voltage as early as possible), and abort if too low.
                      02710 ; On Entry: 
                      02711 ;   The ADC is set up with Tad = 1 uS (so that a complete conversion will take 11 uS)
                      02712 ; Trashes R1,R0
                      02713 ;*==================================================================================*
0012AA 82C2           02714 stall_ppulse:   bsf     ADCON0,GO,0             ;(.25)set GO to initiate an ADC conversion
0012AC C024 F00E      02715                 movff   PPULSEH,R1              ;(.5)prepare for stall
0012B0 C023 F00D      02716                 movff   PPULSEL,R0              ;(.5)
                      02717 
                      02718 ;Check ADC to make sure Vpp is reasonable. If the EPROM is drawing too much current
                      02719 ;then the hardware current limiter will cause Vpp to drop, which we will detect here.
                      02720 
0012B4 502B           02721                 movf    VSENSE_LOW,W,0          ;(.25)prepare to check for low voltage
                      02722 
0012B6 B2C2           02723 spp_adcwait:        btfsc   ADCON0,GO           ;(.5)wait for conversion to complete
0012B8 D7FE           02724                     bra     spp_adcwait         ;(11 uS total time from GO was set)
                      02725 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 45
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02726 ;about 11.75 uS to here
                      02727 
0012BA 5CC4           02728                 subwf   ADRESH,W,0              ;(.25)get ADC result 2 uS after initiation
                      02729                                                 ;W:= measured voltage - lower  limit
0012BC E2D0           02730                 bc      stall_r1r0              ;(.5)carry set if ok, so go stall
                      02731 
                      02732 ;--------------------------------------------------------------------------------
                      02733 ; ABORT: Vpp voltage is too low, probably because the EPROM is drawing too much
                      02734 ; current.
                      02735 ; Panic shutdown Vpp and quit.
                      02736 ;--------------------------------------------------------------------------------
0012BE EE02 F014      02737                 lfsr    0,lvpanic_msg-sstrings  ;"Abort! Vpp is too low"
                      02738 
                      02739 ;Fall into prog_abort
                      02740 
                      02741 ;*==============================================================================*
                      02742 ;Programming abort: clean up and go to main
                      02743 ; On Entry:
                      02744 ;   FSR0 = string to print
                      02745 ;*==============================================================================*
0012C2 D87B           02746 prog_abort:     rcall   epower_off              ;power off immediately
0012C4 8EF2           02747                 bsf     INTCON,GIE,0            ;reenable interrupts
                      02748 
0012C6 D894           02749                 rcall   printf
0012C8 EF3A F004      02750                 goto    main                    ;rude abort
                      02751 
                      02752 ;*==============================================================================*
                      02753 ; Subroutine to program with a fast (~500 nS) active-low or active-high
                      02754 ; programming pulse on pin the PGM pin. (Short pulse required for EEPROMs)
                      02755 ; After the programming pulse, stall or poll the EEPROM as required.
                      02756 ; Trashes W,R0
                      02757 ;*==============================================================================*
0012CC 0E1A           02758 fast_pgmpulse:  movlw   ET_PGMVPP           ;figure out which pin is PGM
0012CE DAF9           02759                 rcall   etype_getval
0012D0 0B70           02760                 andlw   0x70                ;just get the PGM pin assignment bits
0012D2 6E0D           02761                 movwf   R0,0                ;so we can swap
0012D4 3A0D           02762                 swapf   R0,F,0              ;put PGM bits in R0<2:0>
                      02763 
                      02764 ;7-way branch based on R0 - the PGM pin assignment
0012D6 50F9           02765 fjtab:          movf    PCL,W,0             ;force a load of the PCLATH register (page 62)
0012D8 440D           02766                 rlncf   R0,W,0              ;command index (times 2 for jump table)
0012DA 26F9           02767                 addwf   PCL,F,0
                      02768 
0012DC 0012           02769                 return                      ;if no PGM pin defined
0012DE D018           02770                 bra     fast18              ;PGM is on pin 18
0012E0 D013           02771                 bra     fast19              ;PGM is on pin 19
0012E2 D00E           02772                 bra     fast20              ;PGM is on pin 20
0012E4 D009           02773                 bra     fast21              ;PGM is on pin 21
0012E6 D004           02774                 bra     fast22              ;PGM is on pin 22
0012E8                02775 fjtend:                                     ;Fall through to fast23 if PGM is on pin 23
                      02776 
                      02777 ;Quick-pulse on pin 23
0012E8 708B           02778 fast23:         btg     LATC,P23n,0
0012EA 0000           02779                 nop
0012EC 708B           02780                 btg     LATC,P23n,0
0012EE D7AA           02781                 bra     stall_between       ;stall as needed, then return from there
                      02782 
                      02783 ;Quick-pulse on pin 22
0012F0 7A8A           02784 fast22:         btg     LATB,P22n,0
0012F2 0000           02785                 nop
0012F4 7A8A           02786                 btg     LATB,P22n,0
0012F6 D7A6           02787                 bra     stall_between       ;stall as needed, then return from there
                      02788 
                      02789 ;Quick-pulse on pin 21
0012F8 708D           02790 fast21:         btg     LATE,P21_0,0
0012FA 0000           02791                 nop
0012FC 708D           02792                 btg     LATE,P21_0,0
0012FE D7A2           02793                 bra     stall_between       ;stall as needed, then return from there
                      02794 
                      02795 ;Quick-pulse on pin 20
001300 7C89           02796 fast20:         btg     LATA,P20_0,0
001302 0000           02797                 nop
001304 7C89           02798                 btg     LATA,P20_0,0
001306 D79E           02799                 bra     stall_between       ;stall as needed, then return from there
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 46
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02800 
                      02801 ;Quick-pulse on pin 19
001308 7889           02802 fast19:         btg     LATA,P19_0,0
00130A 0000           02803                 nop
00130C 7889           02804                 btg     LATA,P19_0,0
00130E D79A           02805                 bra     stall_between       ;stall as needed, then return from there
                      02806 
                      02807 ;Quick-pulse on pin 18
001310 7489           02808 fast18:         btg     LATA,P18_0,0
001312 0000           02809                 nop
001314 7489           02810                 btg     LATA,P18_0,0
001316 D796           02811                 bra     stall_between       ;stall as needed, then return from there
                      02812 
                      02813 ;*************************************************************
                      02814 ; The above jump table must not span a 256-byte page boundary.
                      02815 ;*************************************************************
                      02816     if high(fjtab)^ high(fjtend)
                      02817     error "Martin sez: Fast PGM pulse jump table spans a page boundary"
                      02818     endif
                      02819 
                      02820 ;*==============================================================================*
                      02821 ; Subroutine to read one byte from the EPROM
                      02822 ; On Entry:
                      02823 ;   ADDRESSH:ADDRESSL = desired address
                      02824 ;   ETYPE has the EPROM type
                      02825 ;   EPROM is powered up for reading
                      02826 ;   EPROM -OE and PGM signals are low (inactive)
                      02827 ;   DINV_STATE = FF if the EPROM data is to be inverted
                      02828 ; On Exit:
                      02829 ;   R2=W = EPROM data, inverted iff DINV_STATE = FF
                      02830 ;   PIC port D is tristated
                      02831 ;   The external data buffer is pointing toward the PIC, and is tristated
                      02832 ; Trashes W,R0,R3,FSR0,TBLPTRH:TBLTRL,REEADR
                      02833 ;*==============================================================================*
001318 DAB9           02834 eread_byte: rcall   address2pins        ;put the address onto the EPROM pins
                      02835 
00131A 0E00           02836             movlw   0x00                ;strobe the address, if there is an address strobe
00131C DA6C           02837             rcall   asn2pin             ;(asn2pin just returns if there isn't.)
                      02838 
00131E 0E03           02839             movlw   0x03                ;(.25)Remember that pin 20 (which may be the -AS pin)
001320 EC1F F000      02840             call    K_STALL1U           ;(4)..is slow due to its 0.047 uF capacitor
                      02841 
001324 0E01           02842             movlw   0x01                ;leave pin in the active state
001326 DA67           02843             rcall   asn2pin
                      02844 
001328 0E01           02845             movlw   0x01                ;set EPROM chip select active
00132A DAAA           02846             rcall   cs2pin              ;(1.5 after CS write)
                      02847 
00132C 6895           02848             setf    TRISD               ;(.25)tristate the PIC's data buffers
00132E 9C8A           02849             bcf     LATB,DBUFDIR,0      ;(.25)point the external data buffer toward PIC
001330 9E8A           02850             bcf     LATB,DBUFOEn,0      ;(.25)enable that data buffer's output
                      02851 
001332 0E21           02852             movlw   DINV_STATE          ;(.25) get data inversion setting
001334 EC19 F000      02853             call    K_RDEEPROM          ;(1.5+.5) this one is in EEPROM
                      02854 
001338 1883           02855             xorwf   PORTD,W,0           ;actually read the EPROM data, invert as needed
00133A 6E0F           02856             movwf   R2,0                ;temp save
                      02857 
00133C 0E00           02858             movlw   0x00
00133E DAA0           02859             rcall   cs2pin              ;set EPROM chip select inactive
                      02860 
001340 8E8A           02861             bsf     LATB,DBUFOEn,0      ;disable data buffer's output
001342 500F           02862             movf    R2,W,0              ;EPROM data to W for return
001344 0012           02863             return
                      02864 
                      02865 ;*==============================================================================*
                      02866 ; Subroutine to power EPROM up for programming
                      02867 ; On Entry:
                      02868 ;   ETYPE = current EPROM type
                      02869 ; On Exit:
                      02870 ;   Busy light is on
                      02871 ;   Vcc is on, to its programming level
                      02872 ;   Vpp power supply is set for the correct Vpp voltage, and measured to see
                      02873 ;      that it is roughly correct
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 47
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02874 ;   Chip Select is active, unless it is also the PGM pulse signal
                      02875 ;   -OE is either inactive (logic high), or at +12V (if required for programming)
                      02876 ; Trashes W,R0,R1,R2,R3,R4,FSR0,TBLPTRH:TBLTRL,REEADR
                      02877 ;*==============================================================================*
001346 848D           02878 epower_prog:    bsf     LATE,ADRCLK,0           ;turn on the busy light
                      02879 
                      02880 ;Start the Vpp switcher for this EPROM's Vpp voltage. Note that if an external
                      02881 ;(negative) supply is called for, then the onboard Vpp will be turned off. If Vpp
                      02882 ;manual adjustment is required, then the appropriate Vpp voltage (which must
                      02883 ;adjusted) was specified when the EPROM was selected.
001348 D9AA           02884                 rcall   eset_vpp
                      02885 
                      02886 ;Set EPROM chip select active, unless it is also the PGM pin. Note that this
                      02887 ;will be overwritten very soon if Vpp is on the same pin as (-)CS.
00134A 0E01           02888                 movlw   0x01
00134C A61F           02889                 btfss   SHARED,CSPGM,0
00134E DA98           02890                 rcall   cs2pin
                      02891 
                      02892 ;turn on any stuck-high pin, in case it's really a Vdd pin
001350 0E01           02893                 movlw   0x01                ;on
001352 DA8D           02894                 rcall   hi2pin
                      02895 
                      02896 ;Set the (-)PGM pin to its inactive state, if there is one
001354 0E00           02897                 movlw   0x00
001356 DA48           02898                 rcall   pgm2pin
                      02899 
                      02900 ;Turn on Vcc for programming
001358 0E02           02901                 movlw   0x02
00135A D9C9           02902                 rcall   vcc2pin
                      02903 
                      02904 ;Turn on Vbb and Vdd, if they exist
00135C 0E01           02905                 movlw   0x01
00135E D9DC           02906                 rcall   vbbvdd2pins 
                      02907 
                      02908 ;Stall to let the Vpp power supply come up to speed
001360 0E28           02909                 movlw   .40                     ;10 mS
001362 EC1E F000      02910                 call    K_STALL250U
                      02911 
                      02912 ;Set up -OE either inactive or at its special programming voltage, if there
                      02913 ;is such a thing: it may possibly be +12V or Vpp.
                      02914 ;If Vpp is the same pin as -OE then: if Vpp is pulsed, then it will be set to
                      02915 ;the programming-inactive state. If Vpp is not pulsed, then turn Vpp is on.
001366 0E02           02916                 movlw   0x02                    ;set -OE to its Programming level
001368 DA22           02917                 rcall   oen2pin
                      02918 
                      02919 ;If this EPROM pulses Vpp, then put Vpp at programming-inactive level
                      02920 ;Otherwise (for pulsed PGM) put it at the active level.
00136A 0E02           02921                 movlw   0x02                    ;programming-inactive level
00136C B221           02922                 btfsc   FLAGS2,PMODE1,0         ;0 means Vpp is pulsed
00136E 0E03           02923                 movlw   0x03                    ;programming-active level
001370 D9E5           02924                 rcall   vpp2pin
                      02925 
                      02926 ;Check that the Vpp is roughly correct, using the ADC
001372 82C2           02927                 bsf ADCON0,GO                   ;start conversion
                      02928 
001374 B2C2           02929 ep_adcwait:         btfsc   ADCON0,GO           ;wait for conversion to complete
001376 D7FE           02930                     bra     ep_adcwait
                      02931 
001378 6811           02932                 setf    R4,0                    ;remember too high
00137A 50C4           02933                 movf    ADRESH,W,0              ;get ADC result
00137C 5C2C           02934                 subwf   VSENSE_HIGH,W,0         ;W:= upper limit-result, C set if ok
00137E E305           02935                 bnc     panic_vpp
                      02936 
001380 6A11           02937                 clrf    R4,0                    ;remember too low
001382 502B           02938                 movf    VSENSE_LOW,W,0          ;lower limit
001384 5CC4           02939                 subwf   ADRESH,W,0              ;W:=result - lower limit, C set if ok
001386 E301           02940                 bnc     panic_vpp
                      02941 
001388 0012           02942                 return
                      02943 
                      02944 ;Vpp is out of spec - abort - too high if R4=FF, too low if R4=0
00138A D817           02945 panic_vpp:      rcall   epower_off              ;power off immediately
                      02946 
00138C EE01 F0FA      02947                 lfsr    0,hvpanic_msg-sstrings  ;""Abort! Vpp is too high"
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 48
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001390 5211           02948                 movf    R4,F,0
001392 B4D8           02949                 btfsc   STATUS,Z,0
001394 EE02 F014      02950                 lfsr    0,lvpanic_msg-sstrings  ;""Abort! Vpp is too low"
                      02951 
001398 D04F           02952                 bra     msg_abort
                      02953 
                      02954 ;*==============================================================================*
                      02955 ; Subroutine to power EPROM up for reading
                      02956 ; On Entry:
                      02957 ;   ETYPE = current EPROM type
                      02958 ; On Exit:
                      02959 ;   Busy light is on
                      02960 ;   Vpp power supply is still on (unchanged)
                      02961 ;   -OE is active, enabling the EPROM's output buffer
                      02962 ; Trashes W,R0,R1,R2,R3,TBLPTRH:TBLTRL,REEADR
                      02963 ;*==============================================================================*
00139A 848D           02964 epower_read:    bsf     LATE,ADRCLK,0       ;turn on the busy light
                      02965 
                      02966 ;turn on any stuck-high pin, in case it's really a Vdd pin
00139C 0E01           02967                 movlw   0x01                ;on
00139E DA67           02968                 rcall   hi2pin
                      02969 
                      02970 ;Set PGM pin inactive
0013A0 0E00           02971                 movlw   0x00
0013A2 DA22           02972                 rcall   pgm2pin
                      02973 
                      02974 ;Turn on Vcc for reading
0013A4 0E01           02975                 movlw   0x01
0013A6 D9A3           02976                 rcall   vcc2pin
                      02977 
                      02978 ;Turn on Vbb and Vdd, if they exist
0013A8 0E01           02979                 movlw   0x01
0013AA D9B6           02980                 rcall   vbbvdd2pins 
                      02981 
                      02982 ;Put the reading voltage on Vpp
0013AC 0E01           02983                 movlw   0x01
0013AE D9C6           02984                 rcall   vpp2pin
                      02985 
                      02986 ;Set up -OE for reading
0013B0 0E01           02987                 movlw   0x01            ;active for reading
0013B2 D9FD           02988                 rcall   oen2pin
                      02989 
                      02990 ;Stall to let power supply come up to speed
0013B4 0E04           02991                 movlw   .4              ;1 mS
0013B6 EF1E F000      02992                 goto    K_STALL250U     ;return from there
                      02993 
                      02994 ;*==============================================================================*
                      02995 ; Subroutine to turn off power to the EPROM
                      02996 ; On Entry:
                      02997 ;   ETYPE = current EPROM type
                      02998 ; On Exit:
                      02999 ;   Busy light is off
                      03000 ;   All EPROM pins are floating or at 0V
                      03001 ;   Vpp power supply is still on (unchanged)
                      03002 ; Trashes W,R0,R1,R2,R3,TBLPTRH:TBLTRL,REEADR
                      03003 ;*==============================================================================*
0013BA 0E00           03004 epower_off:     movlw   0x00
0013BC D9BF           03005                 rcall   vpp2pin             ;disconnect EPROM from Vpp
                      03006 
0013BE 0E00           03007                 movlw   0                   ;shup down the switching power supply
0013C0 D972           03008                 rcall   set_vpp             ;(its output will drift down to +11.3V)
                      03009 
0013C2 0EDF           03010                 movlw   (1<<P22n) ^ 0xFF    ;turn everything on port b off (especially Vcc)
0013C4 128A           03011                 iorwf   LATB,F,0            ;..except pin 22 (because pin 22 could be PGM)
                      03012 
0013C6 6A05           03013                 clrf    ADDRESSL,0          ;put address lines to 0V
0013C8 6A06           03014                 clrf    ADDRESSH,0
0013CA DA60           03015                 rcall   address2pins
                      03016 
0013CC 0E14           03017                 movlw   .20                 ;5 mS
0013CE EC1E F000      03018                 call    K_STALL250U         ;Stall to let power supplies shut down
                      03019 
                      03020 ;The PGM pin, or the -CE pin that serves as the PGM pin, will be on one of pins 18-22.
                      03021 ;Shut these down well after the power supplies are off, to avoid a spurious write.
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 49
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0013D2 688A           03022                 setf    LATB,0              ;turn off in particular pin 22 (in case it's PGM)
0013D4 6A89           03023                 clrf    LATA,0              ;turn off pins 18-20
0013D6 6A8D           03024                 clrf    LATE,0              ;turn off pin 21 and the Busy light
                      03025 
0013D8 0012           03026                 return
                      03027 
                      03028 ;*==============================================================================*
                      03029 ; Subroutine to print the buffer row's address as 4 hex digits, followed by ': '
                      03030 ;
                      03031 ; On Entry:
                      03032 ;   ADDRESSH:ADDRESSL has the buffer address of the byte to be printed
                      03033 ; On Exit:
                      03034 ;   This row's address has been printed, followed by a colon
                      03035 ;   CHECKSUM unchanged
                      03036 ;   W, R0, R1, FSR0 trashed
                      03037 ;*==============================================================================*
0013DA 0E0D           03038 print_addr:     movlw   CR                          ;print CR-LF
0013DC EC06 F000      03039                 call    K_CONOUT
                      03040 
0013E0 5006           03041                 movf    ADDRESSH,W,0
0013E2 EC0A F000      03042                 call    K_PRINTHEX2                 ;don't mess up CHECKSUM
                      03043 
0013E6 5005           03044                 movf    ADDRESSL,W,0                ;low byte of address
0013E8 EC0A F000      03045                 call    K_PRINTHEX2                 ;don't mess up CHECKSUM
                      03046 
0013EC EE03 F03C      03047                 lfsr    0,colonspace_msg-sstrings   ; ': '
                      03048 
                      03049 ;Fall into printf
                      03050 
                      03051 ;*==============================================================================*
                      03052 ; Subroutine to print a null-terminated string
                      03053 ; Note that strings must be in the 1st 4K of RAM, because FSR0 is a 12-bit
                      03054 ; register.
                      03055 ; On Entry:
                      03056 ;   FSR0 + sstrings = address of the null-terminated string
                      03057 ; On Exit:
                      03058 ;   W,R0,TBLPTR,FSR0 trashed
                      03059 ;   Receive interrupt (RCIE) is enabled
                      03060 ;*==============================================================================*
0013F0 CFEA FFF7      03061 printf:         movff   FSR0H,TBLPTRH
0013F4 CFE9 FFF6      03062                 movff   FSR0L,TBLPTRL
                      03063 
0013F8 0E44           03064 do_printf:      movlw   low(sstrings)
0013FA 26F6           03065                 addwf   TBLPTRL,F,0
0013FC 0E24           03066                 movlw   high(sstrings)
0013FE 22F7           03067                 addwfc  TBLPTRH,F,0
001400 EF07 F000      03068                 goto    K_PRINTF        ;print string at TBLPTRH:TBLPTRL
                      03069                 
                      03070 ;*==============================================================================*
                      03071 ; Subroutine to print CR/LF, followed by a null-terminated string
                      03072 ; On Entry:
                      03073 ;   FSR0 points to the null-terminated string
                      03074 ; On Exit:
                      03075 ;   W,R0,FSR0,TBLPTR,FSR0 trashed
                      03076 ;   Receive interrupt (RCIE) is enabled
                      03077 ;*==============================================================================*
001404 CFEA FFF7      03078 cr_printf:      movff   FSR0H,TBLPTRH
001408 CFE9 FFF6      03079                 movff   FSR0L,TBLPTRL
00140C 0E0D           03080                 movlw   CR
00140E EC06 F000      03081                 call    K_CONOUT            ;print CRLF. Trashes FSR0.
                      03082 
001412 D7F2           03083                 bra     do_printf           ;print string at TBLPTRH:TBLPTRL
                      03084 
                      03085 ;*==============================================================================*
                      03086 ; Subroutine to check for a pause (space bar) or abort (control-C or ESC) from
                      03087 ; the user
                      03088 ; Note that control-S will also pause via the receive interrupt.
                      03089 ;*==============================================================================*
001414 EC16 F000      03090 check_pause:    call    K_CHKABORT          ;user abort?
001418 E007           03091                 bz      cp_done             ;Z if no user input
00141A E20F           03092                 bc      quiet_abort         ;C if user abort
                      03093 
00141C 0A20           03094                 xorlw   ' '                 ;pause?
00141E E104           03095                 bnz     cp_done             ;ignore anything else
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 50
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03096 
                      03097 ;Paused. Hang out here until the user types anything else. Abort if requested.
001420 EC16 F000      03098 pause_loop:     call    K_CHKABORT          ;user abort?
001424 E0FD           03099                 bz      pause_loop          ;Z if no user input
001426 E209           03100                 bc      quiet_abort         ;rude abort, no message
                      03101 
001428 0012           03102 cp_done:        return                      ;normal exit
                      03103 
                      03104 ;*==============================================================================*
                      03105 ; Subroutine to flush any user input in the Rx queue, and check for control-C or
                      03106 ; Escape. Abort if either is found.
                      03107 ; Trashes W,R0,FSR0
                      03108 ; (5.5 uS if no chrs waiting)
                      03109 ;*==============================================================================*
00142A EC16 F000      03110 flush_abort:        call    K_CHKABORT      ;(4+.5)user abort?
00142E E202           03111                     bc      abort           ;(.25)abort if requested
001430 E1FC           03112                     bnz     flush_abort     ;(.25)flush everything in the receive queue
                      03113 
001432 0012           03114                 return                      ;(.5)
                      03115 
                      03116 ;*==============================================================================*
                      03117 ; Abort operation: print 'abort', power down, and rudely jump to main
                      03118 ;*==============================================================================*
001434 EE01 F0D2      03119 abort:          lfsr        0,abort_msg-sstrings
                      03120 
001438 DFDB           03121 msg_abort:      rcall       printf
                      03122 
00143A DFBF           03123 quiet_abort:    rcall       epower_off      ;power off, turn off busy light
00143C EF3A F004      03124                 goto        main            ;hoses stack, but main fixes it
                      03125 
                      03126 ;*==============================================================================*
                      03127 ; Subroutine to ask the user for y (yes) or n (no) (allowing both lowercase and
                      03128 ; uppercase)
                      03129 ; On Entry:
                      03130 ;    FSR0 = ask string
                      03131 ; Aborts if not 'N', returns if 'Y'. Nags until 'Y' or 'N'
                      03132 ; Trashes W, R0, FSR0
                      03133 ;*==============================================================================*
001440 DFE1           03134 ask_yn:         rcall   cr_printf           ;print page 1 ask string
001442 EC15 F000      03135                 call    K_ASKYN
001446 E1F6           03136                 bnz     abort               ;NZ means no
                      03137 
001448 0012           03138                 return
                      03139 
                      03140 ;*==============================================================================*
                      03141 ; Subroutine to print W as a 2-character hex value, and add value to CHECKSUM
                      03142 ; On Entry:
                      03143 ;   byte to send is in W
                      03144 ;   CHECKSUM is valid for all prior bytes
                      03145 ; On Exit:
                      03146 ;   W, R0, R1, FSR0, BSR trashed
                      03147 ;   incoming byte has been added to CHECKSUM
                      03148 ;*==============================================================================*
00144A 2604           03149 print_hex_csum: addwf   CHECKSUM,F,0            ;accumulate checksum
00144C EF0A F000      03150                 goto    K_PRINTHEX2
                      03151 
                      03152 ;*==============================================================================*
                      03153 ; Subroutine to set the count to the maximum count for the current EPROM type,
                      03154 ; if no count was specified, or if the specified count is too large
                      03155 ; On Entry:
                      03156 ;   COUNTH:COUNTL = the specified count, which is definitely not 0000
                      03157 ;   ETYPE has the current EPROM type
                      03158 ;   FULL_FLAG is cleared unless COUNTH:COUNTL = 8K
                      03159 ; On Exit:
                      03160 ;   COUNTH:COUNTL = the byte count of the current EPROM, or the provided count,
                      03161 ;          whichever is lesser
                      03162 ;   FULL_FLAG set if the count was limited to an entire EPROM
                      03163 ; Trashes W,R0,R1
                      03164 ;*==============================================================================*
                      03165 ;Get the (encoded) byte count for the current EPROM type
001450 0E16           03166 limit_count:    movlw   ET_BYTES            ;figure out how many bytes this EPROM has
001452 DA37           03167                 rcall   etype_getval
001454 0B07           03168                 andlw   0x07                ;W<2:0> values are 0-6 for 256-8192
001456 6E0E           03169                 movwf   R1,0                ;into R1
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 51
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03170 
                      03171 ;Compute the actual byte count from the encoded byte count
001458 2A0E           03172                 incf    R1,F,0              ;make it 1-7
                      03173 
00145A 0E80           03174                 movlw   0x80                ;compute in R2
00145C 6E0F           03175                 movwf   R2,0
                      03176 
00145E 460F           03177 lbc_loop:           rlncf   R2,F,0          ;compute high byte of count
001460 060E           03178                     decf    R1,F,0
001462 E1FD           03179                     bnz     lbc_loop        ;when done, max count is in R2
                      03180 
                      03181 ;Test to see if the provided byte count is less than the max, and return if so
001464 5019           03182                 movf    COUNTH,W,0
001466 5C0F           03183                 subwf   R2,W,0              ;max count - COUNTH
001468 E302           03184                 bnc     lbc_default         ;carry clear if COUNTH > max count
00146A A4D8           03185                 btfss   STATUS,Z,0          ;equal?
00146C 0012           03186                 return                      ;n: no default required
                      03187 
                      03188 ;COUNTL must be 0 if COUNTH is at the max value, and this will be a full EPROM.
00146E C00F F019      03189 lbc_default:    movff   R2,COUNTH           ;full EPROM count
001472 6A18           03190                 clrf    COUNTL,0
001474 8820           03191                 bsf     FLAGS1,FULL_FLAG,0  ;complete EPROM operation (no 'range' in messages)
001476 0012           03192                 return
                      03193 
                      03194 ;*==============================================================================*
                      03195 ; Subroutine to circular-increment ADDRESSH:ADDRESSL (assuming 8K buffer),
                      03196 ; decrement COUNTH:COUNTL, and test for COUNTH:COUNTL=0
                      03197 ; On Exit:
                      03198 ;   ADDRESSH:ADDRESSL has been incremented, and cleared to 0 if it reached 8K
                      03199 ;   COUNTH:COUNTL has been decremented
                      03200 ;   Z set if COUNT has been decremented to 0
                      03201 ; Trashes W
                      03202 ; (2.75 uS)
                      03203 ;*==============================================================================*
001478 4A05           03204 next_a_count:   infsnz  ADDRESSL,F,0        ;(.5)16-bit increment address
00147A 2A06           03205                 incf    ADDRESSH,F,0
00147C 9A06           03206                 bcf     ADDRESSH,0x05,0     ;(.25)wrap at 8K
                      03207             
00147E 0E01           03208                 movlw   0x01                ;(.25)
001480 5E18           03209                 subwf   COUNTL,F,0          ;(.25)16-bit decrement counter
001482 A0D8           03210                 btfss   STATUS,C,0          ;(.5)
001484 0619           03211                 decf    COUNTH,F,0
                      03212 
001486 5019           03213                 movf    COUNTH,W,0          ;(.25)test counter for 0
001488 1018           03214                 iorwf   COUNTL,W,0          ;(.25)
00148A 0012           03215                 return                      ;(.5)with Z flag set if COUNT=0
                      03216 
                      03217 ;*==============================================================================*
                      03218 ; Subroutine to compare the specified range of the EPROM either to the
                      03219 ; buffer or to the erased value
                      03220 ; On Entry:
                      03221 ;   B_STATE set if this is a blank-check
                      03222 ;   R4 = blank value for blank check, taking into account data inversion
                      03223 ;        by eread_byte
                      03224 ;   ADDRESSH:ADDRESSL = EPROM starting address
                      03225 ;   (ADDRESSH+BUF_OFFSET):ADDRESSL = buffer starting address
                      03226 ;   COUNTH:COUNTL = byte count
                      03227 ; On Exit:
                      03228 ;   Results message is partially printed
                      03229 ; Trashes W,R0,R1,R2,R3, ADDRESSH:ADDRESSL,COUNTH:COUNTL
                      03230 ;*==============================================================================*
00148C                03231 ep_compare:
                      03232 
                      03233 ;Loop to compare eprom to buffer
00148C DF45           03234 ecmp_loop:          rcall   eread_byte          ;read EPROM at ADDRESSH:ADDRESSL, result in W
00148E 6E10           03235                     movwf   R3,0                ;remember for rep_mismatch
                      03236 
001490 5017           03237                     movf    BUF_OFFSET,W,0      ;buffer address offset
001492 2606           03238                     addwf   ADDRESSH,F,0        ;compute buffer address
                      03239 
001494 5011           03240                     movf    R4,W,0              ;erased EPROM value, taking into account
                      03241                                                 ;..possible inversion by eread_byte
                      03242 
001496 A420           03243                     btfss   FLAGS1,B_STATE,0    ;blank check or compare?
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 52
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001498 EC17 F000      03244                     call    K_RDSRAM            ;compare: read buffer data at ADDRESSH:ADDRESSL
                      03245 
00149C 6E0F           03246                     movwf   R2,0                ;remember buffer data for rep_mismatch
                      03247 
00149E 5017           03248                     movf    BUF_OFFSET,W,0      ;buffer address offset
0014A0 5E06           03249                     subwf   ADDRESSH,F,0        ;restore EPROM address
                      03250 
0014A2 500F           03251                     movf    R2,W,0              ;buffer data or erased EPROM value
0014A4 1810           03252                     xorwf   R3,W,0              ;compare to EPROM data
0014A6 A4D8           03253                     btfss   STATUS,Z,0          ;match?
0014A8 D834           03254                     rcall   rep_mismatch        ;n: report mismatch, allow user to abort
                      03255 
0014AA DFE6           03256                     rcall   next_a_count        ;bump address pointer, decrement count
0014AC E1EF           03257                     bnz     ecmp_loop
                      03258 
                      03259 ;Fall into eprange
                      03260 
                      03261 ;*==============================================================================*
                      03262 ; Subroutine to print 'EPROM', followed by 'range ', if needed
                      03263 ; On Entry:
                      03264 ;   FULL_FLAG = 1 if the byte count defaulted to the full EPROM size
                      03265 ;*==============================================================================*
0014AE EE01 F07E      03266 eprange:            lfsr    0,eprom_msg-sstrings    ;'EPROM '
                      03267 
                      03268 ;Fall into prange
                      03269 
                      03270 ;*==============================================================================*
                      03271 ; Subroutine to print CR, then message, followed by 'range ', if needed
                      03272 ; On Entry:
                      03273 ;   FSR0 = address of string to print ('EPROM ' or 'Buffer ')
                      03274 ;   FULL_FLAG = 1 if the byte count defaulted to the full EPROM size
                      03275 ;*==============================================================================*
0014B2 DFA8           03276 prange:         rcall   cr_printf               ;print provided string with initial CR
                      03277 
0014B4 EE01 F038      03278                 lfsr    0,range_msg-sstrings    ;'range '
0014B8 A820           03279                 btfss   FLAGS1,FULL_FLAG,0
0014BA DF9A           03280                 rcall   printf                  ;printed only if needed
                      03281 
0014BC 0012           03282                 return
                      03283 
                      03284 ;*==============================================================================*
                      03285 ;* Subroutine to save ADDRESSH:ADDRESSL and COUNTH:COUNTL in save location
                      03286 ;*==============================================================================*
0014BE C006 F01B      03287 save_params:    movff   ADDRESSH,ADDRESSH_SAVE
0014C2 C005 F01A      03288                 movff   ADDRESSL,ADDRESSL_SAVE
                      03289 
0014C6 C019 F01D      03290                 movff   COUNTH,COUNTH_SAVE
0014CA C018 F01C      03291                 movff   COUNTL,COUNTL_SAVE
0014CE 0012           03292                 return
                      03293 
                      03294 ;*==============================================================================*
                      03295 ;* Subroutine to restore ADDRESSH:ADDRESSL and COUNTH:COUNTL from save location
                      03296 ;*==============================================================================*
0014D0 C01B F006      03297 restore_params: movff   ADDRESSH_SAVE,ADDRESSH
0014D4 C01A F005      03298                 movff   ADDRESSL_SAVE,ADDRESSL
                      03299 
0014D8 C01D F019      03300                 movff   COUNTH_SAVE,COUNTH
0014DC C01C F018      03301                 movff   COUNTL_SAVE,COUNTL
0014E0 0012           03302                 return
                      03303 
                      03304 ;*==============================================================================*
                      03305 ; Abort: Error return for level-1 subroutines
                      03306 ;*==============================================================================*
0014E2 0006           03307 pop_cmderr:     pop                         ;chuck subroutine call's return address
0014E4 EF6D F006      03308                 goto        cmd_error
                      03309 
                      03310 ;*==============================================================================*
                      03311 ; Subroutine to set up for one of the test commands
                      03312 ; This subroutine may only be used one call deep
                      03313 ; On Entry:
                      03314 ;   W = max value+1 for the user input
                      03315 ; On Exit:
                      03316 ;   Port D is enabled and set to 0
                      03317 ;   Busy light is on
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 53
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03318 ;   abort if user input is too high
                      03319 ;   W = R4 = user input
                      03320 ;*==============================================================================*
                      03321 ;Valid user input?
0014E8 6606           03322 tcmd_setup:     tstfsz  ADDRESSH,0          ;no high byte allowed
0014EA D7FB           03323                 bra     pop_cmderr
                      03324 
0014EC 5C05           03325                 subwf   ADDRESSL,W,0        ;W=user input - limit
0014EE E2F9           03326                 bc      pop_cmderr          ;carry clear if limit>user input
                      03327 
                      03328 ;Light "busy" LED, since pins are probably not at 0V anymore
0014F0 6A83           03329                 clrf    PORTD,0             ;since we might clock out low address bits
0014F2 6A95           03330                 clrf    TRISD,0
0014F4 848D           03331                 bsf     LATE,ADRCLK,0
0014F6 6895           03332                 setf    TRISD,0
                      03333 
0014F8 5005           03334                 movf    ADDRESSL,W,0        ;Set up registers for return
0014FA 6E11           03335                 movwf   R4,0
0014FC 0012           03336                 return
                      03337 
                      03338 ;*==============================================================================*
                      03339 ; Subroutine to save the current EPROM type
                      03340 ; On Exit:
                      03341 ;   ETYPE_SAVE = current EPROM type
                      03342 ;   EEADR = ETYPE
                      03343 ;*==============================================================================*
0014FE 0E1C           03344 save_etype:     movlw   ETYPE                   ;get EPROM type
001500 EC19 F000      03345                 call    K_RDEEPROM
001504 6E1E           03346                 movwf   ETYPE_SAVE,0        
001506 0012           03347                 return
                      03348 
                      03349 ;*==============================================================================*
                      03350 ; Subroutine to restore the current EPROM type
                      03351 ; On Entry:
                      03352 ;   ETYPE_SAVE = desired EPROM type
                      03353 ;*==============================================================================*
001508 0E1C           03354 restore_etype:  movlw   ETYPE                   ;restore EPROM type
00150A 6EA9           03355                 movwf   EEADR,0     
00150C 501E           03356                 movf    ETYPE_SAVE,W,0
00150E EF1A F000      03357                 goto    K_WREEPROM              ;..and return to main
                      03358 
                      03359 ;*==============================================================================*
                      03360 ; Subroutine to report an EPROM/Buffer mismatch
                      03361 ; Prints address, buffer data, EPROM data, unless B_STATE (blank check cmd),
                      03362 ; in which case, doesn't print the buffer data.
                      03363 ; Check to see if the user typed ^C to abort, and aborts if so
                      03364 ; On Entry:
                      03365 ;   ADDRESSH:ADDRESSL = address
                      03366 ;   R2 = buffer data
                      03367 ;   R3 = EPROM data
                      03368 ;   B_STATE set if this is a blank-check, and buffer data shouldn't be reported
                      03369 ; On Exit:
                      03370 ;   W, R0, R1, BSR, FSR0 trashed
                      03371 ;   ERR_FLAG set
                      03372 ;*==============================================================================*
001512 800C           03373 rep_mismatch:   bsf     KERN_FLAGS,ERR_FLAG,0       ;remember that we had an error
                      03374 
001514 DF7F           03375                 rcall   check_pause                 ;allow user to abort or pause
                      03376 
001516 EE03 F012      03377                 lfsr    0,mismatcha_msg-sstrings    ;'Error at address '
00151A DF74           03378                 rcall   cr_printf                   ; Trashes R0
                      03379 
00151C DF5E           03380                 rcall   print_addr                  ;4-digit address, followed by ': '
                      03381                                                     ; Trashes R0,R1
                      03382 
00151E B420           03383                 btfsc   FLAGS1,B_STATE,0            ;Skip buffer data if EB blank check cmd
001520 D006           03384                 bra     rep_mm_skipb
                      03385 
001522 EE03 F026      03386                 lfsr    0,mismatchb_msg-sstrings    ;Buffer:
001526 DF64           03387                 rcall   printf
001528 500F           03388                 movf    R2,W,0                      ;buffer data
00152A EC0A F000      03389                 call    K_PRINTHEX2
                      03390 
00152E EE03 F034      03391 rep_mm_skipb:   lfsr    0,mismatche_msg-sstrings    ;EPROM:
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 54
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001532 DF5E           03392                 rcall   printf
001534 5010           03393                 movf    R3,W,0                      ;EPROM data
001536 EC0A F000      03394                 call    K_PRINTHEX2
                      03395 
                      03396 ;Fall into wait_txempty to flush transmit queue
                      03397 
                      03398 ;*==============================================================================*
                      03399 ; Subroutine to wait until the Tx Queue is empty
                      03400 ; The queue is empty when the transmit interrupt is shut off
                      03401 ; and not XOFF'd
                      03402 ; Trashes BSR
                      03403 ; (1.25 uS if transmitter is idle)
                      03404 ;*==============================================================================*
00153A B00B           03405 wait_txempty:   btfsc   INT_FLAGS,XOFF_STATE,0  ;(.5)XOFF'd?
00153C D7FE           03406                 bra     wait_txempty
                      03407     
00153E A89D           03408                 btfss   PIE1,TXIE,0             ;(.25)is transmitter enabled?
001540 0012           03409                 return                          ;(.5)
001542 D7FB           03410                 bra     wait_txempty
                      03411 
                      03412 ;*==============================================================================*
                      03413 ; Subroutine to report the selected EPROM type
                      03414 ; On Entry:
                      03415 ;   ETYPE = EPROM type
                      03416 ; On Entry at rep_etype2:
                      03417 ;   FSR0 = initial message string
                      03418 ; Trashes R0,R1,R2,FSR0
                      03419 ;*==============================================================================*
001544 EE03 F04E      03420 rep_etype:  lfsr    0,etype_msg-sstrings        ;'Current EPROM: '
                      03421 
001548 DF5D           03422 rep_etype2: rcall   cr_printf
                      03423 
00154A 0E1C           03424             movlw   ETYPE                       ;EEPROM address of variable
00154C EC19 F000      03425             call    K_RDEEPROM                  ;W=EPROM type
001550 EC0A F000      03426             call    K_PRINTHEX2                 ;print EPROM type
                      03427 
001554 EE03 F03C      03428             lfsr    0,colonspace_msg-sstrings   ;': '
001558 DF4B           03429             rcall   printf
                      03430 
00155A 6A0F           03431             clrf    R2,0                        ;no blanks padded on the end
00155C 0E00           03432             movlw   ET_NAME                     ;lookup the EPROM name
                      03433 
                      03434 ;Fall into eds_print
                      03435 
                      03436 ;*==============================================================================*
                      03437 ; Subroutine to print a message from the EPROM data structure
                      03438 ; If ETYPE specifies an inbuilt EPROM, then et_getval will retrieve a pointer
                      03439 ; to the string, in the format expected by p_estring. If the specified EPROM
                      03440 ; is a custom EPROM (with its parameters stored in the PIC's onboard EEPROM),
                      03441 ; then etype_getval will retrieve the first character of the string itself,
                      03442 ; and EEADR will be pointing to the string in EEPROM.
                      03443 ; On Entry:
                      03444 ;   W = the data structure item (string pointer)
                      03445 ;   R2 = formatted field width
                      03446 ;   ETYPE = the current EPROM type
                      03447 ; Trashes R0,R1,R2
                      03448 ;*==============================================================================*
00155E D9B1           03449 eds_print:  rcall   etype_getval            ;returns w=string index
                      03450 
001560 BE21           03451             btfsc   FLAGS2,CUST_EPROM,0     ;custom EPROM (so the record is in EEPROM)?
001562 EF08 F000      03452             goto    K_EEPRINT               ;print string from EEPROM, return from there
                      03453 
                      03454 ;Fall into p_estring
                      03455 
                      03456 ;*==============================================================================*
                      03457 ; Subroutine to print an EPROM string from the 2K "estrings" region, with
                      03458 ; formatting (really just a fixed length). Strings for this subroutine are
                      03459 ; null-terminated (with the null being on an even byte), followed by a byte
                      03460 ; that specifies the string's byte count. (Nulls on odd bytes are ignored.)
                      03461 ; If W=0xFF on entry, then don't print anything. This routines check to see of
                      03462 ; the pointer's bits<2:1> got truncated by the /8 by looking the see if the
                      03463 ; character 2 bytese before the beginning of the string is a null - the
                      03464 ; termination of the previous string. If not, it searches forward 2 bytes at a
                      03465 ; time to find the end of the previous string, and then bumps 2 to point to
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 55
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03466 ; the desired string.
                      03467 ; On Entry:
                      03468 ;   W=(string address-estrings)/8
                      03469 ;   R2 = format length, 0 means no formatting
                      03470 ; Trashes W,R0,R2
                      03471 ;*==============================================================================*
001566 6E0D           03472 p_estring:  movwf   R0,0
001568 280D           03473             incf    R0,W,0              ;FF means nothing to print
00156A E01A           03474             bz      pes_exit            ;nothing to print?
                      03475 
                      03476 ;look at  the character that is 2 bytes before the alleged beginning of this string.
                      03477 ;This should be the null-termination of the previous string. If not, hunt for it.
                      03478 ;(The divide-by-8 may have truncated the lower 3 address bits of the string address.)
                      03479 ;Note that this depends on the fact that no string (including its termination and
                      03480 ;byte count) is less than 8 bytes long. 
00156C 0E08           03481             movlw   0x08                ;R0 is string index/8
00156E 020D           03482             mulwf   R0,0
001570 0E66           03483             movlw   low(estrings-2)
001572 26F3           03484             addwf   PRODL,F,0
001574 0E36           03485             movlw   high(estrings-2)
001576 20F4           03486             addwfc  PRODH,W,0           ;W:PRODL = address offset to string index
001578 6EF7           03487             movwf   TBLPTRH,0
00157A CFF3 FFF6      03488             movff   PRODL,TBLPTRL       ;TBLPTRH:TBLPTRL points to 2 before the string
                      03489 
00157E 0009           03490 pal_loop:       tblrd*+                 ;is this the end of the previous string?
001580 50F5           03491                 movf    TABLAT,W,0      ;particularly, its null-terminator
001582 0009           03492                 tblrd*+                 ;skip every other byte, since the null terminator
                      03493                                         ;..must be on an even byte
001584 E1FC           03494                 bnz     pal_loop        ;n: keep looking
                      03495 
                      03496 ;Now that we know where it starts (at TBLPTRH:TBLPTRL), print the string
001586 EC07 F000      03497             call    K_PRINTF            ;ADDRESSH:ADDRESSL=string address
                      03498                                         ;returns with TABLBTRH:TBLPTRL pointing just past the null
                      03499 
                      03500 ;Pad the string out R2 characters wide
00158A 0009           03501             tblrd*+                     ;read the character count into TABLAT               
00158C 50F5           03502             movf    TABLAT,W,0          ;chr past the string end is the string length
00158E 5C0F           03503             subwf   R2,W,0              ;carry will be set if string length<=format length
001590 E307           03504             bnc     pes_exit            ;no formatting or string is too long?
001592 E006           03505             bz      pes_exit            ;exact fit?
                      03506 
001594 6E0F           03507             movwf   R2,0
                      03508 
                      03509 ;Print R2 blanks to fill out the format
001596                03510 pes_blanks:
001596 0E20           03511                 movlw   ' '
001598 EC06 F000      03512                 call    K_CONOUT
00159C 060F           03513                 decf    R2,F,0
00159E E1FB           03514                 bnz     pes_blanks
                      03515 
0015A0 0012           03516 pes_exit:   return
                      03517 
                      03518 ;*==============================================================================*
                      03519 ; Subroutine to report the current Vpp voltage
                      03520 ; On Entry:
                      03521 ;   ETYPE = EPROM type
                      03522 ; Trashes R0,FSR0
                      03523 ;*==============================================================================*
0015A2 50BE           03524 rep_vpp:    movf    CCPR1L,W,0                  ;is switcher off?
0015A4 E013           03525             bz      rep_so
                      03526 
0015A6 EE03 F0A6      03527             lfsr    0,setvpp_msg-sstrings       ;"Vpp is set for "
0015AA DF2C           03528             rcall   cr_printf
                      03529 
                      03530 ;Get current Vpp comparator input
                      03531 
0015AC 507B           03532             movf    CM1CON0,W,0                 ;get comparator's selected input
0015AE 0B03           03533             andlw   (1<<C1CH0)+(1<<C1CH1)       ;just the comparator input bits (page 267)
                      03534 
                      03535 ;Compute selected comparator voltage (assuming 0.8V diode drop):
                      03536 ;        Pin 18                  Pins 19-21
                      03537 ; C1CH1  C1CH0  Voltage    C1CH1  C1CH0  Voltage
                      03538 ;   0      0     25.9V      0      0     25.1V
                      03539 ;   0      1     21.8V      0      1     21.0V
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 56
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03540 ;   1      0     13.55V     1      0     12.75V
                      03541 ;   1      1     13.95V     1      1     13.15V
                      03542 
0015B0 6E0F           03543             movwf   R2,0
0015B2 2A0F           03544             incf    R2,F,0                      ;account for 1st dec
                      03545 
0015B4 EE07 F0EC      03546             lfsr    0,v1315_msg-sstrings
                      03547 
0015B8 4E0F           03548             dcfsnz  R2,F,0
0015BA EE07 F0FA      03549             lfsr    0,v2510_msg-sstrings
                      03550 
0015BE 4E0F           03551             dcfsnz  R2,F,0
0015C0 EE07 F0F4      03552             lfsr    0,v21_msg-sstrings
                      03553 
0015C4 4E0F           03554             dcfsnz  R2,F,0
0015C6 EE07 F0E4      03555             lfsr    0,v1270_msg-sstrings
                      03556 
0015CA D712           03557             bra     printf                      ;print Vpp voltage, return from there
                      03558 
                      03559 ;Report that the switcher is off
0015CC EE04 F0BA      03560 rep_so:     lfsr    0,swoff_msg-sstrings        ;"Switcher is off"
0015D0 D719           03561             bra     cr_printf
                      03562 
                      03563 ;*==============================================================================*
                      03564 ; Subroutine to set up for the current EPROM type
                      03565 ; On Entry:
                      03566 ;   ETYPE = current EPROM type
                      03567 ; On Exit:
                      03568 ;   Vpp power supply is set to the correct voltage
                      03569 ;   The following variables are set up for the current EPROM type:
                      03570 ;     FLAGS2 
                      03571 ;     SHARED
                      03572 ;     SMART1
                      03573 ;     SMART2
                      03574 ;     PROGREPS
                      03575 ;     PPULSEH:PPULSEL (invalid if FLAGS2.FAST_PULSE is set)
                      03576 ;     PPDELH:PPDELL (invalid if FLAGS2.FAST_PULSE is set)
                      03577 ;     VSENSE_LOW
                      03578 ;     VSENSE_HIGH
                      03579 ; Trashes R0,R1,R2,R3,PRODH:PRODL
                      03580 ;*==============================================================================*
0015D2 0E8F           03581 etype_setup:    movlw   0x8F                ;remove old adjustment bits
0015D4 1621           03582                 andwf   FLAGS2,F,0
                      03583 
0015D6 EC08 F011      03584                 call    special_v           ;any special Vpp requirements?
                      03585                                             ;returns R3 = ET_SPECIAL value
                      03586 
0015DA 3810           03587                 swapf   R3,W,0              ;put adjustment bits in W<6:4>
0015DC 0B70           03588                 andlw   0x70                ;chuck the rest
0015DE 1221           03589                 iorwf   FLAGS2,F,0          ;and install them in FLAGS2
                      03590 
                      03591 ;Get & save the smart mode
0015E0 0E20           03592                 movlw   ET_SMART1           ;Get phase 1 smart mode
0015E2 D96F           03593                 rcall   etype_getval
0015E4 6E28           03594                 movwf   SMART1,0
                      03595 
0015E6 0E21           03596                 movlw   ET_SMART2           ;Get phase 2 smart mode
0015E8 D96C           03597                 rcall   etype_getval
0015EA 6E29           03598                 movwf   SMART2,0
                      03599 
                      03600 ;Get & save whether or not the -OE pin is also the Vpp pin
0015EC 901F           03601                 bcf     SHARED,OEVPP        ;assume not for now
                      03602 
0015EE 0E19           03603                 movlw   ET_OECS             ;Get -OE pin
0015F0 D968           03604                 rcall   etype_getval
0015F2 380D           03605                 swapf   R0,W,0              ;put -OE pin in 2:0
0015F4 6E0F           03606                 movwf   R2,0                ;temp save OE and CS pins
                      03607 
0015F6 0E1A           03608                 movlw   ET_PGMVPP
0015F8 D964           03609                 rcall   etype_getval        ;get Vpp pin
0015FA 6E10           03610                 movwf   R3,0                ;temp save Vpp and PGM pins
                      03611 
0015FC 180F           03612                 xorwf   R2,W,0              ;compare to -OE pin
0015FE 0B07           03613                 andlw   0x07                ;chuck other bits
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 57
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03614 
001600 B4D8           03615                 btfsc   STATUS,Z,0          ;is -OE also Vpp?
001602 801F           03616                 bsf     SHARED,OEVPP        ;y: remember
                      03617 
                      03618 ;Get & save whether or not the CS pin is also the Vpp pin
001604 921F           03619                 bcf     SHARED,CSVPP        ;assume not for now
                      03620 
001606 380F           03621                 swapf   R2,W,0              ;put CS pin in 2:0
001608 1810           03622                 xorwf   R3,W,0              ;compare to Vpp pin
00160A 0B07           03623                 andlw   0x07                ;chuck other bits
                      03624 
00160C B4D8           03625                 btfsc   STATUS,Z,0          ;is -OE also Vpp?
00160E 821F           03626                 bsf     SHARED,CSVPP        ;y: remember
                      03627 
                      03628 ;Get & save whether or not the -OE pin is also the PGM pin
001610 941F           03629                 bcf     SHARED,OEPGM        ;assume not for now
                      03630 
001612 3810           03631                 swapf   R3,W,0              ;PGM bits to 2:0
001614 180F           03632                 xorwf   R2,W,0              ;compare to -OE pin
001616 0B07           03633                 andlw   0x07                ;chuck other bits
                      03634 
001618 B4D8           03635                 btfsc   STATUS,Z,0          ;is -OE also PGM?
00161A 841F           03636                 bsf     SHARED,OEPGM        ;y: remember
                      03637 
                      03638 ;Get and save wheter or not the CS pin is also the PGM pin
00161C 961F           03639                 bcf     SHARED,CSPGM
                      03640 
00161E 3A0F           03641                 swapf   R2,F,0              ;put CS pin in 2:0
001620 3810           03642                 swapf   R3,W,0              ;PGM bits to 2:0
001622 180F           03643                 xorwf   R2,W,0              ;compare to CS pin
001624 0B07           03644                 andlw   0x07                ;chuck other bits
                      03645 
001626 B4D8           03646                 btfsc   STATUS,Z,0          ;is CS also PGM?
001628 861F           03647                 bsf     SHARED,CSPGM        ;y: remember
                      03648 
                      03649 ;Get & save the repetition count, or the limit for smart programming
00162A 0E1D           03650                 movlw   ET_PROGREPS         ;Get encoded programming pulse spec
00162C D94A           03651                 rcall   etype_getval
00162E 6E27           03652                 movwf   PROGREPS,0
                      03653 
                      03654 ;Get, compute, and remember the 16-bit programming pulse width spec for this EPROM
001630 8621           03655                 bsf     FLAGS2,FAST_PULSE,0 ;assume fast pulse for a moment
                      03656 
001632 0E1E           03657                 movlw   ET_PROGPULSE        ;Get encoded programming pulse spec
001634 D946           03658                 rcall   etype_getval        ;result into W and R0
                      03659 
001636 0B7F           03660                 andlw   0x7F                ;0 means fast pulse (msb is just a multiplier)
001638 E007           03661                 bz      es_fastpp           ;FAST_PULSE is already set
                      03662 
00163A 9621           03663                 bcf     FLAGS2,FAST_PULSE,0 ;this is not a fast pulse
00163C 500D           03664                 movf    R0,W                ;recover whole value
                      03665 
                      03666 ;Convert ET_PROGPULSE to 10 uS units in PPULSEH:PPULSEL.
00163E D846           03667                 rcall   decode_pulse
001640 CFF4 F024      03668                 movff   PRODH,PPULSEH       ;remember program pulse width
001644 CFF3 F023      03669                 movff   PRODL,PPULSEL
001648                03670 es_fastpp:
                      03671 
                      03672 ;Convert ET_PPDELAY to 10 uS units in PPDELH:PPDELL.
001648 0E1F           03673                 movlw   ET_PPDELAY          ;Get encoded programming pulse spec
00164A D93B           03674                 rcall   etype_getval
                      03675 
00164C D83F           03676                 rcall   decode_pulse
00164E CFF4 F026      03677                 movff   PRODH,PPDELH        ;remember program pulse delay
001652 CFF3 F025      03678                 movff   PRODL,PPDELL
                      03679 
                      03680 ;Figure out which sort of programming pulse and remember in FLAGS2
                      03681 ;Look up this EPROM's Vpp specification. Bits 2:0 are defined as follows:
                      03682 ; Bit    FLAGS2 Bit     Function
                      03683 ;  2        RDVPP     Vpp setting during read: 0 means 0V, 1 means +5V
                      03684 ;  1        PMODE1    0 = Pulsed Vpp, 1 = pulsed PGM
                      03685 ;  0        PMODE0    0 = Vpp returns to 0V, 1 = Vpp returns to +5V (only if PMODE1=0)
                      03686 
001656 0EF8           03687                 movlw   (0x07 ^ 0xFF)       ;strip off old bits
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 58
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001658 1621           03688                 andwf   FLAGS2,F,0
                      03689 
00165A 0E1C           03690                 movlw   ET_VPPSETUP         ;Get Vpp voltage and programming mode bits
00165C D932           03691                 rcall   etype_getval        ;fesult in W and R0
00165E 0B07           03692                 andlw   0x07                ;get the pulse type and Vpp read state spec
001660 1221           03693                 iorwf   FLAGS2,F,0          ;and install them in FLAGS2
                      03694 
                      03695 ;Get the programming voltage, and look up which pin to use for foldback current limiting,
                      03696 ;also the upper and lower current limits
001662 6A2B           03697                 clrf    VSENSE_LOW,0        ;assume no limit for now
001664 682C           03698                 setf    VSENSE_HIGH,0
                      03699 
001666 3A0D           03700                 swapf   R0,F,0              ;look at ET_VPPSETUP
001668 0E07           03701                 movlw   0x07
00166A 160D           03702                 andwf   R0,F,0              ;no Vpp?
00166C E016           03703                 bz      es_nolimit          ;..then no limits
                      03704 
00166E 060D           03705                 decf    R0,F,0              ;make Vpp voltages 0-4
001670 B40D           03706                 btfsc   R0,0x02,0           ;R0=4, meaning external supply?
001672 D013           03707                 bra     es_nolimit          ;external supply: no limits
                      03708 
001674 0E03           03709                 movlw   0x03                ;Get just the power supply section, 0-3
001676 160D           03710                 andwf   R0,F,0              ;also tests for 0, meaning 12.75V supply
001678 0E25           03711                 movlw   0x25                ;select AN9, start conversion (page 255)
00167A B4D8           03712                 btfsc   STATUS,Z,0          ;except for 12.75V Vpp
00167C 0E29           03713                 movlw   0x29                ;which uses AN10
00167E 6EC2           03714                 movwf   ADCON0,0            ;The ADC is now set up
                      03715 
001680 0E22           03716                 movlw   high(LIMTABLE)      ;table lookup voltage limits
001682 6EF7           03717                 movwf   TBLPTRH,0
001684 440D           03718                 rlncf   R0,W,0
001686 0F86           03719                 addlw   low(LIMTABLE)
001688 6EF6           03720                 movwf   TBLPTRL,0
00168A B0D8           03721                 btfsc   STATUS,C,0
00168C 2AF7           03722                 incf    TBLPTRH,F,0
                      03723 
00168E 0009           03724                 tblrd*+
001690 CFF5 F02B      03725                 movff   TABLAT,VSENSE_LOW   ;get low limit, remember
001694 0009           03726                 tblrd*+
001696 CFF5 F02C      03727                 movff   TABLAT,VSENSE_HIGH  ;get high limit, remember
                      03728 
                      03729 ;Make sure the switcher is turned off. (Its output will then be about 11.3V - the input
                      03730 ;voltage minus the drop across the current limiter.)
                      03731 
00169A 0E00           03732 es_nolimit:     movlw   0x00
00169C D004           03733                 bra     set_vpp
                      03734 
                      03735 ;*==============================================================================*
                      03736 ; Subroutine to set up the Vpp supply voltage for this EPROM type
                      03737 ; Trashes W,R0,R1
                      03738 ;*==============================================================================*
00169E 0E1C           03739 eset_vpp:       movlw   ET_VPPSETUP         ;Get Vpp voltage and programming mode bits
0016A0 D910           03740                 rcall   etype_getval        ;result in W and R0
0016A2 380D           03741                 swapf   R0,W,0              ;get the Vpp voltage spec into W<2:0>
0016A4 0B07           03742                 andlw   0x07                ;chuck all other bits
                      03743 
                      03744 ;Fall into set_vpp
                      03745 
                      03746 ;*==============================================================================*
                      03747 ; Subroutine to set the Vpp switching power supply voltage
                      03748 ; On Entry:
                      03749 ;   W = desired voltage:
                      03750 ;      0 = 12V (input voltage) (sets pulse width to 0, without changing
                      03751 ;              the comparator input)
                      03752 ;      1 = 12.75V, use CI2IN2
                      03753 ;      2 = 13.15V, use CI2IN3
                      03754 ;      3 = 21.0V,  use CI2IN1
                      03755 ;      4 = 25.1V,  use CI2IN0 (also for 26V)
                      03756 ;      5 = external supply (so shut switcher off)
                      03757 ; Trashes W,R0
                      03758 ;*==============================================================================*
0016A6 6E0D           03759 set_vpp:    movwf   R0,0                ;temp save input parameter
                      03760 
0016A8 6ABE           03761             clrf    CCPR1L,0            ;set pulse width to 0 while we work
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 59
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03762 
0016AA 520D           03763             movf    R0,F,0              ;test for 0
0016AC B4D8           03764             btfsc   STATUS,Z,0          ;off?
0016AE 0012           03765             return                      ;y: done with pulse width = 0
                      03766 
0016B0 0A05           03767             xorlw   0x05                ;external supply?
0016B2 B4D8           03768             btfsc   STATUS,Z,0
0016B4 0012           03769             return                      ;y: done with pulse width = 0
                      03770             
                      03771 ;Create comparator input bits from R0
                      03772 ;  R0     C1CH1  C1CH0
                      03773 ; 0x01      1      0
                      03774 ; 0x02      1      1
                      03775 ; 0x03      0      1
                      03776 ; 0x04      0      0
                      03777 
0016B6 0E05           03778             movlw   0x05
0016B8 2A0D           03779             incf    R0,F,0              ;R0 is between 0x02 and 0x05
0016BA B40D           03780             btfsc   R0,0x02,0           ;already okay for 0x02 and 0x03
0016BC 1A0D           03781             xorwf   R0,F,0              ;clear bit 2, invert bit 0
                      03782 
                      03783 ;Set Vpp according to R0. (See page 267)
0016BE 507B           03784             movf    CM1CON0,W,0         ;get all the other bits in this register
0016C0 0BFC           03785             andlw   ((1<<C1CH0)+(1<<C1CH1)) ^ 0xFF  ;strip comparator input (page 267)
                      03786 
0016C2 100D           03787             iorwf   R0,W,0              ;put comparator bits in place
0016C4 6E7B           03788             movwf   CM1CON0,0           ;actually select the input now
                      03789 
                      03790 ;Set the PWM pulse width to actually turn on the Vpp switcher
0016C6 0E12           03791             movlw   VPP_PW
0016C8 6EBE           03792             movwf   CCPR1L,0
                      03793 
0016CA 0012           03794             return
                      03795 
                      03796 ;*==============================================================================*
                      03797 ; Subroutine to convert encoded time value to 10 uS units.
                      03798 ;  If msb in ET_PROGPULSE is set then the value is in 1 mS units, and must be
                      03799 ;  multiplied by 100. Also knock 30 uS off the result, to account for programming
                      03800 ;  loop overhead.
                      03801 ; On Entry:
                      03802 ;   W = value to decode
                      03803 ;      00h or 80h means it's a minimum amount of time
                      03804 ;      01h means special value
                      03805 ;      02h and 03h at this point not allowed (may be used for special values)
                      03806 ;      Otherwise: decode as above
                      03807 ; On Exit:
                      03808 ;   PRODH:PRODL = decoded value
                      03809 ;*==============================================================================*
0016CC 6EF3           03810 decode_pulse:   movwf   PRODL,0
0016CE 6AF4           03811                 clrf    PRODH,0             ;high byte
                      03812 
0016D0 0804           03813                 sublw   0x04                ;special value below 3?
0016D2 E20C           03814                 bc      dp_done             ;carry set if below 4
                      03815 
0016D4 50F3           03816                 movf    PRODL,W,0               
0016D6 9EF3           03817                 bcf     PRODL,0x07,0        ;clear the high bit, in case it's set
0016D8 52F3           03818                 movf    PRODL,F,0           ;80h is the same as 0
0016DA E008           03819                 bz      dp_done
                      03820 
0016DC 0B80           03821                 andlw   0x80                ;test bit 7 from input
0016DE 0E64           03822                 movlw   .100
0016E0 A4D8           03823                 btfss   STATUS,Z,0          ;time in 10 uS or 1 mS units?
0016E2 02F3           03824                 mulwf   PRODL,0             ;adjust to 10 uS if 1 mS
                      03825 
0016E4 0E04           03826                 movlw   0x04                ;(.25)adjust for 30 uS timer overhead
                      03827                                             ;and that stall_r1r0 goes one extra time
0016E6 5EF3           03828                 subwf   PRODL,F,0           ;(.25)
0016E8 A0D8           03829                 btfss   STATUS,C,0          ;(.5)borrow?
0016EA 06F4           03830                 decf    PRODH,F,0           ;PRODH:PRODL = program pulse time in 10 uS units
                      03831 
0016EC 0012           03832 dp_done:        return
                      03833 
                      03834 ;*==============================================================================*
                      03835 ;Subroutine to control Vcc for this type of EPROM.
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 60
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03836 ; Vdd is always on pin 24
                      03837 ; On Entry:
                      03838 ;   W = 0 to turn power off
                      03839 ;     = 1 to turn Vcc on for reading (always +5V)
                      03840 ;     = 2 to turn Vcc on for programming (according to EPROM type)
                      03841 ;   ETYPE has the current EPROM type
                      03842 ; On Exit:
                      03843 ;   R1 = 0 off, 1 for 5V, 2 for 6.2V. 3 for 12V
                      03844 ; Trashes W,R0,R3
                      03845 ;*==============================================================================*
0016EE 6E10           03846 vcc2pin:        movwf   R3,0                ;save input
                      03847 
0016F0 0E15           03848                 movlw   (1<<P24_5Vn)+(1<<P24_6Vn)+(1<<P24_12Vn) ;(active-low bits)
0016F2 128A           03849                 iorwf   LATB,F,0            ;turn off all Vcc sources
                      03850 
0016F4 B210           03851                 btfsc   R3,0x01,0           ;R3=2, meaning on for programming?
0016F6 D004           03852                 bra     vcc2p_onprog
                      03853 
0016F8 A010           03854                 btfss   R3,0x00,0           ;R3=0, meaning off?
0016FA 0012           03855                 return                      ;y: done            
                      03856 
0016FC 908A           03857 vcc2p_5V:       bcf     LATB,P24_5Vn        ;n:Turn Vcc on for reading
0016FE 0012           03858                 return              
                      03859 
                      03860 ;Set Vcc for programming according to the EPROM type
001700 0E1B           03861 vcc2p_onprog:   movlw   ET_VBBVDD           ;VBB & VDD voltage specs, Vcc programming voltage spec
001702 D8DF           03862                 rcall   etype_getval        ;returns programming Vcc specification in W bits <3:0>
001704 0B07           03863                 andlw   0x07                ;W=0: 0V
                      03864                                             ;W=1: +5V
                      03865                                             ;W=2: +6.2V
                      03866                                             ;W=3: +12V
                      03867 
001706 E007           03868                 bz      vcc2p_off           ;0v? it's already off
                      03869 
001708 0FFF           03870                 addlw   0xFF                ;decrement
00170A E0F8           03871                 bz      vcc2p_5V            ;make it 5V
                      03872 
00170C 0FFF           03873                 addlw   0xFF                ;decrement
00170E E102           03874                 bnz     vcc2p_not6
                      03875 
001710 988A           03876                 bcf     LATB,P24_6Vn        ;+6.2V setting
001712 0012           03877                 return
                      03878 
001714 948A           03879 vcc2p_not6:     bcf     LATB,P24_12Vn       ;+12V setting
001716 0012           03880 vcc2p_off:      return
                      03881 
                      03882 ;*==============================================================================*
                      03883 ; Subroutine to turn on/off Vbb and Vdd at the correct voltages for this type
                      03884 ; of EPROM.
                      03885 ; Vbb is always -5V on pin 21, if it exists
                      03886 ; Vdd is always +12V on pin 19, if it exists
                      03887 ; On Entry:
                      03888 ;   W = 0 to turn power off, R3 is not zero to turn power on.
                      03889 ;   ETYPE has the current EPROM type
                      03890 ; On Exit:
                      03891 ;   R1 = {0-NZ} for none, -5/+12
                      03892 ;   Vbb and Vdd for this type of EPROM are off or on as specified
                      03893 ; Trashes R0,R1,R3,EEADR,TBLPTR
                      03894 ;*==============================================================================*
001718 6E10           03895 vbbvdd2pins:    movwf   R3,0                ;save input
                      03896 
00171A 0E1B           03897                 movlw   ET_VBBVDD           ;VBB & VDD voltage specs, Vcc voltage spec
00171C D8D2           03898                 rcall   etype_getval        ;returns Vbb & Vdd specification in W bits <5:4>
                      03899 
00171E 0B30           03900                 andlw   0x30                ;just get & test bits 5 & 4
001720 6E0E           03901                 movwf   R1,0                ;R1=ET_VBBVDD value for thie EPROM
                      03902 
                      03903 ;Turn Vdd on or off as requested, if it exists
001722 0ECF           03904                 movlw   ((1<<P19_0)+(1<<P19_1)) ^ 0xFF
001724 1489           03905                 andwf   LATA,W,0            ;strip off pin 19 assignment
                      03906 
001726 6610           03907                 tstfsz  R3,0                ;on or off?
001728 0920           03908                 iorlw   (1<<P19_1)          ;select +12V on for pin 19
                      03909 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 61
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00172A BA0E           03910                 btfsc   R1,0x05,0           ;Is there a Vdd pin?
00172C 6E89           03911                 movwf   LATA,0              ;y: update pin 19
                      03912 
                      03913 ;Turn Vbb on or off as requested, if it exists
00172E 0EFC           03914                 movlw   ((1<<P21_0)+(1<<P21_1)) ^ 0xFF
001730 148D           03915                 andwf   LATE,W,0            ;strip off pin 21 assignment
                      03916 
001732 6610           03917                 tstfsz  R3,0                ;on or off?
001734 0902           03918                 iorlw   (1<<P21_1)          ;select -5V on
                      03919 
001736 B80E           03920                 btfsc   R1,0x04,0           ;Is there a Vb pin?
001738 6E8D           03921                 movwf   LATE,0              ;y: update pin 21 now
                      03922 
00173A 0012           03923                 return
                      03924 
                      03925 ;*==============================================================================*
                      03926 ; Subroutine to put the correct Vpp voltage to the correct EPROM pin
                      03927 ; On Entry:
                      03928 ;   W={0:3}={0V,reading state,inactive programming state,Vpp}
                      03929 ;   ETYPE is the current EPROM type
                      03930 ;   Vpp is already set to the correct voltage for this EPROM
                      03931 ;   EXT_VPP is set if this EPROM requires an external Vpp power supply
                      03932 ; On Exit:
                      03933 ;   R1 = pin number - 17, with 0 meaning none
                      03934 ; Trashes W,R2,EEADR,TBLPTR
                      03935 ; (16 uS from entry to pin off)
                      03936 ; (.5 uS from pin write through return)
                      03937 ;*==============================================================================*
                      03938 ;compute R2={0:3} for {0V,+5V,external,Vpp}
00173C 6E0F           03939 vpp2pin:    movwf   R2,0                    ;(.25)
00173E 520F           03940             movf    R2,F,0                  ;(.25) test for 0
001740 E00D           03941             bz      v2pins                  ;(.25)R2=0 means just make it 0V
                      03942 
001742 B20F           03943             btfsc   R2,0x01,0               ;(.25)one of the programming levels?
001744 D003           03944             bra     v2p_prog                ;(.5)y: do programming levels
                      03945 
                      03946 ;Prepare to put Vpp at its read state (R2 = 1 here)
001746 A421           03947             btfss   FLAGS2,RDVPP,0          ;is reading state high or low?
001748 6A0F           03948             clrf    R2,0                    ;if low, make R2 low
00174A D008           03949             bra     v2pins                  ;R2 = 0 for 0V, 1 for 5V
                      03950 
                      03951 ;We are programming. Should  Vpp become active or inactive?
00174C A00F           03952 v2p_prog:   btfss   R2,0x00,0               ;(.25)inactive programming state?
00174E D003           03953             bra     v2p_poff                ;(.5)y: turn it off
                      03954 
                      03955 ;Prepare to turn Vpp on, either for onboard Vpp or external Vpp. R2 = 3 here
001750 BC21           03956             btfsc   FLAGS2,EXT_VPP,0        ;external Vpp?
001752 060F           03957             decf    R2,F,0                  ;y: set up for external Vpp
001754 D003           03958             bra     v2pins                  ;R2 = 2 or 3, for external or onboard Vpp
                      03959 
                      03960 ;Prepare to put Vpp at its programming inactive state
001756 6A0F           03961 v2p_poff:   clrf    R2,0                    ;(.25)Set up for 0V or +5 depending on PMODE0
001758 B021           03962             btfsc   FLAGS2,PMODE0,0         ;(.5)
00175A 2A0F           03963             incf    R2,F,0
                      03964                                             ;R2 = 0 or 1, depending on PMODE0
                      03965 
                      03966 ;Figure out which pin is Vpp for this EPROM, and send the appropriate voltage there
                      03967 ;R2 = Vpp selection {0-3}={0V,5V,external Vpp,Vpp}
00175C 0E1A           03968 v2pins:     movlw   ET_PGMVPP                           ;(.25)specifies Vpp pin in bits <2:0>
00175E D8B1           03969             rcall   etype_getval                        ;(9.25 + .5)
001760 0B07           03970             andlw   0x07                                ;(.25)just look at Vpp bits
001762 6E0E           03971             movwf   R1,0                                ;(.25) 0x00: none
                      03972                                                         ;      0x01: pin 18
                      03973                                                         ;      0x02: pin 19 (not allowed)
                      03974                                                         ;      0x03: pin 20
                      03975                                                         ;      0x04: pin 21
                      03976 
001764 50F9           03977 v2ptab:     movf    PCL,W,0                             ;(.25)force a load of the PCLATH register (page 
                            62)
001766 440E           03978             rlncf   R1,W,0                              ;(.25)pin index (times 2 for jump table)
001768 26F9           03979             addwf   PCL,F,0                             ;(.25)
                      03980 
                      03981 
00176A 0012           03982             return                                      ;No Vpp pin (EEPROM)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 62
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00176C D019           03983             bra     vpp_pin18                           ;(.25)Vpp on pin 18
00176E 0012           03984             return                                      ;not allowed: Vpp on pin 19
001770 D005           03985             bra     vpp_pin20                           ;Vpp on pin 20
001772                03986 v2ptend:                                                ;Must be pin 21
                      03987 
001772 508D           03988 vpp_pin21:  movf    LATE,W,0                            ;(.25)get other bits
001774 0BFC           03989             andlw   ((1<<P21_0) + (1<<P21_1)) ^ 0FFh    ;(.25)strip old value
001776 100F           03990             iorwf   R2,W,0                              ;(.25)new control bits in place
001778 6E8D           03991             movwf   LATE,0                              ;(.25)
                      03992 
00177A 0012           03993             return                                      ;(.5)
                      03994 
                      03995 ;Vpp in on pin 20
00177C 5089           03996 vpp_pin20:  movf    LATA,W,0                            ;get other port bits
00177E 0B3F           03997             andlw   ((1<<P20_0) + (1<<P20_1)) ^ 0FFh    ;strip old value
                      03998 
001780 420F           03999             rrncf   R2,F,0                              ;put new bits in <7:6>
001782 420F           04000             rrncf   R2,F,0
                      04001 
001784 BE89           04002             btfsc   LATA,0x07,0                         ;Was it at a high voltage?
001786 D003           04003             bra     vpp20q                              ;y: use hardware to yank it down
                      04004 
001788 100F           04005             iorwf   R2,W,0                              ;new control bits in place
00178A 6E89           04006             movwf   LATA,0
                      04007 
00178C 0012           04008             return
                      04009 
                      04010 ;Pin 20 has a 0.047 uF cap on it, making discharge slow when changing from Vpp to +5V.
                      04011 ;If changing from either of the high voltages, uses the 7407 to yank it towards ground
                      04012 ;before setting it to 5V. The amount of time for this yank depends on Vpp.
00178E 6E89           04013 vpp20q:     movwf   LATA,0                          ;Yank it to 0 first
                      04014 
001790 0E03           04015             movlw   0x03                            ;(.25) (for 0.1 uF, use 0x06)
001792 A27B           04016             btfss   CM1CON0,C1CH1,0                 ;(.25)this bit 0 for 21V and 25V
001794 0E04           04017             movlw   0x04                            ;(.25) (for 0.1 uF, use 0x08)
                      04018 
001796 EC1F F000      04019             call    K_STALL1U                       ;delay as required
                      04020 
00179A 500F           04021             movf    R2,W,0                          ;(.25)new control bits in place
00179C 1289           04022             iorwf   LATA,F,0                        ;Vpp to +5V or ground
00179E 0012           04023             return
                      04024 
                      04025 ;Vpp is on pin 18
0017A0 5089           04026 vpp_pin18:  movf    LATA,W,0                            ;(.25)get other port bits
0017A2 0BF3           04027             andlw   ((1<<P18_0) + (1<<P18_1)) ^ 0FFh    ;(.25)strip old value
                      04028 
0017A4 460F           04029             rlncf   R2,F,0                              ;(.25)put new bits in <2:3>
0017A6 460F           04030             rlncf   R2,F,0                              ;(.25)
                      04031 
0017A8 100F           04032             iorwf   R2,W,0                              ;(.25)new control bits in place
0017AA 6E89           04033             movwf   LATA,0                              ;(.25)
                      04034 
0017AC 0012           04035             return                                      ;(.5)
                      04036 
                      04037 ;*************************************************************
                      04038 ; The above jump table must not span a 256-byte page boundary.
                      04039 ;*************************************************************
                      04040     if high(v2ptab)^ high(v2ptend)
                      04041     error "Martin sez: vpp2pin jump table spans a page boundary"
                      04042     endif
                      04043 
                      04044 ;*==============================================================================*
                      04045 ; Subroutine to send -OE signal to its correct pin
                      04046 ; On Entry:
                      04047 ;   W = 0 for -OE = inactive (5V)
                      04048 ;     = 1 for -OE = active(0V)
                      04049 ;     = 2 for -OE = programming-state
                      04050 ;   Note that -OE programming-state is +5V for most EPROMS, but +12V for some.
                      04051 ;   Hardware supports +12V OE signal only on pins 19 and 20. This is not
                      04052 ;   checked here.
                      04053 ;   Also, -OE may be the same pin as Vpp. In this case, set the pin to Vpp
                      04054 ;   if W=2.
                      04055 ;   ETYPE is the current EPROM type
                      04056 ; On Exit:
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 63
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      04057 ;   R1 = pin number - 17, with 0 meaning none
                      04058 ; Trashes W,R0,R3,EEADR,TBLPTR
                      04059 ; (14 uS)
                      04060 ; (1 us from pin-write through return, except if setting to +12V or Vpp)
                      04061 ;*==============================================================================*
0017AE 6E10           04062 oen2pin:    movwf   R3,0                            ;(.25)input in place for set_epin
                      04063 
0017B0 7010           04064             btg     R3,0x00,0                       ;(.25)-OE is an active-low pin
                      04065                                                     ;..so toggle the lsb of the input
                      04066 
0017B2 0E19           04067             movlw   ET_OECS                         ;(.25)get -OE and CS pin specifications
0017B4 D886           04068             rcall   etype_getval                    ;(9.25+.5)returns -OE pin specification in R0<6:4>
0017B6 380D           04069             swapf   R0,W,0                          ;(.25)put the -OE pin number in W<2:0>
                      04070 
0017B8 A210           04071             btfss   R3,0x01,0                       ;(.25)R3<1> set if this is programming state
0017BA D024           04072             bra     set_epin                        ;(3.5+.5)just set a normal (digital) -OE pin
                      04073 
                      04074 ;Set -OE to its programming level. There are 4 possibilities, depending on the EPROM:
                      04075 ; 1) -OE is also non-pulsed Vpp, and so gets set to the active Vpp voltage
                      04076 ; 2) -OE is also pulse Vpp, and so gets set to the inactive Vpp voltage
                      04077 ; 3) -OE is just a normal pin, and so gets set high (inactive)
                      04078 ; 4) -OE gets set to +12V
0017BC 0B07           04079             andlw   0x07                            ;strip upper bits for pin number
0017BE 6E0E           04080             movwf   R1,0                            ;save pin number for return
                      04081 
0017C0 0E02           04082             movlw   0x02                            ;(.25)programming-inactive for vpp2pin
0017C2 B221           04083             btfsc   FLAGS2,PMODE1,0                 ;(.25)0 means pulsed Vpp
0017C4 0E03           04084             movlw   0x03                            ;(.25)programming-active for vpp2pin
                      04085 
0017C6 B01F           04086             btfsc   SHARED,OEVPP                    ;(.5)is -OE pin also the Vpp pin?
0017C8 D7B9           04087             bra     vpp2pin                         ;y:set Vpp to its prog level again (R3=3)
                      04088 
0017CA 500E           04089             movf    R1,W,0                          ;(.25)Pin number again
                      04090 
0017CC AE0D           04091             btfss   R0,0x07,0                       ;(.25)is -OE's programming-state +12V?      
0017CE D01A           04092             bra     set_epin                        ;(3.5+.5)n: just set the pin high
                      04093 
                      04094 ;Set -OE (Must be on pin 19 or 20) to +12V for active level during programming this type of EPROM
0017D0 0A02           04095             xorlw   0x02                            ;pin 19 (encoded as 0x02)?
0017D2 E105           04096             bnz     oen2pin_20                      ;n: assume pin 20
                      04097 
                      04098 ;-OE is on pin 19, and wants to be +12V now
0017D4 5089           04099             movf    LATA,W,0
0017D6 0BCF           04100             andlw   ((1<<P19_0)+(1<<P19_1)) ^ 0xFF  ;strip off previous setting
0017D8 0920           04101             iorlw   (1<<P19_1)                      ;make it +12V
0017DA 6E89           04102             movwf   LATA,0
0017DC 0012           04103             return
                      04104 
                      04105 ;-OE is on pin 20, and wants to be +12V now
0017DE 5089           04106 oen2pin_20: movf    LATA,W,0
0017E0 0B3F           04107             andlw   ((1<<P20_0)+(1<<P20_1)) ^ 0xFF  ;strip off previous setting
0017E2 0980           04108             iorlw   (1<<P20_1)                      ;make it +12V
0017E4 6E89           04109             movwf   LATA,0
0017E6 0012           04110             return
                      04111 
                      04112 ;*==============================================================================*
                      04113 ; Subroutine to send PGM signal to its correct EPROM pin, with the correct
                      04114 ; polarity
                      04115 ; On Entry:
                      04116 ;   W = 0 if the pin is to be inactive
                      04117 ;     = 1 if the pin is to be active
                      04118 ; On Exit:
                      04119 ;   R1 = pin number - 17, with 0 meaning none
                      04120 ; Trashes W,R0,R3,EEADR,TBLPTR
                      04121 ; (15.5 uS through to pin write)
                      04122 ; (0.5 uS from pin write through return)
                      04123 ;*==============================================================================*
0017E8 6E10           04124 pgm2pin:    movwf   R3,0                    ;(.25)input in place for set_epin
                      04125 
0017EA 0E1A           04126             movlw   ET_PGMVPP               ;(.25)PGM and VPP pin specifications
0017EC D86A           04127             rcall   etype_getval            ;(9.75+.5)returns PGM pin specification in W & R0 bits <7:4>
                      04128 
                      04129 ;Invert W bit 0 if the PGM active-high bit is not set
0017EE AE0D           04130             btfss   R0,0x07,0               ;(.25)active-low pin?
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 64
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0017F0 7010           04131             btg     R3,0x00,0               ;(.25)active-low: invert bit                    
                      04132 
0017F2 380D           04133             swapf   R0,W,0                  ;(.25)put the PGM pin-number bits in W<2:0>
0017F4 D007           04134             bra     set_epin                ;(.5+3.5)pin number from W, return from there
                      04135 
                      04136 ;*==============================================================================*
                      04137 ; Subroutine to send -AS signal to its correct EPROM pin
                      04138 ; On Entry:
                      04139 ;   W = 0 if the pin is to be inactive (5V)
                      04140 ;     = 1 if the pin is to be active (0V)
                      04141 ; On Exit:
                      04142 ;   R1 = pin number - 17, with 0 meaning none
                      04143 ; Trashes W,R0,R3,EEADR,TBLPTR
                      04144 ; (11.75 uS min, if no -AS pin)
                      04145 ;*==============================================================================*
0017F6 6E10           04146 asn2pin:    movwf   R3,0                    ;(.25)input in place for set_epin
                      04147 
0017F8 0E18           04148             movlw   ET_A11A12               ;(.25)A11 and A12 pin specifications
0017FA D863           04149             rcall   etype_getval            ;(9.5+.5)returns PGM pin specification in W & R0 bits <7:4>
                      04150 
                      04151 ;A12 is really -AS if bit 3 is set
0017FC 6A0E           04152             clrf    R1,0                    ;(.25)in case this is A12
0017FE A60D           04153             btfss   R0,0x03,0               ;(.25)-AS pin?
001800 0012           04154             return                          ;(.5)no: nothing to do
                      04155                     
001802 7010           04156             btg     R3,0x00,0               ;-AS is always active low, so invert
                      04157 
                      04158 ;Fall into  set_epin
                      04159 
                      04160 ;*==============================================================================*
                      04161 ; Subroutine to set a pin to a digital level: 0V or +5V
                      04162 ; On Entry:
                      04163 ;   W bits <2:0> identify the number of the pin to set:
                      04164 ;     0: none
                      04165 ;     1: pin 18
                      04166 ;     2: pin 19
                      04167 ;     3: pin 20
                      04168 ;     4: pin 21
                      04169 ;     5: pin 22
                      04170 ;     6: pin 23
                      04171 ;     7: illegal
                      04172 ;   R3<0> = 0 sets the pin to 0V, R3<0>=1 sets the pin to +5V
                      04173 ; This subroutine assumes a legal value for the given pin in W
                      04174 ; On Exit:
                      04175 ;   R1 = pin number - 17, with 0 meaning the pin does not exist
                      04176 ;   R3 has been rotated right 1 position
                      04177 ;   The correct output port bit has been set to the requested digital value
                      04178 ; Trashes W
                      04179 ; (3.5 uS) (.5 uS from pin-write through return)    
                      04180 ;*==============================================================================*
001804 0B07           04181 set_epin:       andlw   0x07                ;(.25)just the pin assignment bits
001806 6E0E           04182                 movwf   R1,0                ;(.25)save pin number for return
                      04183 
                      04184 ;7-way jump based on R1, the pin number
001808 50F9           04185 epintab:        movf    PCL,W,0             ;(.25)force a load of the PCLATH register (page 62)
00180A 440E           04186                 rlncf   R1,W,0              ;(.25)command index (times 2 for jump table)
00180C 26F9           04187                 addwf   PCL,F,0             ;(.25)
                      04188 
00180E D02D           04189                 bra     epin_none           ;if no pin defined for this signal
001810 D025           04190                 bra     epin18              ;(.25)
001812 D01D           04191                 bra     epin19
001814 D015           04192                 bra     epin20
001816 D00D           04193                 bra     epin21
001818 D006           04194                 bra     epin22
00181A                04195 eptend:                                     ;fall through to epin23
                      04196 
                      04197 ;Specified signal is on pin 23 (which has inverting hardware)
00181A 3210           04198 epin23:         rrcf    R3,F,0              ;test
00181C E302           04199                 bnc     epin23_low
                      04200 
00181E 908B           04201                 bcf     LATC,P23n,0         ;bit is high (and inverted)
001820 0012           04202                 return
                      04203 
001822 808B           04204 epin23_low:     bsf     LATC,P23n,0         ;bit is low (and inverted)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 65
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001824 0012           04205                 return
                      04206 
                      04207 ;Specified signal is on pin 22 (which has inverting hardware)
001826 3210           04208 epin22:         rrcf    R3,F,0              ;test
001828 E302           04209                 bnc     epin22_low
                      04210 
00182A 9A8A           04211                 bcf     LATB,P22n,0         ;bit is high (and inverted)
00182C 0012           04212                 return
                      04213 
00182E 8A8A           04214 epin22_low:     bsf     LATB,P22n,0         ;bit is low (and inverted)
001830 0012           04215                 return
                      04216         
                      04217 ;Specified signal is on pin 21 (which is capable of other voltages too)
001832 508D           04218 epin21:         movf    LATE,W,0
001834 0BFC           04219                 andlw   ((1<<P21_0)+(1<<P21_1)) ^ 0xFF  ;strip off previous setting
001836 3210           04220                 rrcf    R3,F,0                          ;test
001838 B0D8           04221                 btfsc   STATUS,C,0
00183A 0901           04222                 iorlw   (1<<P21_0)                      ;y: make it 1
00183C 6E8D           04223                 movwf   LATE,0
00183E 0012           04224                 return
                      04225 
                      04226 ;Specified signal is on pin 20 (which is capable of other voltages too)
001840 5089           04227 epin20:         movf    LATA,W,0
001842 0B3F           04228                 andlw   ((1<<P20_0)+(1<<P20_1)) ^ 0xFF  ;strip off previous setting
001844 3210           04229                 rrcf    R3,F,0                          ;test
001846 B0D8           04230                 btfsc   STATUS,C,0
001848 0940           04231                 iorlw   (1<<P20_0)                      ;y: make it 1
00184A 6E89           04232                 movwf   LATA,0
00184C 0012           04233                 return
                      04234 
                      04235 ;Specified signal is on pin 19 (which is capable of other voltages too)
00184E 5089           04236 epin19:         movf    LATA,W,0
001850 0BCF           04237                 andlw   ((1<<P19_0)+(1<<P19_1)) ^ 0xFF  ;strip off previous setting
001852 3210           04238                 rrcf    R3,F,0                          ;test
001854 B0D8           04239                 btfsc   STATUS,C,0
001856 0910           04240                 iorlw   (1<<P19_0)                      ;y: make it 1
001858 6E89           04241                 movwf   LATA,0
00185A 0012           04242                 return
                      04243 
                      04244 ;Specified signal is on pin 18 (which is capable of other voltages too)
00185C 5089           04245 epin18:         movf    LATA,W,0                        ;(.25)
00185E 0BF3           04246                 andlw   ((1<<P18_0)+(1<<P18_1)) ^ 0xFF  ;(.25)strip off previous setting
001860 3210           04247                 rrcf    R3,F,0                          ;(.25)test
001862 B0D8           04248                 btfsc   STATUS,C,0                      ;(.25)
001864 0904           04249                 iorlw   (1<<P18_0)                      ;(.25)y: make it 1
001866 6E89           04250                 movwf   LATA,0                          ;(.25)
001868 0012           04251                 return                                  ;(.5)
                      04252 
00186A 3210           04253 epin_none:      rrcf    R3,F,0
00186C 0012           04254                 return
                      04255 
                      04256 ;*************************************************************
                      04257 ; The above jump table must not span a 256-byte page boundary.
                      04258 ;*************************************************************
                      04259     if high(epintab)^ high(eptend)
                      04260     error "Martin sez: epin jump table spans a page boundary"
                      04261     endif
                      04262 
                      04263 ;*==============================================================================*
                      04264 ; Subroutine to send stuck-high signal to its correct EPROM pin
                      04265 ; On Entry:
                      04266 ;   W = 0 if the pin is to be low
                      04267 ;     = 1 if the pin is to be high
                      04268 ; On Exit:
                      04269 ;   R1 = pin number - 17, with 0 meaning none
                      04270 ; Trashes W,R0,R3,EEADR,TBLPTR
                      04271 ;*==============================================================================*
00186E 6E10           04272 hi2pin:     movwf   R3,0                    ;save input
                      04273 
001870 0E18           04274             movlw   ET_A11A12               ;stuck high shares definition wih A11
001872 EC61 F00C      04275             call    etype_getval            ;result in W & R0
                      04276 
                      04277 ;does the stuck-high pin exist? Of not, done with R1=0
001876 6A0E           04278             clrf    R1,0                    ;indicate non-existance
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 66
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001878 AE0D           04279             btfss   R0,0x07,0               ;forced-high pin?
00187A 0012           04280             return                          ;y:return with R1=0
                      04281 
                      04282 ;get the stuck-high pin number and set it according to R3
00187C 380D           04283             swapf   R0,W,0                  ;<6:4> are the A11/stuck-high pin assignment
00187E D7C2           04284             bra     set_epin                ;W=pin number, R3=state
                      04285 
                      04286 ;*==============================================================================*
                      04287 ; Subroutine to send CS signal to its correct EPROM pin, with the correct
                      04288 ; polarit
                      04289 ; Note that the CS pin may also be the Vpp pin or PGM pin, not dealt with here.
                      04290 ; On Entry:
                      04291 ;   W = 0 if the pin is to be inactive
                      04292 ;     = 1 if the pin is to be active
                      04293 ; On Exit:
                      04294 ;   R1 = pin number - 17, with 0 meaning none
                      04295 ; Trashes W,R0,R3,EEADR,TBLPTR
                      04296 ; (15.25 uS through to pin write)
                      04297 ; (0.5 uS from pin write through return)
                      04298 ;*==============================================================================*
001880 6E10           04299 cs2pin:     movwf   R3,0                    ;(.25)input in place for set_epin
                      04300 
001882 0E19           04301             movlw   ET_OECS                 ;(.25)WE and -CS pin specifications
001884 D81E           04302             rcall   etype_getval            ;(9.75+.5)returns WE pin specification in W & R0 bits <3:0>
                      04303 
                      04304 ;Invert W bit 0 if the CS active-high bit is not set
001886 A60D           04305             btfss   R0,0x03                 ;(.25)test active-high bit
001888 7010           04306             btg     R3,0x00,0               ;(.25)active-low: invert bit    
                      04307 
00188A D7BC           04308             bra     set_epin                ;(.5+3.5)pin number from W, return from there
                      04309 
                      04310 ;*==============================================================================*
                      04311 ;* Subroutine write an address to the EPROM pins
                      04312 ; On Entry:
                      04313 ;*  ADDRESSH:ADDRESSL = desired address
                      04314 ;   ETYPE = currently selected EPROM type
                      04315 ;   LATE.ADRCLK is either high or low, depending on Busy state
                      04316 ;   The data buffer is either directing data to the EPROM or
                      04317 ;   its output is disabled.
                      04318 ; On Exit:
                      04319 ;   Port D is tristated
                      04320 ;   The external data buffer is tristated
                      04321 ; Trashes W,R0,R1,R2,R3,FSR0,TBLPTRH:TBLTRL,REEADR
                      04322 ; (about 40.25 uS)
                      04323 ;*==============================================================================*
00188C C006 F010      04324 address2pins:   movff   ADDRESSH,R3         ;(.25)high-order address bits first
                      04325                                             ;(R3 gets rotated on each call to set_epin)
                      04326 ;write A8, which is always at LATC.P23n
001890 0E06           04327                 movlw   .23-.17             ;(.25)specify pin 23 (always for A8)
001892 DFB8           04328                 rcall   set_epin            ;(3.5)
                      04329 
                      04330 ;Look up the pin positions of A9 & A10
001894 0E17           04331                 movlw   ET_A9A10            ;(.25)
001896 D815           04332                 rcall   etype_getval        ;(9.5+.5)result in W & R0
                      04333 
                      04334 ;Put A9 signal on its correct pin for this EPROM
001898 380D           04335                 swapf   R0,W,0              ;(.25)<6:4> are the A9 pin assignment
00189A DFB4           04336                 rcall   set_epin            ;(3.5)(preserves R0, shifts R3 right)
                      04337 
                      04338 ;Put A10 signal on its correct pin for this EPROM.
00189C 500D           04339                 movf    R0,W,0              ;(.25)<2:0> are the A10 pin number
00189E DFB2           04340                 rcall   set_epin            ;(3.5)(shifts R3 right)
                      04341 
                      04342 ;Get A11 & A12 positions. Note that A11 may be forced high by the EPROM definition.
                      04343 ;(This is to support EPROMs that have a second -CS pin.), and the A12 bits may
                      04344 ;instead describe a negative address strobe pin.
0018A0 0E18           04345                 movlw   ET_A11A12           ;(.25)
0018A2 D80F           04346                 rcall   etype_getval        ;(9.5+.5)result in W & R0
                      04347 
                      04348 ;Put A11 signal on its correct pin for this EPROM, unless it's the forced-high bit
0018A4 BE0D           04349                 btfsc   R0,0x07,0           ;(.5)forced-high pin?
0018A6 8010           04350                 bsf     R3,0x00,0           ;y: force it high
                      04351 
0018A8 380D           04352                 swapf   R0,W,0              ;(.25)<6:4> are the A11 pin assignment
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 67
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0018AA DFAC           04353                 rcall   set_epin            ;(3.5)(preserves R0, shifts R3 right)
                      04354 
                      04355 ;Put A12 signal on its correct pin for this EPROM unless it's the -AS bit
0018AC 500D           04356                 movf    R0,W,0              ;(.25)<2:0> are A12
                      04357 
0018AE A60D           04358                 btfss   R0,0x03,0           ;(.5)is this signal really tne -AS pin?
0018B0 DFA9           04359                 rcall   set_epin            ;(3.5)not -AS, so it is A12
                      04360 
                      04361 ;Write the low address byte into the external data latch. This is done last,
                      04362 ;because one or two of the high-address pins may have a 0.047 uF capacitor, and
                      04363 ;therefore be slower to transition.
0018B2 8E8A           04364                 bsf     LATB,DBUFOEn        ;(.25)disable data buffer output
                      04365 
0018B4 6A95           04366                 clrf    TRISD,0             ;(.25)un-tristate port D
0018B6 C005 FF83      04367                 movff   ADDRESSL,PORTD      ;(.5)put low address on data bus
                      04368 
0018BA 748D           04369                 btg     LATE,ADRCLK,0       ;(.25) togle the clock one way
0018BC 748D           04370                 btg     LATE,ADRCLK,0       ;(.25) and then the other way
                      04371 
0018BE 6895           04372                 setf    TRISD,0             ;(.25)tristate on the data bus again
                      04373 
0018C0 0012           04374                 return                      ;(.5)
                      04375 
                      04376 ;*==============================================================================*
                      04377 ; Subroutine to look up an EPROM type in the EPROM table, and get the value of
                      04378 ; a record item for that EPROM type. Note that the table of built-in EPROM types
                      04379 ; is in Flash memory, while the table of custom EPROM types are in EEPROM. The
                      04380 ; formats for these two tables are slightly different.
                      04381 ; On Entry:
                      04382 ;   W = desired record item
                      04383 ;   ETYPE (in EEPROM) = EPROM type
                      04384 ; On Exit:
                      04385 ;   W = R0 = specified value from EPROM table
                      04386 ;   If specified EPROM is in flash:
                      04387 ;      FLAGS2.CUST_EPROM is cleared
                      04388 ;      TBLPTRH:TBLPTRL = address of the desired item within the desired
                      04389 ;        EPROM record
                      04390 ;   If specified EPROM is in EEPROM (a custom EPROM):
                      04391 ;      FLAGS2.CUST_EPROM is set
                      04392 ;      EEADR = address of the desired item within the desired EPROM record
                      04393 ; Trashes R1
                      04394 ; (9.75 uS)
                      04395 ;*==============================================================================*
0018C2 D80A           04396 etype_getval:   rcall   etype_lookup            ;(7.25+.5)
                      04397 
                      04398 ;Look up value in Flash table or EEPROM table, depending on CUST_EPROM
0018C4 BE21           04399                 btfsc   FLAGS2,CUST_EPROM,0     ;(.5)custom EPROM (so the record is in EEPROM)?
0018C6 D004           04400                 bra     egv_cust
                      04401 
                      04402 ;Flash table lookup
0018C8 0008           04403                 tblrd*                          ;(.5)n: get flash table value
0018CA 50F5           04404                 movf    TABLAT,W,0              ;(.25)
                      04405 
0018CC 6E0D           04406                 movwf   R0,0                    ;(.25)into R0 for return
0018CE 0012           04407                 return                          ;(.5)return with flash table value
                      04408 
                      04409 ;EEPROM table lookup
0018D0 EC19 F000      04410 egv_cust:       call    K_RDEEPROM              ;read value from EEPROM
0018D4 6E0D           04411                 movwf   R0,0
0018D6 0012           04412                 return
                      04413 
                      04414 ;*==============================================================================*
                      04415 ; Subroutine to look up an EPROM type in the EPROM table. Note that the table of
                      04416 ; built-in EPROM types is in Flash memory, while the table of custom EPROM types
                      04417 ; are in EEPROM.
                      04418 ; On Entry:
                      04419 ;   W = desired record item
                      04420 ;   ETYPE (in EEPROM) = EPROM type
                      04421 ; On Exit:
                      04422 ;   If specified EPROM is in flash:
                      04423 ;      FLAGS2.CUST_EPROM is cleared
                      04424 ;      TBLPTRH:TBLPTRL = address of the desired item within the desired EPROM record
                      04425 ;   If specified EPROM is in EEPROM (a custom EPROM):
                      04426 ;      FLAGS2.CUST_EPROM is set
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 68
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      04427 ;      W= EEADR = address of the desired item within the desired EPROM record
                      04428 ; Trashes W,R0,R1,PRODH:PRODL
                      04429 ; (7.25 uS)
                      04430 ;*==============================================================================*
0018D8 6E0E           04431 etype_lookup:   movwf   R1,0                ;(.25)remember record item
0018DA 0E1C           04432                 movlw   ETYPE               ;(.25)EEPROM address of variable
0018DC EC19 F000      04433                 call    K_RDEEPROM          ;(1.5 +.5 )W = EPROM type
                      04434 
                      04435 ;Is this a custom EPROM, or one from the inbuilt table?
0018E0 6E0D           04436                 movwf   R0,0                ;(.25)temp save ETYPE
0018E2 0E28           04437                 movlw   FEPROM_COUNT        ;(.25)
0018E4 5C0D           04438                 subwf   R0,W,0              ;(.25)W:= ETYPE - FEPROM_COUNT
                      04439                                             ; carry cleared if  ETYPE < FEPROM_COUNT
0018E6 E20E           04440                 bc      cust_lookup         ;(.25)
                      04441 
                      04442 ;Look up EPROM type in FLASH table. This will be a 16-bit FLASH address.
0018E8 500D           04443 flookup:        movf    R0,W,0              ;(.25)
0018EA 0D24           04444                 mullw   ET_RLENGTH          ;(.25)
0018EC 50F3           04445                 movf    PRODL,W,0           ;(.25)
0018EE 0FC6           04446                 addlw   low(eprom_table)    ;(.25)
0018F0 6EF6           04447                 movwf   TBLPTRL,0           ;(.25)
0018F2 0E30           04448                 movlw   high(eprom_table)   ;(.25)
0018F4 20F4           04449                 addwfc  PRODH,W,0           ;(.25)
0018F6 6EF7           04450                 movwf   TBLPTRH,0           ;(.25)TPLPTRH:TBLPTRL = record address
                      04451 
0018F8 500E           04452                 movf    R1,W,0              ;(.25)add in the item
0018FA 26F6           04453                 addwf   TBLPTRL,F,0         ;(.25)
0018FC B0D8           04454                 btfsc   STATUS,C,0          ;(.25)
0018FE 2AF7           04455                 incf    TBLPTRH,F,0         ;(.25)
                      04456 
001900 9E21           04457                 bcf     FLAGS2,CUST_EPROM,0 ;(.25)EPROM is not custom
001902 0012           04458                 return                      ;(.5)
                      04459 
                      04460 ;Look up EPROM in custom table in EEPROM. W = ETYPE - FEPROM_COUNT here. Note that
                      04461 ;the EEPROM is only 256 bytes long, so there will never be an address high byte.
001904 0D24           04462 cust_lookup:    mullw   ET_RLENGTH
                      04463 
001906 50F3           04464                 movf    PRODL,W,0           ;offset to record
001908 0F22           04465                 addlw   CE_TABLE            ;W = address of record in EEPROM
00190A 240E           04466                 addwf   R1,W,0              ;W=address of item with record
00190C 6EA9           04467                 movwf   EEADR,0
                      04468 
00190E 8E21           04469                 bsf     FLAGS2,CUST_EPROM,0 ;This is a custom EPROM
001910 0012           04470                 return
                      04471 
                      04472 ;*==============================================================================*
                      04473 ; Subroutine to print the programming voltage as seen at the pin, accounting
                      04474 ; for the diode-drop difference between Vpp at pin 18 versus Vpp at pins 19-21
                      04475 ; On Entry:
                      04476 ;   ETYPE is current EPROM type
                      04477 ;   R2 = pin number minus 17
                      04478 ;   R0 = ET_VPPSETUP for the current EPROM type
                      04479 ; Trashes W,R0,R1,R2, FSR0
                      04480 ;===============================================================================*
001912 380D           04481 pvpp_voltage:   swapf   R0,W,0              ;get the programming voltage bits
001914 0B07           04482                 andlw   0x07
001916 6E0E           04483                 movwf   R1,0
                      04484 
001918 EE01 F0C2      04485                 lfsr    0,fail_msg-sstrings ;flag bad table value
                      04486 
                      04487 ;If Vpp is on pin 18 then it will be one diode drop (about 0.85V) higher,
                      04488 ;requiring different messages
00191C 040F           04489                 decf    R2,W,0              ;test for R2=1, meaning pin 18
00191E E112           04490                 bnz     pvpp_notpin18
                      04491 
001920 4E0E           04492                 dcfsnz  R1,F,0
001922 EE08 F002      04493                 lfsr    0,v1340_msg-sstrings
                      04494 
001926 4E0E           04495                 dcfsnz  R1,F,0
001928 EE08 F00A      04496                 lfsr    0,v1385_msg-sstrings
                      04497 
00192C 4E0E           04498                 dcfsnz  R1,F,0
00192E EE08 F012      04499                 lfsr    0,v2170_msg-sstrings
                      04500 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 69
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001932 4E0E           04501                 dcfsnz  R1,F,0
001934 EE08 F01A      04502                 lfsr    0,v2590_msg-sstrings
                      04503 
001938 060E           04504                 decf    R1,F,0                  ;External supply?
00193A E110           04505                 bnz     pvpp_printv
                      04506 
                      04507 ;External negative Vpp.
00193C EE05 F07C      04508                 lfsr    0,extneg_msg-sstrings   ;"external supply"
001940 A0D8           04509                 btfss   STATUS,C,0
001942 D560           04510                 bra     cr_printf
                      04511 
                      04512 ;Note that an external supply is only allowed on pin 18.
                      04513 
001944 4E0E           04514 pvpp_notpin18:  dcfsnz  R1,F,0
001946 EE07 F0E4      04515                 lfsr    0,v1270_msg-sstrings
                      04516 
00194A 4E0E           04517                 dcfsnz  R1,F,0
00194C EE07 F0EC      04518                 lfsr    0,v1315_msg-sstrings
                      04519 
001950 4E0E           04520                 dcfsnz  R1,F,0
001952 EE07 F0F4      04521                 lfsr    0,v21_msg-sstrings
                      04522 
001956 4E0E           04523                 dcfsnz  R1,F,0
001958 EE07 F0FA      04524                 lfsr    0,v2510_msg-sstrings
                      04525 
                      04526 ;Custom Vpp voltage?
00195C 0E22           04527 pvpp_printv:    movlw   ET_SPECIAL
00195E DFB1           04528                 rcall   etype_getval
001960 0B02           04529                 andlw   0x02                ;test custom Vcc bit
001962 B4D8           04530                 btfsc   STATUS,Z,0
001964 D545           04531                 bra     printf              ;n: print the programming voltage & ret
                      04532 
001966 0E15           04533                 movlw   ET_VPPMSG
001968 6A0F           04534                 clrf    R2,0                ;no formatting
00196A D5F9           04535                 bra     eds_print           ;print the adjustment message & return
                      04536 
                      04537 ;################################################################################
                      04538 ;#                       Custom EPROM Editor Subsystem                          #
                      04539 ;################################################################################
                      04540 
                      04541 ;*****------------------------------------------------------------------------*
                      04542 ;* ?A * Custom EPROM Editor Command: Display Pin Assignment Commands
                      04543 ;*****
                      04544 ; On Entry:
                      04545 ;   FSR1 points to the rest of the command line from the user
                      04546 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04547 ;-------------------------------------------------------------------------------*
00196C 0E7C           04548 ecmd_ahelp:     movlw   low(eamenu_msg)
00196E 6EF6           04549                 movwf   TBLPTRL,0
001970 0E61           04550                 movlw   high(eamenu_msg)
001972 6EF7           04551                 movwf   TBLPTRH,0
001974 EF07 F000      04552                 goto    K_PRINTF                ;return from there
                      04553 
                      04554 ;*****------------------------------------------------------------------------*
                      04555 ;* ? * Custom EPROM Editor Command: Re-display Eprom Editor Commands
                      04556 ;*****
                      04557 ; On Entry:
                      04558 ;   FSR1 points to the rest of the command line from the user
                      04559 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04560 ;-------------------------------------------------------------------------------*
001978 0E9E           04561 ecmd_eehelp:    movlw   low(eemenu_msg)         ;Print the EPROM editor menu
00197A 6EF6           04562                 movwf   TBLPTRL,0
00197C 0E5F           04563                 movlw   high(eemenu_msg)
00197E 6EF7           04564                 movwf   TBLPTRH,0
001980 EC07 F000      04565                 call    K_PRINTF
                      04566 
                      04567 ;Tell user to name the EPROM if it's not already named
001984 0E00           04568                 movlw   ET_NAME                 ;point EEADR to the name's place
001986 DF9D           04569                 rcall   etype_getval            ;look at 1st chr of name
001988 EE0A F038      04570                 lfsr    0,gname_msg-sstrings    ;"EPROM is unassigned until it is named (EN)"
00198C 0900           04571                 iorlw   0x00                    ;no name?
00198E B4D8           04572                 btfsc   STATUS,Z,0
001990 EC02 F00A      04573                 call    cr_printf
                      04574 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 70
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001994 0012           04575                 return
                      04576 
                      04577 ;******-------------------------------------------------------------------------*
                      04578 ;* QU * Custom EPROM Editor Command: Quit
                      04579 ;******
                      04580 ; On Entry:
                      04581 ;   ETYPE_SAVE = original EPROM type
                      04582 ;-------------------------------------------------------------------------------*
001996 DDB8           04583 ecmd_quit:      rcall       restore_etype       ;restore EPROM type
001998 DE1C           04584                 rcall       etype_setup         ;in case we changed the current type
00199A EF3A F004      04585                 goto        main                ;rude return
                      04586 
                      04587 ;******-------------------------------------------------------------------------*
                      04588 ;* EN * Custom EPROM Editor Command: Name EPROM
                      04589 ;******
                      04590 ; On Entry:
                      04591 ;   FSR1 points to the rest of the command line from the user
                      04592 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04593 ;-------------------------------------------------------------------------------*
00199E 0E00           04594 ecmd_epname:    movlw   ET_NAME         ;point EEADR to the name's place
0019A0 DF9B           04595                 rcall   etype_lookup
                      04596 
0019A2 0E0F           04597                 movlw   MAXNAME+1       ;max allowed characters
0019A4 6E10           04598                 movwf   R3,0
                      04599 
0019A6 0E00           04600 epn_loop:           movlw   0x00
0019A8 2E10           04601                     decfsz  R3,F,0          ;too many characters?
0019AA EC10 F000      04602                     call    K_GETCHR        ;n: get another from the user
                      04603                                             ;..into W & R0
                      04604 
0019AE 0A20           04605                     xorlw   ' '             ;terminator?
0019B0 A4D8           04606                     btfss   STATUS,Z,0      ;y: make it a null
0019B2 0A20           04607                     xorlw   ' '
0019B4 6E0F           04608                     movwf   R2,0            ;put it back, space converted to null
                      04609 
0019B6 EC1A F000      04610                     call    K_WREEPROM
0019BA 2AA9           04611                     incf    EEADR,F,0
                      04612 
0019BC 520F           04613                     movf    R2,F,0          ;done?
0019BE E1F3           04614                     bnz     epn_loop    
                      04615 
0019C0 0012           04616                 return
                      04617 
                      04618 ;******=========================================================================*
                      04619 ;* EE * Invoke Custom EPROM Editor
                      04620 ;******
                      04621 ; On Entry:
                      04622 ;   DFLT_FLAG set if no parameters came with this command
                      04623 ;   ADDRESSL = EPROM number
                      04624 ;===============================================================================*
                      04625 ;remember actual current EPROM type
0019C2 DD9D           04626 do_ceedit:      rcall   save_etype              ;save original ETYPE while we work
                      04627                                                 ;..and set EEADR to ETYPE
                      04628 
0019C4 B620           04629                 btfsc   FLAGS1,DFLT_FLAG,0      ;any user input?
0019C6 6E05           04630                 movwf   ADDRESSL,0              ;n: current EPROM is the choice
                      04631 
                      04632 ;Validate that the requested EPROM type is a custom EPROM type
0019C8 EE07 F018      04633                 lfsr    0,cantedit_msg-sstrings
0019CC 0E28           04634                 movlw   FEPROM_COUNT            ;Trying to edit an inbuilt EPROM?
0019CE 5C05           04635                 subwf   ADDRESSL,W,0            ;W:= input value - FEPROM_COUNT
                      04636                                                 ;carry cleared if input value < FEPROM_COUNT
                      04637 
0019D0 A0D8           04638                 btfss   STATUS,C,0
0019D2 D518           04639                 bra     cr_printf               ;error if attempting to edit inbuilt EPROM
                      04640 
0019D4 0803           04641                 sublw   CEPROM_COUNT-1          ;too big?
0019D6 A0D8           04642                 btfss   STATUS,C,0              ;Carry set if ADDRESSL <= max allowed EPROM
0019D8 EF6D F006      04643                 goto    cmd_error
                      04644 
                      04645 ;Set requested EPROM to be the current one for now
0019DC 5005           04646                 movf    ADDRESSL,W,0            ;EEADR is already set up
0019DE EC1A F000      04647                 call    K_WREEPROM              ;requested EEPROM is current for now
                      04648 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 71
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      04649 ;Display list of custom EPROM editor commands
0019E2 DFCA           04650                 rcall   ecmd_eehelp
                      04651 
                      04652 ;---------------------------------------------------------------------------------
                      04653 ; Print the special EPROM Editor prompt on a new line and get a command
                      04654 ;---------------------------------------------------------------------------------
0019E4 D801           04655 ee_main:        rcall   go_ee_main              ;push return address onto the stack
0019E6 D7FE           04656                 bra     ee_main
                      04657 
0019E8 EE00 F024      04658 go_ee_main:     lfsr    0,eeprompt_msg-sstrings
0019EC DD0B           04659                 rcall   cr_printf
0019EE 5005           04660                 movf    ADDRESSL,W,0            ;put EPROM number in the prompt
0019F0 EC0A F000      04661                 call    K_PRINTHEX2
0019F4 0E3E           04662                 movlw   PROMPTCHR
0019F6 EC06 F000      04663                 call    K_CONOUT
                      04664 
                      04665 ;Re-calculate the EPROM size every time we pass through this loop
                      04666 ;The size is determined by the highest (contiguous) assigned address pin.
0019FA 0E01           04667                 movlw   0x01
0019FC 6E11           04668                 movwf   R4,0                    ;assume 512 bytes for now
                      04669 
0019FE 0E17           04670                 movlw   ET_A9A10
001A00 DF60           04671                 rcall   etype_getval            ;result in W and R0
001A02 0B70           04672                 andlw   0x70                    ;any A9 pin asigned?
001A04 E00E           04673                 bz      size_done               ;n: it's 512 bytes
001A06 2A11           04674                 incf    R4,F,0                  ;y: it's at least 1K bytes
                      04675 
001A08 500D           04676                 movf    R0,W,0
001A0A 0B07           04677                 andlw   0x07                    ;any A10 pin assigned?
001A0C E00A           04678                 bz      size_done               ;n: it's 1K bytes
001A0E 2A11           04679                 incf    R4,F,0                  ;y: it's at least 2K bytes
                      04680 
001A10 0E18           04681                 movlw   ET_A11A12
001A12 DF57           04682                 rcall   etype_getval            ;result in W & R0
001A14 0B70           04683                 andlw   0x70                    ;any A11 pin asigned?
001A16 E005           04684                 bz      size_done               ;n: it's 2K bytes
001A18 2A11           04685                 incf    R4,F,0                  ;y: it's at least 4K bytes
                      04686 
001A1A 500D           04687                 movf    R0,W,0
001A1C 0B07           04688                 andlw   0x07                    ;any A12 pin assigned?
001A1E E001           04689                 bz      size_done               ;n: it's 4K bytes
001A20 2A11           04690                 incf    R4,F,0                  ;y: it's 8K bytes
                      04691 
001A22 0E16           04692 size_done:      movlw   ET_BYTES
001A24 DF4E           04693                 rcall   etype_getval            ;result in W & R0, set EEADR to ET_BYTES
                      04694 
001A26 0E80           04695                 movlw   0x80                    ;we only support 8 bits/byte now
001A28 2411           04696                 addwf   R4,W,0                  ;compute new reg value
                      04697 
001A2A 620D           04698                 cpfseq  R0,0                    ;any changes to this byte?
001A2C EC1A F000      04699                 call    K_WREEPROM              ;y: remember the new byte size in ET_BYTES
                      04700 
                      04701 ;Get a complete, CR-terminated line into the line buffer
001A30 0E4F           04702                 movlw   MAXLIN-1                ;max input line size
001A32 EC0E F000      04703                 call    K_GETLIN                ;get a line from the user into the LINEBUF
001A36 E0D8           04704                 bz      go_ee_main              ;no input, ^c or ESC: start over
                      04705 
                      04706 ;Search EPROM Editor command table for match, get its command index into R4
001A38 0E23           04707                 movlw   high(ee_cmds)
001A3A 6EF7           04708                 movwf   TBLPTRH,0
001A3C 0E58           04709                 movlw   low(ee_cmds)
001A3E 6EF6           04710                 movwf   TBLPTRL,0
                      04711 
001A40 EC0F F000      04712                 call    K_PARSE                 ;returns W=command index
                      04713 
                      04714 ;----------------------------------------------------------------------------------         
                      04715 ; Go execute an EPROM Editor command, if it exists
                      04716 ; W = command index, 0 means not found
                      04717 ; All of these command-processing routines return to ee_main when done
                      04718 ;----------------------------------------------------------------------------------         
001A44 CFF9 F00D      04719 jmptab2:    movff   PCL,R0              ;force a load of the PCLATH register (page 62)
001A48 26F9           04720             addwf   PCL,F,0
                      04721 
001A4A D1E0           04722             bra     ecmd_error          ;command not found
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 72
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001A4C EF5C F008      04723             goto    cmd_tprog           ;TPROG
001A50 EF71 F008      04724             goto    cmd_tread           ;TREAD
001A54 D02B           04725             bra     ecmd_deleprom       ;DEP
001A56 D21D           04726             bra     ecmd_dispeprom      ;ED
001A58 D7A2           04727             bra     ecmd_epname         ;EN
001A5A D79D           04728             bra     ecmd_quit           ;QU
001A5C D78D           04729             bra     ecmd_eehelp         ;?
001A5E D037           04730             bra     ecmd_vbb            ;VBB
001A60 D044           04731             bra     ecmd_vdd            ;VDD
001A62 D051           04732             bra     ecmd_a9             ;A9
001A64 D053           04733             bra     ecmd_a10            ;A10
001A66 D058           04734             bra     ecmd_a11            ;A11
001A68 D05D           04735             bra     ecmd_a12            ;A12
001A6A D07C           04736             bra     ecmd_oen            ;OEN
001A6C D091           04737             bra     ecmd_cs             ;CS
001A6E D0A5           04738             bra     ecmd_csp            ;CSP
001A70 D0AD           04739             bra     ecmd_pgm            ;PGM
001A72 D0C1           04740             bra     ecmd_pgp            ;PGP
001A74 D0C9           04741             bra     ecmd_ppp            ;PPP
001A76 D0EA           04742             bra     ecmd_vcp            ;VCP
001A78 D0F0           04743             bra     ecmd_oev            ;OEV
001A7A D10E           04744             bra     ecmd_vpp            ;VPP
001A7C D115           04745             bra     ecmd_vpr            ;VPR
001A7E D169           04746             bra     ecmd_pul            ;PUL
001A80 D16F           04747             bra     ecmd_ptu            ;PTU
001A82 D17F           04748             bra     ecmd_ppw            ;PPW
001A84 D185           04749             bra     ecmd_pps            ;PPS
001A86 D192           04750             bra     ecmd_pol            ;POL
001A88 D196           04751             bra     ecmd_spa            ;SPA
001A8A D19A           04752             bra     ecmd_fp1            ;FP1
001A8C D1A4           04753             bra     ecmd_fn1            ;FN1
001A8E D19A           04754             bra     ecmd_fp2            ;FP2
001A90 D1A4           04755             bra     ecmd_fn2            ;FN2
001A92 D1AD           04756             bra     ecmd_pmx            ;PMX
001A94 D155           04757             bra     ecmd_ff1            ;FF1
001A96 D04C           04758             bra     ecmd_asn            ;ASN
001A98 D051           04759             bra     ecmd_hi             ;HI
001A9A D10F           04760             bra     ecmd_bck            ;BCK
001A9C D117           04761             bra     ecmd_copy           ;COP
001A9E D766           04762             bra     ecmd_ahelp          ;?A
                      04763 
001AA0                04764 jmpend2:    ;fall into ecmd_phelp for ?P
                      04765 
                      04766 ;*****------------------------------------------------------------------------*
                      04767 ;* ?P * Custom EPROM Editor Command: Display Programming Parameter Commands
                      04768 ;*****
                      04769 ; On Entry:
                      04770 ;   FSR1 points to the rest of the command line from the user
                      04771 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04772 ;-------------------------------------------------------------------------------*
001AA0 0ED2           04773 ecmd_phelp:     movlw   low(epmenu_msg)
001AA2 6EF6           04774                 movwf   TBLPTRL,0
001AA4 0E64           04775                 movlw   high(epmenu_msg)
001AA6 6EF7           04776                 movwf   TBLPTRH,0
001AA8 EF07 F000      04777                 goto    K_PRINTF                ;return from there
                      04778 
                      04779 ;********************************************************************************
                      04780 ; The above jump table must not span a 256-byte page boundary.
                      04781 ;********************************************************************************
                      04782     if high(jmptab2)^ high(jmpend2)
                      04783     error "Martin sez: EPROM Editor command jump table spans a page boundary"
                      04784     endif
                      04785 
                      04786 ;*******------------------------------------------------------------------------*
                      04787 ;* DEP * Custom EPROM Editor Command: Delete EPROM
                      04788 ;*******
                      04789 ; On Entry:
                      04790 ;   FSR1 points to the rest of the command line from the user
                      04791 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04792 ;-------------------------------------------------------------------------------*
001AAC 0E00           04793 ecmd_deleprom:  movlw   ET_NAME                 ;clear this to delete an EPROM
001AAE DF14           04794                 rcall   etype_lookup            ;set EEADR to ET_NAME
                      04795 
001AB0 EE0A F024      04796                 lfsr    0,delce_msg-sstrings    ;"Delete EPROM"
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 73
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001AB4 DCA7           04797                 rcall   cr_printf
001AB6 EC15 F000      04798                 call    K_ASKYN
001ABA E108           04799                 bnz     edel_done               ;did user say yes?
                      04800 
001ABC 0E24           04801                 movlw   ET_RLENGTH              ;bytes per EPROM record
001ABE 6E10           04802                 movwf   R3,0
                      04803 
                      04804 ;Loop to clear out custom EPROM, starting at ET_NAME
001AC0 0E00           04805 edel_loop:          movlw   0x00
001AC2 EC1A F000      04806                     call    K_WREEPROM
001AC6 2AA9           04807                     incf    EEADR,F,0
001AC8 0610           04808                     decf    R3,F,0
001ACA E1FA           04809                     bnz     edel_loop
                      04810 
001ACC 0012           04811 edel_done:      return
                      04812 
                      04813 ;*******------------------------------------------------------------------------*
                      04814 ;* VBB * Custom EPROM Editor Command: Define Vbb pin
                      04815 ;*******
                      04816 ; VBB <0/1> 0 means none
                      04817 ;           1 means -5V on pin 21
                      04818 ; On Entry:
                      04819 ;   FSR1 points to the rest of the command line from the user
                      04820 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04821 ;-------------------------------------------------------------------------------*
001ACE 0E1B           04822 ecmd_vbb:       movlw   ET_VBBVDD
001AD0 DEF8           04823                 rcall   etype_getval        ;get Vcc, Vbb & Vdd setup
                      04824                                             ;..and set ETYPE to ET_VBBVDD
                      04825 
001AD2 0BEF           04826                 andlw   0xEF                ;strip off old Vbb
001AD4 6E12           04827                 movwf   R5,0                ;save for end
                      04828 
001AD6 0E01           04829                 movlw   0x01                ;allow only allow 0-1
001AD8 D990           04830                 rcall   ee_getdec           ;result in W & R0, trash R1. Z set if 1
001ADA E104           04831                 bnz     evbb_none           ;no Vbb pin?
                      04832 
                      04833 ;Vbb is always on pin 21. If any other signals are assigned to pin 21, remove them
001ADC 0E04           04834                 movlw   0x04                ;pin 21 encoding
001ADE 6E10           04835                 movwf   R3,0
001AE0 D998           04836                 rcall   dup_delete
                      04837 
001AE2 8812           04838                 bsf     R5,0x04,0           ;enable Vbb
                      04839 
001AE4 5012           04840 evbb_none:      movf    R5,W,0
001AE6 EF1A F000      04841                 goto    K_WREEPROM          ;install new ET_VBBVDD value, return
                      04842 
                      04843 ;*******------------------------------------------------------------------------*
                      04844 ;* VDD * Custom EPROM Editor Command: Define Vdd pin
                      04845 ;*******
                      04846 ; VDD <0/1> 0 means none
                      04847 ;             1 means +12V on pin 19
                      04848 ; On Entry:
                      04849 ;   FSR1 points to the rest of the command line from the user
                      04850 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04851 ;-------------------------------------------------------------------------------*
001AEA 0E1B           04852 ecmd_vdd:       movlw   ET_VBBVDD
001AEC DEEA           04853                 rcall   etype_getval        ;get Vcc, Vbb & Vdd setup
                      04854                                             ;..and set EEADR to ET_VBBVDD
001AEE 0BDF           04855                 andlw   0xDF                ;strip off old Vdd
001AF0 6E12           04856                 movwf   R5,0                ;save for end
                      04857 
001AF2 0E01           04858                 movlw   0x01                ;allow only allow 0-1
001AF4 D982           04859                 rcall   ee_getdec           ;result in W & R0, trash R1. Z set if 1
001AF6 E104           04860                 bnz     evdd_none           ;no Vbb pin?
                      04861 
                      04862 ;Vbb is always on pin 19. If any other signals are assigned to pin 19, remove them
001AF8 0E02           04863                 movlw   0x02                ;pin 21 encoding
001AFA 6E10           04864                 movwf   R3,0
001AFC D98A           04865                 rcall   dup_delete
                      04866 
001AFE 8A12           04867                 bsf     R5,0x05,0           ;enable Vdd
                      04868 
001B00 5012           04869 evdd_none:      movf    R5,W,0
001B02 EF1A F000      04870                 goto    K_WREEPROM          ;install new ET_VBBVDD value, return
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 74
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      04871 
                      04872 ;******-------------------------------------------------------------------------*
                      04873 ;* A9 * Custom EPROM Editor Command: assign pin number to A9 signal
                      04874 ;******
                      04875 ; On Entry:
                      04876 ;   FSR1 points to the rest of the command line from the user
                      04877 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04878 ; See comment at assignp for exit details
                      04879 ;-------------------------------------------------------------------------------*
001B06 0E17           04880 ecmd_a9:    movlw   ET_A9A10
001B08 DEE7           04881             rcall   etype_lookup        ;point EEADR to the correct byte
                      04882 
001B0A D01D           04883             bra     assignp_hi
                      04884 
                      04885 ;*******------------------------------------------------------------------------*
                      04886 ;* A10 *  Custom EPROM Editor Command: assign pin number to A10 signal
                      04887 ;*******
                      04888 ; On Entry:
                      04889 ;   FSR1 points to the rest of the command line from the user
                      04890 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04891 ; Note that A10 shares its definition with the stuck-low signal - an EPROM
                      04892 ; with a stuck-low signal cannot also have an A10 pin and vice versa. Assigning
                      04893 ; a pin to be A10 will unassign any stuck-low signal.
                      04894 ; See comment at assignp for exit details
                      04895 ;-------------------------------------------------------------------------------*
001B0C 0E17           04896 ecmd_a10:   movlw   ET_A9A10
001B0E DED9           04897             rcall   etype_getval        ;sets EEADR to ET_A9A10 too
001B10 0BF7           04898             andlw   0xF7                ;remove stuck-low indicator bit
001B12 EC1A F000      04899             call    K_WREEPROM
                      04900 
001B16 D019           04901             bra     assignp_lo          ;creates mask=0xF8
                      04902 
                      04903 ;*******------------------------------------------------------------------------*
                      04904 ;* A11 *  Custom EPROM Editor Command: assign pin number to A11 signal
                      04905 ;*******
                      04906 ; On Entry:
                      04907 ;   FSR1 points to the rest of the command line from the user
                      04908 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04909 ; Note that A11 shares its definition with the stuck-high signal - an EPROM
                      04910 ; with a stuck-high signal cannot also have an A11 pin and vice versa. Assigning
                      04911 ; a pin to be A11 will unassign any stuck-high signal.
                      04912 ; See comment at assignp for exit details
                      04913 ;-------------------------------------------------------------------------------*
001B18 0E18           04914 ecmd_a11:   movlw   ET_A11A12
001B1A DED3           04915             rcall   etype_getval        ;sets EEADR to ET_A11A12 too
                      04916 
001B1C 0B7F           04917             andlw   0x7F                ;remove stuck-high indicator bit
001B1E EC1A F000      04918             call    K_WREEPROM
                      04919 
001B22 D011           04920             bra     assignp_hi          ;creates mask=0x8F
                      04921 
                      04922 ;*******------------------------------------------------------------------------*
                      04923 ;* A12 *  Custom EPROM Editor Command: assign pin number to A12 signal
                      04924 ;*******
                      04925 ; On Entry:
                      04926 ;   FSR1 points to the rest of the command line from the user
                      04927 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04928 ; Note that A12 shares its definition with the -AS signal - an EPROM with a -AS
                      04929 ; signal cannot also have an A12 pin and vice versa. Assigning a pin to be A12
                      04930 ; will unassign any -AS signal.
                      04931 ; See comment at assignp for exit details
                      04932 ;-------------------------------------------------------------------------------*
001B24 0E18           04933 ecmd_a12:   movlw   ET_A11A12
001B26 DECD           04934             rcall   etype_getval        ;sets EEADR to ET_A11A12 too
                      04935 
001B28 0BF7           04936             andlw   0xF7                ;remove -AS indicator bit
001B2A EC1A F000      04937             call    K_WREEPROM
                      04938 
001B2E D00D           04939             bra     assignp_lo          ;creates mask=0xF8
                      04940 
                      04941 ;*******------------------------------------------------------------------------*
                      04942 ;* ASN *  Custom EPROM Editor Command: assign pin number to -AS signal
                      04943 ;*******
                      04944 ; On Entry:
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 75
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      04945 ;   FSR1 points to the rest of the command line from the user
                      04946 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04947 ; Note that A12 shares its definition with the -AS signal - an EPROM with a -AS
                      04948 ; signal cannot also have an A12 pin and vice versa. Assigning a pin to be -AS
                      04949 ; will unassign any A12 signal.
                      04950 ; See comment at assignp for exit details
                      04951 ;-------------------------------------------------------------------------------*
001B30 0E18           04952 ecmd_asn:   movlw   ET_A11A12           ;-ASN shares pin definition with A12
001B32 DEC7           04953             rcall   etype_getval        ;sets EEADR to ET_A11A12 too
                      04954 
001B34 0908           04955             iorlw   0x08                ;set -AS indicator bit
001B36 EC1A F000      04956             call    K_WREEPROM
                      04957 
001B3A D007           04958             bra     assignp_lo          ;creates mask=0xF8
                      04959 
                      04960 ;******-------------------------------------------------------------------------*
                      04961 ;* HI *  Custom EPROM Editor Command: Define stuck-high pin
                      04962 ;******
                      04963 ; On Entry:
                      04964 ;   FSR1 points to the rest of the command line from the user
                      04965 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      04966 ; Note that A11 shares its definition with the stuck-high signal - an EPROM
                      04967 ; with a stuck-high signal cannot also have an A11 pin and vice versa. Assigning
                      04968 ; a pin to be stuck-high will unassign any A11 signal.
                      04969 ; See comment at assignp for exit details
                      04970 ;-------------------------------------------------------------------------------*
001B3C 0E18           04971 ecmd_hi:    movlw   ET_A11A12           ;stuck-high shares pin definition with A11
001B3E DEC1           04972             rcall   etype_getval        ;sets EEADR to ET_A11A12 too
                      04973 
001B40 0980           04974             iorlw   0x80                ;set stuck-high bit
001B42 EC1A F000      04975             call    K_WREEPROM
                      04976 
                      04977 ;fall into assignp_hi
                      04978 
                      04979 ;-------------------------------------------------------------------------------*
                      04980 ; EPROM Editor Subroutine for EPROM to assign a pin number to an EPROM signal
                      04981 ; 1) Hunt for any other signals that have the same pin number as the one we
                      04982 ; are about to assign. 
                      04983 ; 2) If we find any, then sets them to 0, meaning that signal is now unassigned.
                      04984 ; 3) Install the new pin number into the signal specified on entry
                      04985 ; On Entry at assignp_hi or assignp_lo:
                      04986 ;   EEADR = address of entry
                      04987 ;   New pin number is still in the line buffer (to be retrieved by get_pin)
                      04988 ; On Entry at assignp:
                      04989 ;   EEADR = target signal's pin definition address
                      04990 ;   R3 = new pin number from user
                      04991 ;   R5 = pin mask
                      04992 ; On Exit (valid entry):
                      04993 ;   Any other signals with the provided pin number are now unassigned
                      04994 ;   The specified signal has the specified pin number
                      04995 ;   An invalid pin number prints the command error message and returns to the
                      04996 ;   EPROM Editor loop.
                      04997 ; Trashes W, R0-R6.
                      04998 ;-------------------------------------------------------------------------------*
001B46 0E8F           04999 assignp_hi: movlw   0x8F                ;high-nibble mask
001B48 D001           05000             bra     assignp_hl
                      05001 
001B4A 0EF8           05002 assignp_lo: movlw   0xF8                ;low-nibble mask
                      05003 
001B4C 6E12           05004 assignp_hl: movwf   R5,0                ;R5=pin mask
                      05005 
001B4E D991           05006             rcall   get_pin             ;get W=R3=pin number from user (trashes R0)
                      05007 
001B50 CFA9 F011      05008 assignp:    movff   EEADR,R4            ;R4=pin-pair address for the pin we are changing
                      05009 
                      05010 ;hunt for any pins that have the same pin number as this new one, and clear them
                      05011 ;   R3 = new pin number from user, in one nibble or the other
                      05012 ;   R4 = EEPROM address for the pin we will eventually write
                      05013 ;   R5 = pin mask, either 0x8F or 0xF8 (or 0F...)
                      05014 
001B54 D95E           05015             rcall   dup_delete
                      05016 
                      05017 ;install the new pin number in the correct place
                      05018 ;R3 = new pin number, replicated into both nibbles
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 76
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      05019 ;R4 = EEPROM address for the particular pin we are writing
                      05020 ;R5 = nibble mask for the particular pin we are writing
001B56 1C12           05021             comf    R5,W,0              ;get new pin number in correct nibble
001B58 1610           05022             andwf   R3,F,0              ;..by stripping off the other nibble
                      05023 
001B5A 5011           05024             movf    R4,W,0              ;restore pin-pair address
001B5C EC19 F000      05025             call    K_RDEEPROM          ;get 2 pin definitions
001B60 1412           05026             andwf   R5,W,0              ;strip old pin number for the one we are changing
                      05027 
001B62 D141           05028             bra     binstall_r3         ;Combine W and R3, install into
                      05029                                         ;..EEPROM register, and return 
                      05030 
                      05031 ;*******------------------------------------------------------------------------*
                      05032 ;* OEN *  Custom EPROM Editor Command: assign pin number to -OE signal
                      05033 ;*******
                      05034 ; On Entry:
                      05035 ;   FSR1 points to the rest of the command line from the user
                      05036 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05037 ; Note: The -OE signal may be assigned to the same pin as the Vpp signal. In this
                      05038 ; case, it is not necessary to check for other signal-pin conflicts because they
                      05039 ; would have been checked when Vpp was assigned.
                      05040 ; Note also that the -OE signal may be programmed to be at +12V during
                      05041 ; programming, ony if it is assigned to pin 19 or 20 (hardware limitation).
                      05042 ; When -OE is assigned to a pin, this feature is cleared.
                      05043 ; See comment at assignp for exit details
                      05044 ;-------------------------------------------------------------------------------*
001B64 D986           05045 ecmd_oen:   rcall   get_pin             ;get W=R3=new -OE pin number from user
                      05046 
                      05047 ;See if this new pin is also assigned to PGM, which is allowed.
001B66 0E1A           05048             movlw   ET_PGMVPP           ;Is this new -OE pin the same as PGM pin?
001B68 DEAC           05049             rcall   etype_getval        ;get OEN & CS pin assignment in W and R0
001B6A 6E0E           05050             movwf   R1,0                ;temp save
                      05051 
001B6C 380D           05052             swapf   R0,W,0              ;put PGM pins in <2:0>
001B6E 1810           05053             xorwf   R3,W,0              ;-OE pin same as our new Vpp pin?
001B70 0B07           05054             andlw   0x07                ;just the right pin bits
001B72 E009           05055             bz      eoen_same           ;y: no need to hunt for matches
                      05056 
                      05057 ;This new -OE pin number is not the same as the existing PGM pin number.
                      05058 ;Is it the same as  the VPP pin? This is also allowed.
001B74 500E           05059             movf    R1,0                ;VPP pin number in 2:0
001B76 1810           05060             xorwf   R3,W,0              ;VPP pin same as our new CS pin?
001B78 0B07           05061             andlw   0x07                ;just the right pin bits
001B7A E005           05062             bz      eoen_same           ;y: no need to hunt for matches
                      05063 
                      05064 ;This new -OE pin number is not the same as the existing Vpp pin number either.
001B7C 0E19           05065             movlw   ET_OECS
001B7E DEAC           05066             rcall   etype_lookup        ;set EEADR for -OE and CS pin assignment
                      05067 
001B80 0E0F           05068             movlw   0x0F                ;mask for -OE pin number (clears +12V bit too.)
001B82 6E12           05069             movwf   R5,0                ;R5=pin mask
                      05070 
001B84 D7E5           05071             bra     assignp             ;check for duplicates, and assign
                      05072 
                      05073 ;The new -OE pin is the same as either PGM or Vpp, so no need to check for conflicts
001B86 0E19           05074 eoen_same:  movlw   ET_OECS
001B88 DE9C           05075             rcall   etype_getval        ;get -OE and CS pin assignment
001B8A 0B0F           05076             andlw   0x0F                ;strip old -OE assignmemt and +12V bit
001B8C 3A10           05077             swapf   R3,F,0              ;put new pin number in high nibble
                      05078 
001B8E D12B           05079             bra     binstall_r3         ;Combine W and R3, install into
                      05080                                         ;..EEPROM register, and return 
                      05081 
                      05082 ;******-------------------------------------------------------------------------*
                      05083 ;* CS *  Custom EPROM Editor Command: assign pin number to CS signal
                      05084 ;******
                      05085 ; On Entry:
                      05086 ;   FSR1 points to the rest of the command line from the user
                      05087 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05088 ; See comment at assignp for exit details
                      05089 ;-------------------------------------------------------------------------------*
001B90 D970           05090 ecmd_cs:    rcall   get_pin             ;get W=R3=new CS pin number from user
                      05091 
                      05092 ;See if this new pin is also assigned to PGM, which is allowed.
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 77
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001B92 0E1A           05093             movlw   ET_PGMVPP           ;Is this new CS pin the same as PGM pin?
001B94 DE96           05094             rcall   etype_getval        ;get OEN & CS pin assignment in W and R0
001B96 6E0E           05095             movwf   R1,0                ;temp save
                      05096 
001B98 380D           05097             swapf   R0,W,0              ;put PGM pins in <2:0>
001B9A 1810           05098             xorwf   R3,W,0              ;CS pin same as our new Vpp pin?
001B9C 0B07           05099             andlw   0x07                ;just the right pin bits
001B9E E009           05100             bz      ecs_same            ;y: no need to hunt for matches
                      05101 
                      05102 ;This new CS pin number is not the same as the existing PGM pin number.
                      05103 ;Is it the same as  the VPP pin? This is also allowed.
001BA0 500E           05104             movf    R1,0                ;VPP pin number in 2:0
001BA2 1810           05105             xorwf   R3,W,0              ;VPP pin same as our new CS pin?
001BA4 0B07           05106             andlw   0x07                ;just the right pin bits
001BA6 E005           05107             bz      ecs_same            ;y: no need to hunt for matches
                      05108 
                      05109 ;This new CS pin number is not the same as the existing Vpp pin number either.
001BA8 0E19           05110             movlw   ET_OECS
001BAA DE96           05111             rcall   etype_lookup        ;set EEADR for -OE and CS pin assignment
                      05112 
001BAC 0EF8           05113             movlw   0xF8                ;low-nibble mask
001BAE 6E12           05114             movwf   R5,0                ;R5=pin mask
                      05115 
001BB0 D7CF           05116             bra     assignp             ;check for duplicates, and assign
                      05117 
                      05118 ;The new CS pin is the same as either PGM or Vpp, so no need to check for conflicts
001BB2 0E19           05119 ecs_same:   movlw   ET_OECS
001BB4 DE86           05120             rcall   etype_getval        ;set EEADR for -OE and CS pin assignment
001BB6 0BF8           05121             andlw   0xF8                ;remove old CS pin number
                      05122 
001BB8 D116           05123             bra     binstall_r3         ;Combine W and R3, install into
                      05124                                         ;..EEPROM register, and return 
                      05125 
                      05126 ;*******------------------------------------------------------------------------*
                      05127 ;* CSP * Custom EPROM Editor Command: Define CS signal polarity
                      05128 ;*******
                      05129 ; On Entry:
                      05130 ;   FSR1 points to the rest of the command line from the user
                      05131 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05132 ;-------------------------------------------------------------------------------*
001BBA 0E19           05133 ecmd_csp:   movlw   ET_OECS
001BBC DE82           05134             rcall   etype_getval        ;get -OE and CS pin assignment
                      05135 
001BBE 0BF7           05136             andlw   0xF7                ;strip old CS polarity assignmemt
001BC0 6E10           05137             movwf   R3,0                ;temp save
                      05138 
001BC2 0E01           05139             movlw   0x01                ;allow only allow 0-1
001BC4 D91A           05140             rcall   ee_getdec           ;result in W & R0, trash R1, set Z if exactly max
                      05141 
001BC6 B4D8           05142             btfsc   STATUS,Z,0          ;was value 0?
001BC8 8610           05143             bsf     R3,0x03,0           ;n: set bit for positive polarity
                      05144 
001BCA D10E           05145             bra     install_r3          ;install R3 into EEPROM register and return 
                      05146 
                      05147 ;*******------------------------------------------------------------------------*
                      05148 ;* PGM * Custom EPROM Editor Command: assign pin number to PGM signal
                      05149 ;*******
                      05150 ; On Entry:
                      05151 ;   FSR1 points to the rest of the command line from the user
                      05152 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05153 ; See comment at assignp for exit details
                      05154 ;------------------------------------------------------------------------------*
001BCC D952           05155 ecmd_pgm:   rcall   get_pin             ;get W=R3=new PGM pin number from user
                      05156 
                      05157 ;See if this new pin is also assigned to OEN, which is allowed.
001BCE 0E19           05158             movlw   ET_OECS             ;Is this new PGM pin the same as OEN pin?
001BD0 DE78           05159             rcall   etype_getval        ;get OEN & CS pin assignment in W and R0
001BD2 6E0E           05160             movwf   R1,0                ;temp save
                      05161 
001BD4 380D           05162             swapf   R0,W,0              ;put OEN pins in <2:0>
001BD6 1810           05163             xorwf   R3,W,0              ;OEN pin same as our new PGM pin?
001BD8 0B07           05164             andlw   0x07                ;just the right pin bits
001BDA E009           05165             bz      epgm_same           ;y: no need to hunt for matches
                      05166 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 78
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      05167 ;This new PGM pin number is not the same as the existing OEN pin number.
                      05168 ;Is it the same as  the CS pin? This is also allowed.
001BDC 500E           05169             movf    R1,0                ;CS pin number in 2:0
001BDE 1810           05170             xorwf   R3,W,0              ;CS pin same as our new PGM pin?
001BE0 0B07           05171             andlw   0x07                ;just the right pin bits
001BE2 E005           05172             bz      epgm_same           ;y: no need to hunt for matches
                      05173 
                      05174 ;This new PGM pin number is not the same as the existing -OE or CS pin number.
001BE4 0E1A           05175             movlw   ET_PGMVPP
001BE6 DE78           05176             rcall   etype_lookup        ;set EEADR for PGM & Vpp pin assignment
001BE8 0E8F           05177             movlw   0x8F                ;mask for PGM pin number
001BEA 6E12           05178             movwf   R5,0                ;in place for assignp
                      05179 
001BEC D7B1           05180             bra     assignp             ;go install pin         
                      05181 
                      05182 ;This new PGM pin number matches the existing -OE or CS pin number, which is allowed.
001BEE 0E1A           05183 epgm_same:  movlw   ET_PGMVPP
001BF0 DE68           05184             rcall   etype_getval        ;set EEADR for PGM & Vpp pin assignment
001BF2 0B8F           05185             andlw   0x8F                ;remove old PGM pin number
                      05186 
001BF4 D0F8           05187             bra     binstall_r3         ;Combine W and R3, install into
                      05188                                         ;..EEPROM register, and return 
                      05189             
                      05190 ;*******------------------------------------------------------------------------*
                      05191 ;* PGP * Custom EPROM Editor Command: Define PGM signal polarity
                      05192 ;*******
                      05193 ; On Entry:
                      05194 ;   FSR1 points to the rest of the command line from the user
                      05195 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05196 ;-------------------------------------------------------------------------------*
001BF6 0E1A           05197 ecmd_pgp:   movlw   ET_PGMVPP
001BF8 DE64           05198             rcall   etype_getval        ;get PGM & Vpp pin assignment
                      05199 
001BFA 0B7F           05200             andlw   0x7F                ;strip old Vpp pin polarity assignmemt
001BFC 6E10           05201             movwf   R3,0                ;temp save
001BFE 0E01           05202             movlw   0x01
001C00 D8FC           05203             rcall   ee_getdec           ;result in W & R0, trash R1, Z set if exactly max
                      05204 
001C02 B4D8           05205             btfsc   STATUS,Z,0          ;was value 0?
001C04 8E10           05206             bsf     R3,0x07,0           ;n: set bit for positive polarity
                      05207 
001C06 D0F0           05208             bra     install_r3          ;install R3 into EEPROM register and return 
                      05209 
                      05210 ;*******------------------------------------------------------------------------*
                      05211 ;* PPP * Custom EPROM Editor Command: assign pin number to Vpp signal
                      05212 ;*******
                      05213 ; On Entry:
                      05214 ;   FSR1 points to the rest of the command line from the user
                      05215 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05216 ; Note 1: Vpp may only be assigned to pins 18, 20, and 21. Attempting to
                      05217 ;   assign it to another pin will generate an error message instead.
                      05218 ; Note 2: The -OE signal or the CS signal may be assigned to the same pin as the
                      05219 ; Vpp signal. In these cases, it is not necessary to check for other signal-pin
                      05220 ; conflicts because they would have been checked when -OE was assigned.
                      05221 ; Note 3: the -OE signal may be programmed to be at +12V during programming,
                      05222 ;   but not if it is also the Vpp pin. If we are assigning Vpp to be on the same
                      05223 ;   pin as -OEN, then clear the flag that sets -OE to +12V during programming.
                      05224 ;   .
                      05225 ; When -OE is assigned to a pin, this feature is cleared.
                      05226 ;-------------------------------------------------------------------------------*
001C08 D934           05227 ecmd_ppp:   rcall   get_pin             ;get W=R3=new Vpp pin number from user
                      05228 
                      05229 ;Vpp may not be on pins 19, 22, or 23. (R2 values 2, 5, 6) due to hardware limitations
001C0A 0A02           05230             xorlw   0x02                ;pin 19?
001C0C E01C           05231             bz      ppp_err
001C0E 0E05           05232             movlw   0x05
001C10 5C10           05233             subwf   R3,W,0
001C12 E219           05234             bc      ppp_err         
                      05235 
                      05236 ;See if this new pin is also assigned to -OE, which is allowed.
001C14 0E19           05237             movlw   ET_OECS             ;Is this new Vpp pin the same as OEN pin?
001C16 DE55           05238             rcall   etype_getval        ;get OEN & CS pin assignment in W and R0
                      05239                                         ;..also sets EEADR to ET_OECS
                      05240 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 79
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001C18 6E0E           05241             movwf   R1,0                ;temp save
                      05242 
001C1A 380D           05243             swapf   R0,W,0              ;put OEN pins in <2:0>
001C1C 1810           05244             xorwf   R3,W,0              ;OEN pin same as our new Vpp pin?
001C1E 0B07           05245             andlw   0x07                ;just the right pin bits
001C20 E009           05246             bz      evppoe_sam          ;y: no need to hunt for matches
                      05247 
                      05248 ;This new Vpp pin number is not the same as the existing -OE pin number.
                      05249 ;Is it the same as  the CS pin? This is also allowed.
001C22 500E           05250             movf    R1,0                ;CS pin number in 2:0
001C24 1810           05251             xorwf   R3,W,0              ;CS pin same as our new Vpp pin?
001C26 0B07           05252             andlw   0x07                ;just the right pin bits
001C28 E00A           05253             bz      evpp_same           ;y: no need to hunt for matches
                      05254 
                      05255 ;This new Vpp pin number is not the same as the existing -OE or CS pin number.
001C2A 0E1A           05256             movlw   ET_PGMVPP
001C2C DE55           05257             rcall   etype_lookup        ;set EEADR for PGM & Vpp pin assignment
001C2E 0EF8           05258             movlw   0xF8                ;mask for Vpp pin number
001C30 6E12           05259             movwf   R5,0                ;in place for assignp
                      05260 
001C32 D78E           05261             bra     assignp             ;go install pin         
                      05262 
                      05263 ;This new Vpp pin number matches the existing -OE pin number, which is allowed.
001C34 500D           05264 evppoe_sam: movf    R0,W,0              ;-OE signal can't also be 12V during programming
001C36 0B7F           05265             andlw   0x7F                ;...so clear that flag
001C38 BE0D           05266             btfsc   R0,0x07,0           ;..unless it was already cleared
001C3A EC1A F000      05267             call    K_WREEPROM          ;EEADR = ET_OECS
                      05268             
                      05269 ;This new Vpp pin number matches the existing -OE  or CS pin number, which is allowed.
001C3E 0E1A           05270 evpp_same:  movlw   ET_PGMVPP
001C40 DE40           05271             rcall   etype_getval        ;set EEADR for PGM & Vpp pin assignment
001C42 0BF8           05272             andlw   0xF8                ;remove old Vpp pin number
                      05273 
001C44 D0D0           05274             bra     binstall_r3         ;Combine W and R3, install into
                      05275                                         ;..EEPROM register, and return 
                      05276 
                      05277 ;The user is trying to put Vpp on a pin that can't be supported by the hardware
001C46 EE07 F04A      05278 ppp_err:    lfsr    0,novpp_msg-sstrings
001C4A D2E0           05279             bra     cr_hprintf
                      05280 
                      05281 ;*******------------------------------------------------------------------------*
                      05282 ;* VCP * Custom EPROM Editor Command: Define Vcc programming voltage
                      05283 ;*******
                      05284 ; On Entry:
                      05285 ;   FSR1 points to the rest of the command line from the user
                      05286 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05287 ;-------------------------------------------------------------------------------*
001C4C 0E1B           05288 ecmd_vcp:   movlw   ET_VBBVDD
001C4E DE39           05289             rcall   etype_getval        ;get Vbb & Vdd & Vcc setup
001C50 0BF8           05290             andlw   0xF8                ;strip off old Vcc setup
001C52 6E10           05291             movwf   R3,0                ;temp save
                      05292 
001C54 0E03           05293             movlw   0x03                ;allow only allow 0-3
001C56 D8D1           05294             rcall   ee_getdec           ;result in W & R0, trash R1
                      05295 
001C58 D0C6           05296             bra     binstall_r3         ;Combine W and R3, install into
                      05297                                         ;..EEPROM register, and return 
                      05298 
                      05299 ;*******------------------------------------------------------------------------*
                      05300 ;* OEV * Custom EPROM Editor Command: Define -OE programming voltage
                      05301 ;*******
                      05302 ; OE may be set to +12V during programming only if it is on pin 19 or 20
                      05303 ; On Entry:
                      05304 ;   FSR1 points to the rest of the command line from the user
                      05305 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05306 ; Note: the -OE signal may be programmed to be at +12V during programming,
                      05307 ;   but not if it is also the Vpp pin. If -OE is currently assigned to the same
                      05308 ;   pin as Vpp then exit with an error message.
                      05309 ;-------------------------------------------------------------------------------*
001C5A 0E1A           05310 ecmd_oev:   movlw   ET_PGMVPP           ;for testing if Vpp pin= -OE pin
001C5C 6E11           05311             movwf   R4,0                ;temp save
                      05312 
001C5E 0E19           05313             movlw   ET_OECS
001C60 DE30           05314             rcall   etype_getval        ;get -OE and CS pin assignment
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 80
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      05315                                         ;..and set EEADR to ET_OECS
                      05316 
001C62 0B7F           05317             andlw   0x7F                ;strip old -OE voltage assignmemt
001C64 6E10           05318             movwf   R3,0                ;temp save
                      05319 
001C66 0E01           05320             movlw   0x01                ;allow only allow 0-1
001C68 D8C8           05321             rcall   ee_getdec           ;result in W & R0, trash R1, Z set if exactly max
001C6A E10A           05322             bnz     oev_ok              ;always okay if turning feature off
                      05323 
001C6C 3810           05324             swapf   R3,W,0              ;look at the -OE pin number
001C6E 1811           05325             xorwf   R4,W,0              ;compare to Vpp pin number
001C70 0B07           05326             andlw   0x07                ;just the pin bits
001C72 E00E           05327             bz      oev_vpperr          ;y: can't also be +12V
                      05328 
                      05329 ;Is OE on pin 19 or 20 (encoded as 2 or 3)? if not, hardware can't set it to 12V
001C74 3810           05330             swapf   R3,W,0
001C76 0B07           05331             andlw   0x07                ;just the OEN pin number
001C78 0FFE           05332             addlw   0xFE                ;subtract 2
001C7A E002           05333             bz      oev_ok
001C7C 0FFF           05334             addlw   0xFF                ;subtract 1
001C7E E104           05335             bnz     oev_pnerr           
                      05336 
                      05337 ;All ok: set bit for +12V -OE programming voltage
001C80 8E10           05338 oev_ok:     bsf     R3,0x07,0
001C82 5010           05339             movf    R3,W,0
001C84 EF1A F000      05340             goto    K_WREEPROM          ;put it back at ET_OECS, return
                      05341 
                      05342 ;The user has requested +12V OE on a pin the hardware can't support
001C88 EE07 F078      05343 oev_pnerr:  lfsr    0,oeverr_msg-sstrings
001C8C EF02 F00A      05344             goto        cr_printf
                      05345 
                      05346 ;The user is attempting to set -OE to +12V when it is also assigned to be Vpp
001C90 EE07 F0AE      05347 oev_vpperr: lfsr    0,oevperr_msg-sstrings
001C94 EF02 F00A      05348             goto        cr_printf
                      05349 
                      05350 ;*******------------------------------------------------------------------------*
                      05351 ;* VPP * Custom EPROM Editor Command: Define Vpp programming voltage
                      05352 ;*******
                      05353 ; On Entry:
                      05354 ;   FSR1 points to the rest of the command line from the user
                      05355 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05356 ;-------------------------------------------------------------------------------*
001C98 0E1C           05357 ecmd_vpp:   movlw   ET_VPPSETUP
001C9A DE13           05358             rcall   etype_getval        ;get current Vpp setup
                      05359 
001C9C 0B8F           05360             andlw   0x8F                ;strip off old Vpp setting
001C9E 6E10           05361             movwf   R3,0                ;temp save
                      05362 
001CA0 0E05           05363             movlw   0x05                ;allow only allow 0-5
001CA2 D8AB           05364             rcall   ee_getdec           ;result in W & R0, trash R1
                      05365 
001CA4 380D           05366             swapf   R0,W,0              ;value in place
                      05367 
001CA6 D09F           05368             bra     binstall_r3         ;Combine W and R3, install into
                      05369                                         ;..EEPROM register, and return 
                      05370 
                      05371 ;*******------------------------------------------------------------------------*
                      05372 ;* VPR * Custom EPROM Editor Command: Define Vpp read voltage
                      05373 ;*******
                      05374 ; On Entry:
                      05375 ;   FSR1 points to the rest of the command line from the user
                      05376 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05377 ;-------------------------------------------------------------------------------*
001CA8 0E1C           05378 ecmd_vpr:   movlw   ET_VPPSETUP
001CAA DE0B           05379             rcall   etype_getval        ;get current Vpp etc. setup
                      05380 
001CAC 0BFB           05381             andlw   0xFB                ;strip off old read-Vpp setting
001CAE 6E10           05382             movwf   R3,0                ;temp save
                      05383 
001CB0 0E01           05384             movlw   0x01                ;allow only allow 0-1
001CB2 D8A3           05385             rcall   ee_getdec           ;result in W & R0, trash R1, Z set if exactly max
                      05386 
001CB4 B4D8           05387             btfsc   STATUS,Z,0          ;was value 0?
001CB6 8410           05388             bsf     R3,0x02,0           ;n: set bit for +5V read Vpp
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 81
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      05389 
001CB8 D097           05390             bra     install_r3          ;install R3 into EEPROM register and return 
                      05391 
                      05392 ;*******------------------------------------------------------------------------*
                      05393 ;* BCK * Custom EPROM Editor Command: disable/enable blank check
                      05394 ;*******
                      05395 ; On Entry:
                      05396 ;   FSR1 points to the rest of the command line from the user
                      05397 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05398 ;-------------------------------------------------------------------------------*
001CBA 0E22           05399 ecmd_bck:   movlw   ET_SPECIAL
001CBC DE02           05400             rcall   etype_getval        ;get various programming details
                      05401 
001CBE 0BF7           05402             andlw   0xF7                ;strip old CS blank-check requirement
001CC0 6E10           05403             movwf   R3,0                ;temp save
                      05404 
001CC2 0E01           05405             movlw   0x01                ;allow only allow 0-1
001CC4 D89A           05406             rcall   ee_getdec           ;result in W & R0, trash R1, set Z if exactly max
                      05407 
001CC6 A4D8           05408             btfss   STATUS,Z,0          ;was value 1?
001CC8 8610           05409             bsf     R3,0x03,0           ;n: set bit for no blank check
                      05410 
001CCA D08E           05411             bra     install_r3          ;install R3 into EEPROM register and return 
                      05412 
                      05413 ;*******------------------------------------------------------------------------*
                      05414 ;* COP * Custom EPROM Editor Command: Copy EPROM
                      05415 ;*******
                      05416 ; On Entry:
                      05417 ;   FSR1 points to the rest of the command line from the user
                      05418 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05419 ; Trashes W,R0-R5,FSR0
                      05420 ;-------------------------------------------------------------------------------*
001CCC 900C           05421 ecmd_copy:      bcf     KERN_FLAGS,ERR_FLAG,0   ;no hex errors yet
001CCE EC14 F000      05422                 call    K_GETHEX4               ;Get source etype in R2:R1
001CD2 B00C           05423                 btfsc   KERN_FLAGS,ERR_FLAG,0   ;hex errors?
001CD4 D09B           05424 ec_bogus:       bra     ecmd_error
                      05425 
001CD6 520F           05426                 movf    R2,F,0                  ;no high byte allowed
001CD8 E1FD           05427                 bnz     ec_bogus
                      05428 
001CDA 0E1C           05429                 movlw   ETYPE
001CDC EC19 F000      05430                 call    K_RDEEPROM
001CE0 6E11           05431                 movwf   R4,0                    ;remember destination EPROM type
                      05432 
001CE2 500E           05433                 movf    R1,W,0                  ;source etype from user
001CE4 6E12           05434                 movwf   R5,0                    ;save source etype
                      05435 
001CE6 EC1A F000      05436                 call    K_WREEPROM              ;EEADR still points to ETYPE
001CEA 0E00           05437                 movlw   ET_NAME                 ;check for valid source
001CEC EC61 F00C      05438                 call    etype_getval            ;first chr of the name=0 means invalid entry
001CF0 0900           05439                 iorlw   0x00
001CF2 E01D           05440                 bz      ecopy_error             ;not a valid EPROM type
                      05441 
                      05442 ;Copy the requsted EPROM specs to the custom EPROM currently being edited
                      05443 ; R4 = destination EPROM
                      05444 ; R5 = source EPROM
                      05445 
001CF4 0E16           05446                 movlw   ET_BYTES                ;first item to copy
001CF6 6E10           05447                 movwf   R3,0
                      05448 
001CF8 0E1C           05449 ecopy_loop:         movlw   ETYPE               ;point to source byte
001CFA 6EA9           05450                     movwf   EEADR,0
001CFC 5012           05451                     movf    R5,W,0
001CFE EC1A F000      05452                     call    K_WREEPROM
                      05453 
001D02 5010           05454                     movf    R3,W,0              ;get this particular value
001D04 DDDE           05455                     rcall   etype_getval
001D06 6E0F           05456                     movwf   R2,0
                      05457 
001D08 0E1C           05458                     movlw   ETYPE               ;point to dest byte
001D0A 6EA9           05459                     movwf   EEADR,0
001D0C 5011           05460                     movf    R4,W,0
001D0E EC1A F000      05461                     call    K_WREEPROM
                      05462 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 82
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001D12 5010           05463                     movf    R3,W,0              ;this particular value
001D14 DDE1           05464                     rcall   etype_lookup
001D16 500F           05465                     movf    R2,W,0
001D18 EC1A F000      05466                     call    K_WREEPROM
                      05467 
001D1C 2A10           05468                     incf    R3,F,0
001D1E 0E24           05469                     movlw   ET_RLENGTH
001D20 1810           05470                     xorwf   R3,W,0
001D22 E1EA           05471                     bnz     ecopy_loop
                      05472 
                      05473 ;No manual voltage adjustment messages for custom EPROMS
001D24 0E22           05474                 movlw   ET_SPECIAL
001D26 DDCD           05475                 rcall   etype_getval
001D28 0BF8           05476                 andlw   0xF8
001D2A EF1A F000      05477                 goto    K_WREEPROM          ;return from there  
                      05478 
                      05479 ;Non-existent EPROM type
001D2E 0E1C           05480 ecopy_error:    movlw   ETYPE               ;restore EPROM type
001D30 6EA9           05481                 movwf   EEADR,0
001D32 5011           05482                 movf    R4,W,0
001D34 EC1A F000      05483                 call    K_WREEPROM
                      05484 
001D38 EE03 F068      05485                 lfsr    0,undef_msg-sstrings
001D3C EF02 F00A      05486                 goto    cr_printf
                      05487 
                      05488 ;*******------------------------------------------------------------------------*
                      05489 ;* FF1 * Custom EPROM Editor Command: disable/enable EEPROM write FF (erase)
                      05490 ;*******
                      05491 ; On Entry:
                      05492 ;   FSR1 points to the rest of the command line from the user
                      05493 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05494 ;-------------------------------------------------------------------------------*
001D40 0E20           05495 ecmd_ff1:   movlw   ET_SMART1
001D42 DDBF           05496             rcall   etype_getval        ;get previous value
                      05497 
001D44 0BF7           05498             andlw   0xF7                ;strip old  spec
001D46 6E10           05499             movwf   R3,0                ;temp save
                      05500 
001D48 0E01           05501             movlw   0x01                ;allow only allow 0-1
001D4A D857           05502             rcall   ee_getdec           ;result in W & R0, trash R1, set Z if exactly max
                      05503 
001D4C B4D8           05504             btfsc   STATUS,Z,0          ;was value 1?
001D4E 8610           05505             bsf     R3,0x03,0           ;y: set bit for EEPROM ersase
                      05506 
001D50 D04B           05507             bra     install_r3          ;install R3 into EEPROM register and return 
                      05508 
                      05509 ;*******------------------------------------------------------------------------*
                      05510 ;* PUL * Custom EPROM Editor Command: Define programming pulse signal
                      05511 ;*******
                      05512 ; On Entry:
                      05513 ;   FSR1 points to the rest of the command line from the user
                      05514 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05515 ;-------------------------------------------------------------------------------*
001D52 0E1C           05516 ecmd_pul:   movlw   ET_VPPSETUP
001D54 DDB6           05517             rcall   etype_getval        ;get current Vpp setup
                      05518 
001D56 0BFC           05519             andlw   0xFC                ;strip off old programing pulse setting
001D58 6E10           05520             movwf   R3,0                ;temp save
                      05521 
001D5A 0E02           05522             movlw   0x02                ;allow only allow 0-2
001D5C D84E           05523             rcall   ee_getdec           ;result in W & R0, trash R1
                      05524 
001D5E D043           05525             bra     binstall_r3         ;Combine W and R3, install into
                      05526                                         ;..EEPROM register, and return 
                      05527 
                      05528 ;*******------------------------------------------------------------------------*
                      05529 ;* PTU * Custom EPROM Editor Command: Define programming pulse time units
                      05530 ;*******
                      05531 ; On Entry:
                      05532 ;   FSR1 points to the rest of the command line from the user
                      05533 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05534 ;-------------------------------------------------------------------------------*
001D60 0E01           05535 ecmd_ptu:   movlw   0x01                ;allow only allow 0-1
001D62 D84B           05536             rcall   ee_getdec           ;result in W & R0, trash R1
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 83
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001D64 6E10           05537             movwf   R3,0
                      05538 
                      05539 ;Set the multiplier for the programming pulse
001D66 0E1E           05540             movlw   ET_PROGPULSE
001D68 DDAC           05541             rcall   etype_getval        ;get current programming pulse
001D6A 0B7F           05542             andlw   0x7F                ;remove old multiplier
001D6C B010           05543             btfsc   R3,0x00,0           ;multiply by 100?
001D6E 0980           05544             iorlw   0x80                ;y: set the bit
                      05545 
001D70 EC1A F000      05546             call    K_WREEPROM          ;and put ET_PROGPULSE back
                      05547 
                      05548 ;Set the multiplier for the delay between pulses
001D74 0E1F           05549             movlw   ET_PPDELAY
001D76 DDA5           05550             rcall   etype_getval        ;get current programming pulse
001D78 0B7F           05551             andlw   0x7F                ;remove old multip[lier
001D7A B010           05552             btfsc   R3,0x00,0           ;multiply by 100?
001D7C 0980           05553             iorlw   0x80                ;y: set the bit
                      05554 
001D7E EF1A F000      05555             goto    K_WREEPROM          ;put ET_PPDELAY back and go to main
                      05556 
                      05557 ;*******------------------------------------------------------------------------*
                      05558 ;* PPW * Custom EPROM Editor Command: Define programming pulse width
                      05559 ;*******
                      05560 ; On Entry:
                      05561 ;   FSR1 points to the rest of the command line from the user
                      05562 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05563 ;-------------------------------------------------------------------------------*
001D82 0E1E           05564 ecmd_ppw:   movlw   ET_PROGPULSE
                      05565 
001D84 DD9E           05566             rcall   etype_getval        ;get current separation pulse
001D86 0B80           05567             andlw   0x80                ;save old multiplier
001D88 6E10           05568             movwf   R3,0
                      05569 
001D8A 0E7F           05570             movlw   0x7F                ;allow only allow 0-127
001D8C D836           05571             rcall   ee_getdec           ;result in W & R0, trash R1
                      05572 
001D8E D02B           05573             bra     binstall_r3         ;Combine W and R3, install into
                      05574                                         ;..EEPROM register, and return 
                      05575 
                      05576 ;*******------------------------------------------------------------------------*
                      05577 ;* PPS * Custom EPROM Editor Command: Define programming pulse separation
                      05578 ;*******
                      05579 ; On Entry:
                      05580 ;   FSR1 points to the rest of the command line from the user
                      05581 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05582 ;-------------------------------------------------------------------------------*
001D90 0E1F           05583 ecmd_pps:   movlw   ET_PPDELAY
                      05584 
001D92 DD97           05585             rcall   etype_getval        ;get current separation pulse
001D94 0B80           05586             andlw   0x80                ;save old multiplier
001D96 6E10           05587             movwf   R3,0
                      05588 
001D98 0E7F           05589             movlw   0x7F                ;allow only allow 0-127
001D9A D82F           05590             rcall   ee_getdec           ;result in W & R0, trash R1
                      05591 
001D9C 5210           05592             movf    R3,F,0              ;uS?
001D9E E105           05593             bnz     pps_save            ;n: all values allowed for mS
                      05594     
001DA0 0804           05595             sublw   0x04                ;min uS value is 4
001DA2 500D           05596             movf    R0,W,0              ;also tests for 0 without messing up C
001DA4 E002           05597             bz      pps_save            ;0 is allowed
001DA6 B0D8           05598             btfsc   STATUS,C,0          ;carry set if too small
001DA8 0E04           05599             movlw   0x04                ;just make it a bit bigger
                      05600 
001DAA D01D           05601 pps_save:   bra     binstall_r3         ;Combine W and R3, install into
                      05602                                         ;..EEPROM register, and return 
                      05603 
                      05604 ;*******------------------------------------------------------------------------*
                      05605 ;* POL * Custom EPROM Editor Command: select EEPROM-style competion polling
                      05606 ;*******
                      05607 ; On Entry:
                      05608 ;   FSR1 points to the rest of the command line from the user
                      05609 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05610 ;-------------------------------------------------------------------------------*
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 84
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001DAC 0E1F           05611 ecmd_pol:   movlw   ET_PPDELAY      ;overwrites separation pulse
001DAE DD94           05612             rcall   etype_lookup
001DB0 0E01           05613             movlw   0x01            ;specifies polling
001DB2 EF1A F000      05614             goto    K_WREEPROM
                      05615 
                      05616 ;*******------------------------------------------------------------------------*
                      05617 ;* SPA * Custom EPROM Editor Command: Specify simple programming algorithm
                      05618 ;*******
                      05619 ; On Entry:
                      05620 ;   FSR1 points to the rest of the command line from the user
                      05621 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05622 ;-------------------------------------------------------------------------------*
001DB6 0E20           05623 ecmd_spa:   movlw   ET_SMART1
001DB8 DD8F           05624             rcall   etype_lookup
001DBA 0E00           05625             movlw   0x00                ;clear this for simple algorithm
001DBC EF1A F000      05626             goto    K_WREEPROM          ;put it back and go to main
                      05627 
                      05628 ;*******------------------------------------------------------------------------*
                      05629 ;* FP1 * Custom EPROM Editor Command: Define fast-programming phase 1
                      05630 ;*******
                      05631 ; On Entry:
                      05632 ;   FSR1 points to the rest of the command line from the user
                      05633 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05634 ;-------------------------------------------------------------------------------*
001DC0 0E20           05635 ecmd_fp1:   movlw   ET_SMART1
001DC2 D001           05636             bra     ecmd_fp12           ;reuse code
                      05637 
                      05638 ;*******------------------------------------------------------------------------*
                      05639 ;* FP2 * Custom EPROM Editor Command: Define fast-programming phase 2
                      05640 ;*******
                      05641 ; On Entry:
                      05642 ;   FSR1 points to the rest of the command line from the user
                      05643 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05644 ;-------------------------------------------------------------------------------*
001DC4 0E21           05645 ecmd_fp2:   movlw   ET_SMART2
                      05646 
                      05647 ;Fall into ecmd_fp12
                      05648 
                      05649 ;-------------------------------------------------------------------------------*
                      05650 ; Local subroutine to install new smart programming algorithm bit
                      05651 ; On Entry:
                      05652 ;   W=bit mask for algorithm bit
                      05653 ;-------------------------------------------------------------------------------*
001DC6 DD7D           05654 ecmd_fp12:  rcall   etype_getval
001DC8 0B0F           05655             andlw   0x0F                ;strip off old value
001DCA 6E10           05656             movwf   R3,0                ;temp save
                      05657 
001DCC 0E04           05658             movlw   0x04                ;allow only allow 0-4
001DCE D815           05659             rcall   ee_getdec           ;result in W & R0, trash R1, Z set if exactly max
                      05660 
001DD0 380D           05661             swapf   R0,W,0              ;put result in bits <6:4>
001DD2 0980           05662             iorlw   0x80                ;set msb so it's not SPA
                      05663 
001DD4 D008           05664             bra     binstall_r3         ;Combine W and R3, install into
                      05665                                         ;..EEPROM register, and return 
                      05666 
                      05667 ;*******------------------------------------------------------------------------*
                      05668 ;* FN1 * Custom EPROM Editor Command: Define n for fast-programming phase 1
                      05669 ;*******
                      05670 ; On Entry:
                      05671 ;   FSR1 points to the rest of the command line from the user
                      05672 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05673 ;-------------------------------------------------------------------------------*
001DD6 0E20           05674 ecmd_fn1:   movlw   ET_SMART1
001DD8 D001           05675             bra     ecmd_fn12           ;common code
                      05676 
                      05677 ;*******------------------------------------------------------------------------*
                      05678 ;* FN2 * Custom EPROM Editor Command: Define n for fast-programming phase 2
                      05679 ;*******
                      05680 ; On Entry:
                      05681 ;   FSR1 points to the rest of the command line from the user
                      05682 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05683 ;-------------------------------------------------------------------------------*
001DDA 0E21           05684 ecmd_fn2:   movlw   ET_SMART2
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 85
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      05685 
                      05686 ;Fall into ecmd_fn12
                      05687 
                      05688 ;-------------------------------------------------------------------------------*
                      05689 ; Local subroutine to get and install a new n value for the smart algorithm
                      05690 ;-------------------------------------------------------------------------------*
001DDC DD72           05691 ecmd_fn12:  rcall   etype_getval
001DDE 0BF8           05692             andlw   0xF8                ;strip off old value
001DE0 6E10           05693             movwf   R3,0                ;temp save
                      05694 
001DE2 0E07           05695             movlw   0x07                ;allow only allow 0-7
001DE4 D80A           05696             rcall   ee_getdec           ;result in W & R0, trash R1, Z set if exactly max
                      05697 
                      05698 ;Fall into  binstall_r3
                      05699 
                      05700 ;-------------------------------------------------------------------------------*
                      05701 ; Subroutine to install R3 value into EEPROM
                      05702 ; On Entry:
                      05703 ;   EEADR =EEPROM address
                      05704 ;   W = value to install
                      05705 ;   R3 = original value, with appropriate bits cleared
                      05706 ;-------------------------------------------------------------------------------*
001DE6 1210           05707 binstall_r3:    iorwf   R3,F,0              ;combine with other bits
                      05708 
                      05709 ;Fall into install_r3
                      05710 
                      05711 ;-------------------------------------------------------------------------------*
                      05712 ; Subroutine to install R3 value into EEPROM
                      05713 ; On Entry:
                      05714 ;   EEADR =EEPROM address
                      05715 ;   R3 = value to install
                      05716 ;-------------------------------------------------------------------------------*
001DE8 5010           05717 install_r3:     movf    R3,W,0
001DEA EF1A F000      05718                 goto    K_WREEPROM          ;install new value, return
                      05719 
                      05720 ;*******------------------------------------------------------------------------*
                      05721 ;* PMX * Custom EPROM Editor Command: Define max 'P' for fast-programming
                      05722 ;*******
                      05723 ; On Entry:
                      05724 ;   FSR1 points to the rest of the command line from the user
                      05725 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05726 ;-------------------------------------------------------------------------------*
001DEE 0E1D           05727 ecmd_pmx:   movlw   ET_PROGREPS
001DF0 DD73           05728             rcall   etype_lookup
                      05729 
001DF2 0EFF           05730             movlw   0x0FF               ;allow almost anything
001DF4 D802           05731             rcall   ee_getdec           ;result in W & R0, trash R1
001DF6 EF1A F000      05732             goto    K_WREEPROM          ;install new ET_PROGREPS value and return to main
                      05733 
                      05734 ;--------------------------------------------------------------------------------
                      05735 ; Subroutine to get and validate a decimal number
                      05736 ; On Entry:
                      05737 ;   FSR1 points to the next input character
                      05738 ;   W = max allowed value
                      05739 ; On Exit:
                      05740 ;   W=R0 = decimal value
                      05741 ;   Z set if value = max value
                      05742 ; Return to ecmd_error on bogus hex or value too large
                      05743 ; Trashes R1
                      05744 ;--------------------------------------------------------------------------------
001DFA 6E0E           05745 ee_getdec:      movwf   R1,0
001DFC EC12 F000      05746                 call    K_GETDEC                ;get W=decimal input, trash R0
001E00 B00C           05747                 btfsc   KERN_FLAGS,ERR_FLAG,0   ;any input errors?
001E02 D004           05748                 bra     ecmd_error
                      05749 
001E04 6E0D           05750                 movwf   R0,0                    ;for return
001E06 5E0E           05751                 subwf   R1,F,0                  ;beyond max value?
001E08 B0D8           05752                 btfsc   STATUS,C,0              ;y:error
001E0A 0012           05753                 return
                      05754 
                      05755 ;Fall into ecmd_error
                      05756 
                      05757 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                      05758 ; Common Routine
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 86
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      05759 ;   Bad command of some sort - print command error message and go to ee_main
                      05760 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
001E0C EC6D F006      05761 ecmd_error:     call    cmd_error
001E10 D5E9           05762                 bra     ee_main                 ;rude return
                      05763 
                      05764 ;-------------------------------------------------------------------------------*
                      05765 ; Subroutine to delete duplicate pin assignments. Removes all instances of the
                      05766 ; specified pin number from all signal definitions.
                      05767 ; On Entry:
                      05768 ;   R3 = (new pin number-17) to hunt for and delete, in one nibble or the other     
                      05769 ; On Exit:
                      05770 ;   R3 has pin number replicated into both nibbles
                      05771 ; trashes W,R0,R1,R2,R6,EEADR,PRODH:PRODL
                      05772 ;-------------------------------------------------------------------------------*
001E12 3810           05773 dup_delete: swapf   R3,W,0              ;put new pin number in both nibbles
001E14 1210           05774             iorwf   R3,F,0
                      05775 
001E16 0E17           05776             movlw   ET_A9A10            ;first of four 2-pin definition bytes
001E18 DD5F           05777             rcall   etype_lookup        ;each byte define 2 pins
                      05778 
001E1A 0E04           05779             movlw   0x04                ;4 bytes of these signal definitions
001E1C 6E13           05780             movwf   R6,0                ;loop counter
                      05781 
001E1E 50A9           05782 dd_loop:        movf    EEADR,W,0
001E20 EC19 F000      05783                 call    K_RDEEPROM      ;get 2 signal definitions
001E24 6E0F           05784                 movwf   R2,0            ;save original version for compare at end
001E26 6E0E           05785                 movwf   R1,0            ;this version may get modified
                      05786 
001E28 1810           05787                 xorwf   R3,W,0          ;compare both nibbles to given pin number
001E2A 6E0D           05788                 movwf   R0,0            ;save compare
                      05789     
001E2C 0B07           05790                 andlw   0x07            ;low nibble match?
001E2E 0EF8           05791                 movlw   0xF8
001E30 B4D8           05792                 btfsc   STATUS,Z,0
001E32 160E           05793                 andwf   R1,F,0          ;y: clear low nibble
                      05794 
001E34 500D           05795                 movf    R0,W,0          ;result of 2-nibble compare again
                      05796 
001E36 0B70           05797                 andlw   0x70            ;high nibble match?
001E38 0E8F           05798                 movlw   0x8F
001E3A B4D8           05799                 btfsc   STATUS,Z,0
001E3C 160E           05800                 andwf   R1,F,0          ;y: clear high nibble
                      05801 
001E3E 500E           05802                 movf    R1,W,0          ;new value for this byte
001E40 620F           05803                 cpfseq  R2,0            ;any changes to this byte?
001E42 EC1A F000      05804                 call    K_WREEPROM      ;y: replace byte
                      05805 
001E46 2AA9           05806                 incf    EEADR,F,0       ;next pin-definition word
001E48 0613           05807                 decf    R6,F,0          ;loop counter
001E4A E1E9           05808                 bnz     dd_loop
                      05809 
                      05810 ;If the given pin is 19, then remove Vdd definition.
001E4C 5010           05811             movf    R3,W,0
001E4E 0B07           05812             andlw   0x07                ;pin definition
001E50 0A02           05813             xorlw   0x02                ;pin 19?
001E52 E105           05814             bnz     dd_not19
                      05815 
001E54 0E1B           05816             movlw   ET_VBBVDD           ;redefining pin 19, so no Vdd
001E56 DD35           05817             rcall   etype_getval
001E58 0BDF           05818             andlw   0xDF                ;remove Vdd definition
001E5A EC1A F000      05819             call    K_WREEPROM
001E5E                05820 dd_not19:
                      05821 
                      05822 ;If the given pin is 21, then remove Vbb definition
001E5E 5010           05823             movf    R3,W,0
001E60 0B07           05824             andlw   0x07                ;pin definition
001E62 0A04           05825             xorlw   0x04                ;pin 21?
001E64 E105           05826             bnz     dd_not21
                      05827 
001E66 0E1B           05828             movlw   ET_VBBVDD           ;redefining pin 21
001E68 DD2C           05829             rcall   etype_getval
001E6A 0BEF           05830             andlw   0xEF                ;remove Vbb definition
001E6C EC1A F000      05831             call    K_WREEPROM
                      05832 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 87
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001E70 0012           05833 dd_not21:   return
                      05834 
                      05835 ;-------------------------------------------------------------------------------*
                      05836 ; Subroutine to get a pin number from the line buffer LINBUF
                      05837 ; legal values are 0 (meaning no pin) and 18-23
                      05838 ; On Entry:
                      05839 ;   FSR1 points to the rest of the command line from the user
                      05840 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05841 ; On Exit:
                      05842 ;   R3=W=0-6, an encoded pin number
                      05843 ; Rude jump to ee_main on input error
                      05844 ; Trashes R0,PRODL
                      05845 ;-------------------------------------------------------------------------------*
001E72 EC12 F000      05846 get_pin:    call    K_GETDEC                ;get PRODL=decimal input
001E76 B00C           05847             btfsc   KERN_FLAGS,ERR_FLAG,0   ;any input errors?
001E78 D7C9           05848             bra     ecmd_error
                      05849 
001E7A 50F3           05850             movf    PRODL,W,0               ;0, meaning no pin?
001E7C E008           05851             bz      gp_done                 ;y: nothing more to do
                      05852 
001E7E 0E12           05853             movlw   .18
001E80 5EF3           05854             subwf   PRODL,F,0               ;legal value should be above 17
001E82 E303           05855             bnc     gp_error
                      05856 
001E84 0E05           05857             movlw   .5
001E86 5CF3           05858             subwf   PRODL,W,0               ;carry clear if PRODL >=6
001E88 B0D8           05859             btfsc   STATUS,C,0
                      05860 
001E8A D7C0           05861 gp_error:   bra     ecmd_error
                      05862 
001E8C 28F3           05863             incf    PRODL,W,0               ;pins 18-23 encoded as 1-6
                      05864 
001E8E 6E10           05865 gp_done:    movwf   R3,0                    ;result in place for return
001E90 0012           05866             return
                      05867 
                      05868 ;******-------------------------------------------------------------------------*
                      05869 ;* ED * Custom EPROM Editor Command: Display EPROM
                      05870 ;******
                      05871 ; On Entry:
                      05872 ;   FSR1 points to the rest of the command line from the user
                      05873 ;   ETYPE = the EPROM type currently being edited (one of the custom types)
                      05874 ;-------------------------------------------------------------------------------*
001E92                05875 ecmd_dispeprom:
                      05876 
                      05877 ; Same as dispeprom
                      05878 
                      05879 ;*==============================================================================*
                      05880 ; Subroutine to Display EPROM Specifications (with pretty picture)
                      05881 ; (Placed at the end of code to optimize for rcall and bra instructions)
                      05882 ; On Entry:
                      05883 ;   ETYPE is the type of EPROM to display
                      05884 ; Trashes W,R0,R1,R2,R3,R4
                      05885 ;*==============================================================================*
001E92                05886 dispeprom:
                      05887 
                      05888 ;-----------------------
                      05889 ; Print the EPROM's name
                      05890 ;-----------------------
001E92 EE01 F0B4      05891                 lfsr    0,type_msg-sstrings     ;"Type "
001E96 ECA4 F00A      05892                 call    rep_etype2              ;print EPROM type and name
                      05893 
                      05894 ;-------------------------------------------
                      05895 ; Print the EPROM's byte count and bits/byte
                      05896 ;-------------------------------------------
001E9A EE06 F06C      05897                 lfsr    0,esize_msg-sstrings    ;", size: "
001E9E D9B4           05898                 rcall   hprintf
                      05899 
001EA0 0E16           05900                 movlw   ET_BYTES
001EA2 DD0F           05901                 rcall   etype_getval
001EA4 6E10           05902                 movwf   R3,0                    ;save upper nibble for byte width
                      05903 
001EA6 0B07           05904                 andlw   0x07                    ;just the byte count bits
001EA8 6E0F           05905                 movwf   R2,0
001EAA 2A0F           05906                 incf    R2,F,0                  ;loop will go at least once
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 88
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      05907 
001EAC 6A0E           05908                 clrf    R1,0                    ;compute the number of bytes in R1:R0
001EAE 0E80           05909                 movlw   .128
001EB0 6E0D           05910                 movwf   R0,0
                      05911 
001EB2 90D8           05912 de_bloop:           bcf     STATUS,C,0          ;shift in a 0
001EB4 360D           05913                     rlcf    R0,F,0
001EB6 360E           05914                     rlcf    R1,F,0
001EB8 060F           05915                     decf    R2,F,0
001EBA E1FB           05916                     bnz     de_bloop
                      05917 
001EBC EC0B F000      05918                 call    K_PRINTDEC              ;Print R1:R0 in decimal
                      05919 
001EC0 EE06 F076      05920                 lfsr    0,by_msg-sstrings       ;" x "
001EC4 D9A1           05921                 rcall   hprintf
                      05922 
001EC6 3810           05923                 swapf   R3,W,0                  ;get the bits/byte portion
001EC8 0B0F           05924                 andlw   0x0F
001ECA 6E0D           05925                 movwf   R0,0                    ;set up for K_PRINTDEC
001ECC 6A0E           05926                 clrf    R1,0
001ECE EC0B F000      05927                 call    K_PRINTDEC
                      05928 
                      05929 ;-----------------------------------------------------------------------------------
                      05930 ; Print a picture of the EPROM, with pins in the right place, with adjacent messages
                      05931 ;-----------------------------------------------------------------------------------
001ED2 EE08 F096      05932                 lfsr    0,ep1_msg-sstrings      ;beginning of picture
001ED6 D99A           05933                 rcall   cr_hprintf
                      05934 
                      05935 ;Programming Vcc goes adjacent to the Vcc pin
001ED8 0E1B           05936                 movlw   ET_VBBVDD               ;get the programming-Vcc bits
001EDA DCF3           05937                 rcall   etype_getval
001EDC 0B07           05938                 andlw   0x07
                      05939 
001EDE EE07 F0D0      05940                 lfsr    0,v0_msg-sstrings       ;"0V"
001EE2 0FFF           05941                 addlw   0xFF                    ;decrement
001EE4 B4D8           05942                 btfsc   STATUS,Z,0
001EE6 EE07 F0D4      05943                 lfsr    0,v5_msg-sstrings       ;"5V"
001EEA 0FFF           05944                 addlw   0xFF                    ;decrement
001EEC B4D8           05945                 btfsc   STATUS,Z,0
001EEE EE07 F0D8      05946                 lfsr    0,v6_msg-sstrings       ;"6.2V"
001EF2 0FFF           05947                 addlw   0xFF                    ;decrement
001EF4 B4D8           05948                 btfsc   STATUS,Z,0
001EF6 EE07 F0DE      05949                 lfsr    0,v12_msg-sstrings      ;"12V"
                      05950 
                      05951 ;Does this EPROM require the (6.2V) power supply to be adjusted?
001EFA 0E22           05952                 movlw   ET_SPECIAL
001EFC DCE2           05953                 rcall   etype_getval
001EFE 0B01           05954                 andlw   0x01                    ;test custom Vcc bit
001F00 E005           05955                 bz      de_novccadj 
                      05956 
001F02 0E14           05957                 movlw   ET_VCCMSG
001F04 6A0F           05958                 clrf    R2,0                    ;no formatting
001F06 ECAF F00A      05959                 call    eds_print               ;print the adjustment message from the data structure
001F0A D001           05960                 bra     de_vadone
                      05961 
001F0C D97D           05962 de_novccadj:    rcall   hprintf
001F0E                05963 de_vadone:
                      05964 ;Figure out and print what's on pin 22
001F0E EE08 F0DC      05965                 lfsr    0,ep2_msg-sstrings      ;2nd picture piece
001F12 D97C           05966                 rcall   cr_hprintf
                      05967 
001F14 0E05           05968                 movlw   .22-.17
001F16 D8EA           05969                 rcall   hunt_pin
                      05970 
                      05971 ;Figure out and print what's on pin 21
001F18 EE09 F00E      05972                 lfsr    0,ep3_msg-sstrings      ;3rd picture piece
001F1C D977           05973                 rcall   cr_hprintf
                      05974 
001F1E 0E04           05975                 movlw   .21-.17
001F20 D8E5           05976                 rcall   hunt_pin
                      05977 
                      05978 ;Figure out and print what's on pin 20
001F22 EE09 F026      05979                 lfsr    0,ep4_msg-sstrings      ;4th picture piece
001F26 D972           05980                 rcall   cr_hprintf
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 89
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      05981 
001F28 0E03           05982                 movlw   .20-.17
001F2A D8E0           05983                 rcall   hunt_pin
                      05984 
                      05985 ;Figure out and print what's on pin 19
001F2C EE09 F03E      05986                 lfsr    0,ep5_msg-sstrings      ;5th picture piece
001F30 D96D           05987                 rcall   cr_hprintf
                      05988 
001F32 0E02           05989                 movlw   .19-.17
001F34 D8DB           05990                 rcall   hunt_pin
                      05991 
                      05992 ;Figure out and print what's on pin 18
001F36 EE09 F056      05993                 lfsr    0,ep6_msg-sstrings      ;6th picture piece
001F3A D968           05994                 rcall   cr_hprintf
                      05995 
001F3C 0E01           05996                 movlw   .18-.17
001F3E D8D6           05997                 rcall   hunt_pin
                      05998 
                      05999 ;Print the supported EPROMs list next to the EPROM picture. (Don't print the
                      06000 ;list if this is a custom EPROM.)
001F40 EE09 F06E      06001                 lfsr    0,ep7_msg-sstrings      ;7th picture piece
001F44 D963           06002                 rcall   cr_hprintf
                      06003 
001F46 EE0A F00A      06004                 lfsr    0,supdev_msg-sstrings   ;"   Supported devices:"
001F4A AE21           06005                 btfss   FLAGS2,CUST_EPROM,0     ;custom EPROM?
001F4C D95D           06006                 rcall   hprintf                 ;n: print heading
                      06007 
001F4E EE09 F088      06008                 lfsr    0,ep8_msg-sstrings      ;8th picture piece
001F52 0E02           06009                 movlw   ET_PARTNO1
001F54 D868           06010                 rcall   print_2names
                      06011 
001F56 EE09 F0A2      06012                 lfsr    0,ep9_msg-sstrings      ;9th picture piece
001F5A 0E04           06013                 movlw   ET_PARTNO2
001F5C D864           06014                 rcall   print_2names
                      06015 
001F5E EE09 F0BC      06016                 lfsr    0,ep10_msg-sstrings     ;10th picture piece
001F62 0E06           06017                 movlw   ET_PARTNO3
001F64 D860           06018                 rcall   print_2names
                      06019 
001F66 EE09 F0D6      06020                 lfsr    0,ep11_msg-sstrings     ;11th picture piece
001F6A 0E08           06021                 movlw   ET_PARTNO4
001F6C D85C           06022                 rcall   print_2names
                      06023 
001F6E EE09 F0F0      06024                 lfsr    0,ep12_msg-sstrings     ;12th picture piece
001F72 0E0A           06025                 movlw   ET_PARTNO5
001F74 D858           06026                 rcall   print_2names
                      06027 
                      06028 ;-----------------------------------------------------------------------------
                      06029 ; Print additional details about Vpp, only if there is a Vpp pin on this EPROM
                      06030 ; If it's a pulsed Vpp, does it return to 0V or 5V?
                      06031 ;-----------------------------------------------------------------------------
001F76 0E1C           06032                 movlw   ET_VPPSETUP             ;programming pulse type etc.
001F78 DCA4           06033                 rcall   etype_getval
001F7A 6E0F           06034                 movwf   R2,0                    ;temp save
                      06035 
001F7C 0E1A           06036                 movlw   ET_PGMVPP
001F7E DCA1           06037                 rcall   etype_getval
001F80 0B07           06038                 andlw   0x07                    ;is there a Vpp pin?
001F82 E009           06039                 bz      de_noVpp
                      06040 
001F84 EE06 F044      06041                 lfsr    0,rvppat_msg-sstrings   ;"Vpp level during read: "
001F88 D941           06042                 rcall   cr_hprintf
                      06043 
001F8A EE07 F0D0      06044                 lfsr    0,v0_msg-sstrings       ;"0V"
001F8E B40F           06045                 btfsc   R2,0x02,0
001F90 EE07 F0D4      06046                 lfsr    0,v5_msg-sstrings       ;"5V"
001F94 D939           06047                 rcall   hprintf
001F96                06048 de_noVpp:
                      06049 ;----------------------------------------------------------------------------
                      06050 ; Print details about digital programming pulse, if there is one
                      06051 ;----------------------------------------------------------------------------
001F96 A20F           06052                 btfss   R2,0x01,0               ;pulsed Vpp?
001F98 D009           06053                 bra     de_nopgm                ;y: then there is no PGM pulse
                      06054 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 90
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001F9A EE06 F0A0      06055                 lfsr    0,propulse_msg-sstrings ;"programming pulse on "
001F9E D936           06056                 rcall   cr_hprintf
                      06057 
001FA0 EE08 F05F      06058                 lfsr    0,pgm_msg-sstrings+1    ; (skipping slash)
001FA4 D931           06059                 rcall   hprintf
                      06060 
001FA6 EE04 F028      06061                 lfsr    0,pin_msg-sstrings      ;" pin "
001FAA D92E           06062                 rcall   hprintf
001FAC                06063 de_nopgm:
                      06064 
                      06065 ;----------------------------------------------------
                      06066 ; Announce any Vcc and/or Vpp adjustment requirements 
                      06067 ;----------------------------------------------------
001FAC D931           06068                 rcall   special_v
                      06069 
                      06070 ;----------------------------------------------------------------
                      06071 ; Announce if the chip is an EEPROM, and therefore no blank check
                      06072 ;----------------------------------------------------------------
001FAE 0E22           06073                 movlw   ET_SPECIAL
001FB0 DC88           06074                 rcall   etype_getval
                      06075 
001FB2 EE06 F07C      06076                 lfsr    0,eeprom_msg-sstrings   ;"EEPROM: no blank check before programming"
001FB6 0B08           06077                 andlw   0x08                    ;EEPROM bit
001FB8 A4D8           06078                 btfss   STATUS,Z,0
001FBA D928           06079                 rcall   cr_hprintf
                      06080 
                      06081 ;--------------------------------------------------
                      06082 ; Decode and print programming pulse width
                      06083 ;--------------------------------------------------
001FBC EE05 F0C8      06084                 lfsr    0,ppw_msg-sstrings          ;"Programming pulse width: "
001FC0 D925           06085                 rcall   cr_hprintf
                      06086 
001FC2 0E1E           06087                 movlw   ET_PROGPULSE
001FC4 DC7E           06088                 rcall   etype_getval
                      06089 
001FC6 D84B           06090                 rcall   pdecode_time                ;decode and print pulse width time
                      06091 
                      06092 ;--------------------------------------------------
                      06093 ; Decode and print programming pulse delay
                      06094 ;--------------------------------------------------
001FC8 0E1F           06095                 movlw   ET_PPDELAY
001FCA DC7B           06096                 rcall   etype_getval                ;into W and R0
001FCC 6E0F           06097                 movwf   R2,0                        ;temp save
001FCE 0B7F           06098                 andlw   0x7F                        ;no delay?
001FD0 E00B           06099                 bz      de_nodelay                  ;..then no delay message
                      06100 
001FD2 040F           06101                 decf    R2,W,0                      ;EEPROM-style polling?
001FD4 E104           06102                 bnz     de_nopoll
                      06103 
001FD6 EE06 F0B8      06104                 lfsr    0,poll_msg-sstrings         ;"Poll data for write completion"
001FDA D918           06105                 rcall   cr_hprintf
001FDC D005           06106                 bra     de_nodelay              
                      06107 
001FDE EE05 F0E4      06108 de_nopoll:      lfsr    0,ppd_msg-sstrings          ;", delay between pulses: "
001FE2 D912           06109                 rcall   hprintf
001FE4 500F           06110                 movf    R2,W,0
001FE6 D83B           06111                 rcall   pdecode_time                ;decode and print pulse width time
001FE8                06112 de_nodelay:
                      06113 ;-----------------
                      06114 ; Smart algorithm?
                      06115 ;-----------------
001FE8 0E20           06116                 movlw   ET_SMART1
001FEA DC6B           06117                 rcall   etype_getval
001FEC 0900           06118                 iorlw   0x00                        ;00 means no smart programming
001FEE E013           06119                 bz      de_dumb
                      06120 
                      06121 ;---------------------------------------------------------------------------
                      06122 ; Print smart programming specifics
                      06123 ; On Entry:
                      06124 ;    W<6:4> Phase 1 type
                      06125 ;        0: program until match, then program n times
                      06126 ;        1: program until match, then 1 pulse that is n*ET_PROGPULSE long
                      06127 ;        2: program until match (P), then nP times
                      06128 ;        3: program until match, then 1 pulse that is n*P*ET_PROGPULSE long
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 91
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      06129 ;        4: Program n times
                      06130 ;        5: Program once, pulse time = n*ET_PROGPULSE
                      06131 ;   W<3> = 1 to write FFh (EEPROM erase)
                      06132 ;   W<2:0> Phase n
                      06133 ;---------------------------------------------------------------------------
001FF0 9420           06134                 bcf     FLAGS1,B_STATE,0            ;will become set if this pass had a P
001FF2 6E10           06135                 movwf   R3,0                        ;remember smart specifics
                      06136 
001FF4 EE02 F02E      06137                 lfsr    0,smartrapid_msg-sstrings   ;"Smart/Rapid algorithm:\r  Pass 1"
001FF8 D841           06138                 rcall   de_smart                    ;describe pass 1
                      06139 
001FFA 0E21           06140                 movlw   ET_SMART2                   ;get pass 2 specs
001FFC DC62           06141                 rcall   etype_getval
001FFE 6E10           06142                 movwf   R3,0                        ;for de_smart
002000 0900           06143                 iorlw   0x00                        ;00 means no pass 2
                      06144 
002002 EE02 F048      06145                 lfsr    0,pass2_msg-sstrings        ;"  Pass 2"
002006 A4D8           06146                 btfss   STATUS,Z,0
002008 D839           06147                 rcall   de_smart                    ;y: describe pass 2
                      06148 
00200A A420           06149                 btfss   FLAGS1,B_STATE,0            ;Did either pass create a P value?
00200C 0012           06150                 return                              ;n: done
                      06151 
00200E EE02 F0DE      06152                 lfsr    0,maxp_msg-sstrings         ;"  Maximum P= "
002012 D8FC           06153                 rcall   cr_hprintf                  ;y: announce
002014 D003           06154                 bra     de_reps
                      06155 
                      06156 ;------------------------------
                      06157 ; Print programming repetitions
                      06158 ;------------------------------
002016 EE06 F014      06159 de_dumb:        lfsr    0,ppr_msg-sstrings      ;"Programming cycles: "
00201A D8F8           06160                 rcall   cr_hprintf
                      06161 
00201C 0E1D           06162 de_reps:        movlw   ET_PROGREPS
00201E DC51           06163                 rcall   etype_getval            ;result in W and R0
002020 6A0E           06164                 clrf    R1,0                    ;set up for K_PRINTDEC
002022 EF0B F000      06165                 goto    K_PRINTDEC              ;print W in decimal, return from there
                      06166 
                      06167 ;---------------------------------------------------------------
                      06168 ; Local subroutine to print a piece of the supported EPROM list
                      06169 ; unless this is a custom EPROM
                      06170 ; On Entry:
                      06171 ;   lfsr0 = string pointer offset for piece of the EPROM picture
                      06172 ;   W = index to one of the supported EPROMs
                      06173 ;   ETYPE is current
                      06174 ; Trashes W,R0,R1,R2,R4
                      06175 ;---------------------------------------------------------------
002026 6E11           06176 print_2names:   movwf   R4,0                    ;save EPROM index
002028 D8F1           06177                 rcall   cr_hprintf              ;print EPROM picture piece
00202A EE08 F08C      06178                 lfsr    0,space7_msg-sstrings   ;space over a bit from the EPROM picture
00202E D8EC           06179                 rcall   hprintf
                      06180 
002030 BE21           06181                 btfsc   FLAGS2,CUST_EPROM,0     ;custom EPROM?
002032 0012           06182                 return                          ;y: no supported devices list
                      06183 
002034 D80A           06184                 rcall   print_1name             ;print the 1st column supported EPROM
                      06185 
002036 0E0A           06186                 movlw   .5 * 2                  ;print the second column - 5 names later
002038 2611           06187                 addwf   R4,F,0
                      06188 
00203A 0E14           06189                 movlw   ET_PARTNO10             ;last name in the list?
00203C 1811           06190                 xorwf   R4,W,0
00203E E105           06191                 bnz     print_1name             ;n: nothing special to do
                      06192 
                      06193 ;The last name on the list may actually be a pointer to special programming instructions
002040 0E22           06194                 movlw   ET_SPECIAL              ;the last 2 names overlap messages
002042 DC3F           06195                 rcall   etype_getval
002044 0B07           06196                 andlw   0x7                     ;any special requirements?
002046 E001           06197                 bz      print_1name             ;n: carry on
                      06198 
002048 0012           06199                 return                          ;y: don't print a "supported eprom"                 
                      06200 
                      06201 ;--------------------------------------------------------------------
                      06202 ; Local subroutine to print one supported EPROM's manufacturer & name
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 92
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      06203 ; On Entry:
                      06204 ;   R4 = pointer to the manufacturer index
                      06205 ; Trashes W,R0,R1,R2 
                      06206 ;--------------------------------------------------------------------
00204A 0E0B           06207 print_1name:    movlw   .11                 ;print manufacturer names in 11-wide field
00204C 6E0F           06208                 movwf   R2,0
00204E 5011           06209                 movf    R4,W,0
002050 ECAF F00A      06210                 call    eds_print
                      06211 
002054 0E0C           06212                 movlw   .12                 ;print part number in 12-wide field
002056 6E0F           06213                 movwf   R2,0
002058 2811           06214                 incf    R4,W,0
00205A EFAF F00A      06215                 goto    eds_print
                      06216 
                      06217 ;-----------------------------------------------------------------
                      06218 ; Local subroutine to decode and print a pulse width or delay time
                      06219 ; On Entry:
                      06220 ;   W = value to decode
                      06221 ; Trashes W,R0,R1,R2,R3,PRODH,PRODL
                      06222 ;-----------------------------------------------------------------
00205E 6E10           06223 pdecode_time:   movwf   R3,0
002060 0B7F           06224                 andlw   0x7F                    ;set Z if 0
                      06225 
002062 EE05 F0FE      06226                 lfsr    0,ns500_msg-sstrings    ;"500 nS"
002066 E009           06227                 bz      de_pwdone
                      06228 
002068 6E0D           06229                 movwf   R0,0                    ;set up for K_PRINTDEC
00206A 6A0E           06230                 clrf    R1,0
00206C EC0B F000      06231                 call    K_PRINTDEC              ;print W in decimal
                      06232 
002070 EE06 F00E      06233                 lfsr    0,us_msg-sstrings       ;"0 uS" adds a zero too
002074 BE10           06234                 btfsc   R3,0x07,0
002076 EE06 F008      06235                 lfsr    0,ms_msg-sstrings       ;" mS"
                      06236 
00207A D0C6           06237 de_pwdone:      bra     hprintf                 ;return from there
                      06238 
                      06239 ;-------------------------------------------------------------------------
                      06240 ; Local subroutine to decode and print one phase of the smart
                      06241 ; programming algorithm
                      06242 ; On Entry:
                      06243 ;   FSR0 = initial print string pointer
                      06244 ;   R3<6:4> Phase 1 type
                      06245 ;      0: program until match, then program n times
                      06246 ;      1: program until match, then 1 pulse that is n*ET_PROGPULSE long
                      06247 ;      2: program until match (P), then nP times
                      06248 ;      3: program until match, then 1 pulse that is n*P*ET_PROGPULSE long
                      06249 ;      4: Program n times
                      06250 ;      5: Program once, pulse time = n*ET_PROGPULSE
                      06251 ;   R3<3> = 1 forces data to FF (EEPROM erase)
                      06252 ;   R3<2:0> Phase n
                      06253 ; On Exit:
                      06254 ;   B_STATE set if this pass produced a P value
                      06255 ; Trashes W,R0,R1,R2,PRODH,PRODL
                      06256 ;------------------------------------------------------------------------
00207C D8C7           06257 de_smart:       rcall   cr_hprintf
00207E EE02 F052      06258                 lfsr    0,write_msg-sstrings    ;": write "
002082 D8C2           06259                 rcall   hprintf
                      06260 
002084 EE02 F05C      06261                 lfsr    0,ff_msg-sstrings       ;"FFh to "
002088 B610           06262                 btfsc   R3,0x03,0               ;erase pass?
00208A D8BE           06263                 rcall   hprintf
                      06264 
00208C EE02 F066      06265                 lfsr    0,eachbyte_msg-sstrings ;"each byte "
002090 D8BB           06266                 rcall   hprintf
                      06267 
002092 BC10           06268                 btfsc   R3,0x06,0               ;program until match?
002094 D00F           06269                 bra     des1
                      06270 
                      06271 ;This is one of the P+ type algorithms
002096 8420           06272                 bsf     FLAGS1,B_STATE,0        ;remember this pass had a P
                      06273 
002098 EE02 F07C      06274                 lfsr    0,matchp_msg-sstrings   ;"until it matches (P times)"
00209C D8B5           06275                 rcall   hprintf
                      06276 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 93
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00209E 5010           06277                 movf    R3,W,0                  ;get n
0020A0 0B07           06278                 andlw   0x07
0020A2 B4D8           06279                 btfsc   STATUS,Z,0
0020A4 0012           06280                 return                          ;no n value: done
                      06281 
0020A6 EE02 F092      06282                 lfsr    0,andthen_msg-sstrings  ;", and then "
0020AA D8AE           06283                 rcall   hprintf
                      06284 
0020AC EE02 F0AA      06285                 lfsr    0,another_msg-sstrings  ;"another "
0020B0 A810           06286                 btfss   R3,0x04,0               ;n/nP or fat pulse?
0020B2 D8AA           06287                 rcall   hprintf
                      06288 
0020B4 EE02 F0B4      06289 des1:           lfsr    0,withone_msg-sstrings  ;"with one "
0020B8 B810           06290                 btfsc   R3,0x04,0               ;n/nP or fat pulse?
0020BA D8A6           06291                 rcall   hprintf
                      06292 
0020BC 5010           06293                 movf    R3,W,0                  ;get n
0020BE 0B07           06294                 andlw   0x07
                      06295 
0020C0 6E0D           06296                 movwf   R0,0                    ;set up for K_PRINTDEC
0020C2 6A0E           06297                 clrf    R1,0
0020C4 EC0B F000      06298                 call    K_PRINTDEC
                      06299 
0020C8 0E50           06300                 movlw   'P'
0020CA BA10           06301                 btfsc   R3,0x05,0               ;nP type programming?
0020CC EC06 F000      06302                 call    K_CONOUT
                      06303 
0020D0 EE02 F072      06304                 lfsr    0,times_msg-sstrings    ;" time(s)"
0020D4 A810           06305                 btfss   R3,0x04,0               ;n/nP or fat pulse?
0020D6 D098           06306                 bra     hprintf                 ;print 'times', return from there
                      06307 
                      06308 ;This is one of the fat-pulse algorithms: n or nP times the programming pulse width
0020D8 EE02 F0C0      06309                 lfsr    0,mult_msg-sstrings     ;" * "
0020DC D895           06310                 rcall   hprintf
                      06311 
0020DE 0E1E           06312                 movlw   ET_PROGPULSE            ;get programming pulse width
0020E0 EC61 F00C      06313                 call    etype_getval
0020E4 DFBC           06314                 rcall   pdecode_time            ;decode and print it, with units
                      06315 
0020E6 EE02 F0C6      06316                 lfsr    0,pulse_msg-sstrings    ;" pulse"
0020EA D08E           06317                 bra     hprintf
                      06318                  
                      06319 ;----------------------------------------------------------------
                      06320 ; Local subroutine to print the signal(s) assigned to a pin
                      06321 ; Note that a pin may have multiple signals assigned to it. If
                      06322 ; so, all are printed, separated by slashes.
                      06323 ; On Entry:
                      06324 ;   W = pin number -17, 0 means unassigned
                      06325 ;   ETYPE = the EPROM type
                      06326 ; Trashes W,R0,R1,R2,R3,R4,FSR0
                      06327 ;----------------------------------------------------------------
0020EC 6E11           06328 hunt_pin:       movwf   R4,0                    ;save pin number while we hunt
0020EE 9420           06329                 bcf     FLAGS1,B_STATE          ;this pin is not yet assigned
                      06330 
                      06331 ;A9 or A10?
0020F0 0E17           06332                 movlw   ET_A9A10
0020F2 EC61 F00C      06333                 call    etype_getval            ;result in W and R0
                      06334 
0020F6 EE08 F022      06335                 lfsr    0,A9_msg-sstrings       ;"A9"
0020FA 380D           06336                 swapf   R0,W,0
0020FC 0B07           06337                 andlw   0x07                    ;get the A9 pin definition
0020FE 1811           06338                 xorwf   R4,W,0                  ;A9?
                      06339 
002100 B4D8           06340                 btfsc   STATUS,Z,0
002102 D081           06341                 bra     hunt_ppin               ;print pin name
                      06342 
002104 EE08 F026      06343                 lfsr    0,A10_msg-sstrings      ;"A10"
002108 500D           06344                 movf    R0,W,0
00210A 0B07           06345                 andlw   0x07                    ;get the A10 pin definition
00210C 1811           06346                 xorwf   R4,W,0                  ;A10?
                      06347 
00210E B4D8           06348                 btfsc   STATUS,Z,0
002110 D07A           06349                 bra     hunt_ppin               ;print pin name
                      06350 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 94
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      06351 ;A11 or A12?
002112 0E18           06352                 movlw   ET_A11A12
002114 EC61 F00C      06353                 call    etype_getval            ;result in W and R0
                      06354 
002118 380D           06355                 swapf   R0,W,0
00211A 0B07           06356                 andlw   0x07                    ;get the A11 pin definition
00211C 1811           06357                 xorwf   R4,W,0                  ;A11?
00211E E106           06358                 bnz     hunt_12
                      06359 
                      06360 ;It's A11. Is this forced high?
002120 EE08 F02C      06361                 lfsr    0,A11_msg-sstrings      ;"A11"
002124 BE0D           06362                 btfsc   R0,0x07,0
002126 EE08 F038      06363                 lfsr    0,stuckhi_msg-sstrings  ;"Stuck-High"
00212A D06D           06364                 bra     hunt_ppin               ;print pin name
                      06365 
00212C 500D           06366 hunt_12:        movf    R0,W,0
00212E 0B07           06367                 andlw   0x07                    ;get the A12 pin definition
002130 1811           06368                 xorwf   R4,W,0                  ;A12?
002132 E106           06369                 bnz     hunt_not12
                      06370 
                      06371 ;It's A12. is it really -Address Strobe?
002134 EE08 F032      06372                 lfsr    0,A12_msg-sstrings      ;"A12"
002138 B60D           06373                 btfsc   R0,0x03,0
00213A EE08 F044      06374                 lfsr    0,as_msg-sstrings       ;"-AS"
00213E D063           06375                 bra     hunt_ppin               ;print pin name
002140                06376 hunt_not12:
                      06377 
                      06378 ;-OE or CS?
002140 0E19           06379                 movlw   ET_OECS
002142 EC61 F00C      06380                 call    etype_getval            ;result in W and R0
002146 6E10           06381                 movwf   R3,0                    ;temp save for +12V test
                      06382 
002148 380D           06383                 swapf   R0,W,0
00214A 0B07           06384                 andlw   0x07                    ;get the -OE bits
00214C 1811           06385                 xorwf   R4,W,0                  ;-OE?
00214E E107           06386                 bnz     hunt_cs
                      06387 
                      06388 ;It's -OE.
002150 EE08 F04A      06389                 lfsr    0,oe_msg-sstrings       ;"-OE"
002154 D858           06390                 rcall   hunt_ppin               ;print pin name, keep looking
                      06391             
                      06392 ;Is -OE pin at +12V during programming?
002156 EE06 F02A      06393                 lfsr    0,p12v_msg-sstrings     ;" +12V during programming"
00215A BE10           06394                 btfsc   R3,0x07,0
00215C D855           06395                 rcall   hprintf
                      06396 
00215E 5010           06397 hunt_cs:        movf    R3,W,0
002160 0B07           06398                 andlw   0x07                    ;get the CS bits (CS may not also be -OE)
002162 1811           06399                 xorwf   R4,W,0                  ;CS?
002164 E106           06400                 bnz     hunt_notcs
                      06401 
                      06402 ;It's CS. active-low?
002166 EE08 F052      06403                 lfsr    0,cs_msg-sstrings       ;"CS"
00216A A610           06404                 btfss   R3,0x03,0
00216C EE08 F050      06405                 lfsr    0,csn_msg-sstrings      ;"-CS"
002170 D84A           06406                 rcall   hunt_ppin               ;print pin name
002172                06407 hunt_notcs:
                      06408 
                      06409 ;PGM or Vpp?
002172 0E1A           06410                 movlw   ET_PGMVPP
002174 EC61 F00C      06411                 call    etype_getval            ;result in W and R0
                      06412 
002178 380D           06413                 swapf   R0,W,0
00217A 0B07           06414                 andlw   0x07                    ;get the PGM bits
00217C 1811           06415                 xorwf   R4,W,0                  ;PGM?
00217E E106           06416                 bnz     hunt_vpp
                      06417 
                      06418 ;It's PGM. active-low?
002180 EE08 F056      06419                 lfsr    0,pgmn_msg-sstrings     ;"/-PGM"
002184 BE0D           06420                 btfsc   R0,0x07,0
002186 EE08 F05E      06421                 lfsr    0,pgm_msg-sstrings      ;"/PGM"
                      06422 
00218A D83B           06423                 rcall   hunt_sppin              ;print pin name, with slash if needed
                      06424 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 95
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00218C 500D           06425 hunt_vpp:       movf    R0,W,0
00218E 0B07           06426                 andlw   0x07                    ;get the Vpp bits
002190 1811           06427                 xorwf   R4,W,0                  ;Vpp?
002192 E11B           06428                 bnz     hunt_notVpp
                      06429 
                      06430 ;It's Vpp. Print Vpp details.
                      06431 ;R4 = pin number - 17 here.
002194 EE08 F064      06432                 lfsr    0,vpp_msg-sstrings      ;"/Vpp: "
002198 D834           06433                 rcall   hunt_sppin              ;print pin name, with slash if needed
                      06434 
00219A 0E1C           06435                 movlw   ET_VPPSETUP
00219C EC61 F00C      06436                 call    etype_getval            ;result in W and R0
                      06437 
0021A0 B20D           06438                 btfsc   R0,0x01,0               ;pulsed Vpp?
0021A2 D00F           06439                 bra     hunt_pvpp
                      06440 
0021A4 6E0E           06441                 movwf   R1,0                    ;temp save while we print
0021A6 EE06 F058      06442                 lfsr    0,pvpp_msg-sstrings     ;" pulsed from "
0021AA D82E           06443                 rcall   hprintf
                      06444 
0021AC EE07 F0D0      06445                 lfsr    0,v0_msg-sstrings       ;"0V"
0021B0 B00E           06446                 btfsc   R1,0x00,0
0021B2 EE07 F0D4      06447                 lfsr    0,v5_msg-sstrings       ;"5V"
0021B6 D828           06448                 rcall   hprintf
                      06449 
0021B8 EE06 F066      06450                 lfsr    0,to_msg-sstrings       ;" to "
0021BC D825           06451                 rcall   hprintf
                      06452 
0021BE C00E F00D      06453                 movff   R1,R0                   ;voltage for pvpp_voltage
                      06454 
0021C2 C011 F00F      06455 hunt_pvpp:      movff   R4,R2                   ;Pin number minus 17
0021C6 EF89 F00C      06456                 goto    pvpp_voltage            ;return from there
0021CA                06457 hunt_notVpp:
                      06458 
                      06459 ;Vbb (on pin 21) (may not be shared with other signals)?
0021CA 6E0E           06460                 movwf   R1,0
0021CC 0E04           06461                 movlw   .21-.17                 ;could this be Vbb (pin 21)?
0021CE 1811           06462                 xorwf   R4,W,0
0021D0 E108           06463                 bnz     hunt_notvbb
                      06464 
0021D2 0E1B           06465                 movlw   ET_VBBVDD
0021D4 EC61 F00C      06466                 call    etype_getval
0021D8 0B10           06467                 andlw   0x10                    ;any Vbb pin on this EPROM?
0021DA E003           06468                 bz      hunt_notvbb
                      06469 
0021DC EE08 F06C      06470                 lfsr    0,vbb5v_msg-sstrings    ;"Vbb -5V"
0021E0 D012           06471                 bra     hunt_ppin
0021E2                06472 hunt_notvbb:
                      06473 ;Vdd (on pin 19) (may not be shared with other signals)?
0021E2 6E0E           06474                 movwf   R1,0
0021E4 0E02           06475                 movlw   .19-.17                 ;could this be Vdd (pin 19)?
0021E6 1811           06476                 xorwf   R4,W,0
0021E8 E108           06477                 bnz     hunt_notvdd
                      06478 
0021EA 0E1B           06479                 movlw   ET_VBBVDD
0021EC EC61 F00C      06480                 call    etype_getval
0021F0 0B20           06481                 andlw   0x20                    ;any Vdd pin on this EPROM?
0021F2 E003           06482                 bz      hunt_notvdd
                      06483 
0021F4 EE08 F076      06484                 lfsr    0,vdd12v_msg-sstrings   ;"Vdd +12V"
0021F8 D006           06485                 bra     hunt_ppin
0021FA                06486 hunt_notvdd:
                      06487 
                      06488 ;No signal assigned to this pin yet?
0021FA EE08 F080      06489                 lfsr    0,unassign_msg-sstrings ;"/unassigned pin (low)"
                      06490 
0021FE B420           06491                 btfsc   FLAGS1,B_STATE,0
002200 0012           06492                 return
                      06493 
                      06494 ;Fall into hunt_ppin to print message
                      06495 
                      06496 ;----------------------------------------------------------------
                      06497 ; Local subroutine to print a signal name, with a leading slash
                      06498 ; if this pin has already been assigned to another signal
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 96
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      06499 ;On Entry:
                      06500 ;  LFSR0 = string pointer, with slash as leading chr
                      06501 ;  B_STATE set if a signal has already been assigned to this pin
                      06502 ;On Exit:
                      06503 ;  B_STATE is set
                      06504 ;   W,R0,TBLPTR,FSR0 trashed
                      06505 ;----------------------------------------------------------------
002202 A420           06506 hunt_sppin:     btfss   FLAGS1,B_STATE,0        ;does this pin already do something else?
002204 50EE           06507                 movf    POSTINC0,W,0            ;n: bump FSR0 to skip over slash
                      06508 
002206 8420           06509 hunt_ppin:      bsf     FLAGS1,B_STATE          ;this pin is now assigned
                      06510 
                      06511 ;Fall into hprintf
                      06512 
                      06513 ;--------------------------------------------------------------------
                      06514 ;Local subroutines to print a string (saves a bunch of 2-word goto's)
                      06515 ;On Entry:
                      06516 ;  LFSR0 = string pointer
                      06517 ;On Exit:
                      06518 ;   W,R0,TBLPTR,FSR0 trashed
                      06519 ;--------------------------------------------------------------------
002208 EFF8 F009      06520 hprintf:        goto    printf
                      06521 
00220C EF02 F00A      06522 cr_hprintf:     goto    cr_printf
                      06523 
                      06524 ;*==============================================================================*
                      06525 ; Subroutine to print special Vcc and Vpp requirements
                      06526 ; (Placed at the end of code to optimize for rcall and bra instructions)
                      06527 ; On Entry:
                      06528 ;   ETYPE = current EPROM type
                      06529 ; On Exit:
                      06530 ;   R3 = ET_SPECIAL value
                      06531 ; Trashes W,R0,R1,R2
                      06532 ;*==============================================================================*
002210 0E22           06533 special_v:      movlw   ET_SPECIAL              ;does this EPROM require an external power supply, etc.?
002212 EC61 F00C      06534                 call    etype_getval            ;returns Vpp type in bits <3:0>
002216 6E10           06535                 movwf   R3,0                    ;Save for return
                      06536 
                      06537 ;Announce this EPROM's special programming requirements
002218 A010           06538                 btfss   R3,0x00,0               ;Requires programming Vcc adjustment?
00221A D00A           06539                 bra     no_adjvcc
                      06540 
00221C EE04 F0CC      06541                 lfsr    0,adj_msg-sstrings      ;"==>Manually Adjust "
002220 DFF5           06542                 rcall   cr_hprintf
                      06543 
002222 EE04 F0E2      06544                 lfsr    0,adjvcc_msg-sstrings   ;"6.2V supply to "
002226 DFF0           06545                 rcall   hprintf
002228 0E14           06546                 movlw   ET_VCCMSG
00222A 6A0F           06547                 clrf    R2,0                    ;no formatting at eds_print
00222C ECAF F00A      06548                 call    eds_print               ;print the Vcc message from the data structure
                      06549 
002230                06550 no_adjvcc:
002230 A210           06551                 btfss   R3,0x01,0               ;Requires Vpp adjustment?
002232 D019           06552                 bra     no_adjvpp
                      06553 
                      06554 ;Tell user which supply to adjust, and to what voltage
                      06555 
002234 EE04 F0CC      06556                 lfsr    0,adj_msg-sstrings      ;"==>Manually Adjust "
002238 DFE9           06557                 rcall   cr_hprintf
                      06558 
00223A 0E1C           06559                 movlw   ET_VPPSETUP             ;Which Vpp adjustment?
00223C EC61 F00C      06560                 call    etype_getval            ;returns Vpp voltage in bits <6:4>
002240 3A0D           06561                 swapf   R0,F,0
002242 0E07           06562                 movlw   0x07
002244 160D           06563                 andwf   R0,F,0
002246 060D           06564                 decf    R0,F,0                  ;0-3 are the possible supplies
                      06565 
002248 EE07 F0E4      06566                 lfsr    0,v1270_msg-sstrings
00224C 4E0D           06567                 dcfsnz  R0,F,0
00224E EE07 F0EC      06568                 lfsr    0,v1315_msg-sstrings
002252 4E0D           06569                 dcfsnz  R0,F,0
002254 EE07 F0F4      06570                 lfsr    0,v21_msg-sstrings
002258 4E0D           06571                 dcfsnz  R0,F,0
00225A EE07 F0FA      06572                 lfsr    0,v2510_msg-sstrings
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 97
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      06573 
00225E DFD4           06574                 rcall   hprintf
                      06575 
002260 EE04 F0F4      06576                 lfsr    0,vppto_msg-sstrings    ;" Vpp supply to"
002264 D004           06577                 bra     spec_eprint             ;print the adjustment message from the data structure
                      06578 
002266                06579 no_adjvpp:
002266 A410           06580                 btfss   R3,0x02,0               ;Requires external (negative) Vpp power supply?
002268 0012           06581                 return
                      06582 
00226A EE05 F006      06583                 lfsr    0,req_msg-sstrings      ;"Requires "
                      06584 
00226E DFCC           06585 spec_eprint:    rcall   hprintf
                      06586 
002270 0E15           06587                 movlw   ET_VPPMSG               ;ET_VPPMSG is used for both Vpp adjustment and external 
                            Vpp
002272 6A0F           06588                 clrf    R2,0                    ;no formatting at eds_print
002274 EFAF F00A      06589                 goto    eds_print               ;print the Vpp message from the data structure
                      06590 
                      06591 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                      06592 ; Reboot if this firmware does not match the Loader Kernel
                      06593 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
002278 EE0A F0AE      06594 wrong_programmer:   lfsr    0,wrongprog_msg-sstrings
00227C DFC7           06595                     rcall   cr_hprintf
                      06596 
00227E 0EC8           06597                     movlw   .200            ;stall for 50 chr times, to print message
002280 EC1E F000      06598                     call    K_STALL250U
002284 00FF           06599                     reset                   ;let user type L to go to loader
                      06600 
                      06601 ;################################################################################
                      06602 ;#                              Included tables                                 #
                      06603 ;################################################################################
                      06604 
                      06605 ;********************************************************************************
                      06606 ; Voltage Limits Table
                      06607 ; These are rough limits (15% below and above the expected value), intended only
                      06608 ; to detect gross errors and short circuits. They have been calculated to be 15%
                      06609 ; above and below each nominal voltage. (This leaves room for Vpp adjustments
                      06610 ; outside the nominal settings, for peculiar EPROMs.)
                      06611 ;********************************************************************************
002286 694C           06612 LIMTABLE:   dw  0x694c      ;Low limit, high limit for 12.75V supply
002288 6F50           06613             dw  0x6F50      ;Low limit, high limit for 13.15V supply
00228A B482           06614             dw  0xB482      ;Low limit, high limit for 21V supply
00228C D69A           06615             dw  0xD69A      ;Low limit, high limit for 25V supply
                      06616 
                      06617 ;********************************************************************************
                      06618 ; User Commands Table
                      06619 ;********************************************************************************
                      06620     #include    Commands.inc
                      00001 ;********************************************************************
                      00002 ; Main Command Table                                                *
                      00003 ; Each entry is a null terminated ASCII string followed by a 1-byte *
                      00004 ; command index. Index 0 is reserved for non-existant commands.     *
                      00005 ;********************************************************************
00228E 4245 0200      00006 main_cmds:  dw  "EB",0x0200     ;Blank-check EPROM
002292 4445 0400      00007             dw  "ED",0x0400     ;Display EPROM specs
002296 4545 0600      00008             dw  "EE",0x0600     ;edit custom EPROM
00229A 4944 0800      00009             dw  "DI",0x0800     ;Set/clear data invert mode
00229E 4C45 0A00      00010             dw  "EL",0x0A00     ;List supported EPROMs
0022A2 5045 0C00      00011             dw  "EP",0x0C00     ;Program EPROM
0022A6 5245 0E00      00012             dw  "ER",0x0E00     ;Read EPROM into buffer
0022AA 4345 1000      00013             dw  "EC",0x1000     ;Compare to buffer
0022AE 5445 1200      00014             dw  "ET",0x1200     ;Select EPROM type
0022B2 4142 004F 1400 00015             dw  "BAO",0x1400    ;set buffer address offset
0022B8 4146 004F 1600 00016             dw  "FAO",0x1600    ;set file address offset
0022BE 4955 1800      00017             dw  "UI",0x1800     ;upload buffer as Intel hex
0022C2 5355 1A00      00018             dw  "US",0x1A00     ;upload buffer as Motorola S-records
0022C6 4442 1C00      00019             dw  "BD",0x1C00     ;display buffer
0022CA 4542 1E00      00020             dw  "BE",0x1E00     ;Edit buffer
0022CE 4642 2000      00021             dw  "BF",0x2000     ;Fill buffer
0022D2 5344 2200      00022             dw  "DS",0x2200     ;Display settings
0022D6 4345 4F48 2400 00023             dw  "ECHO",0x2400       ;Terminal echo on/off
0022DC 4552 4553 0054 00024             dw  "RESET",0x2600  ;Reset
       2600 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 98
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0022E4 5641 5050 2800 00025             dw  "AVPP",0x2800   ;adjust Vpp
0022EA 4154 0053 2A00 00026             dw  "TAS",0x2A00    ;test -AS
0022F0 5654 4442 2C00 00027             dw  "TVBD",0x2C00   ;test Vbb & Vdd
0022F6 5654 4343 2E00 00028             dw  "TVCC",0x2E00   ;test Vcc
0022FC 4F54 0045 3000 00029             dw  "TOE",0x3000    ;test -OE pin
002302 5054 4D47 3200 00030             dw  "TPGM",0x3200   ;test PGM pin
002308 5054 4F52 0047 00031             dw  "TPROG",0x3400  ;test programming
       3400 
002310 5254 4145 0044 00032             dw  "TREAD",0x3600  ;test EPROM reading
       3600 
002318 4354 0053 3800 00033             dw  "TCS",0x3800    ;test CS pin
00231E 5654 5050 3A00 00034             dw  "TVPP",0x3A00   ;Test Vpp pin
002324 4854 0049 3C00 00035             dw  "THI",0x3C00    ;Test stuck-high pin
00232A 4452 3E00      00036             dw  "RD",0x3E00     ;test data inputs
00232E 4157 4000      00037             dw  "WA",0x4000     ;test address outputs
002332 4457 4200      00038             dw  "WD",0x4200     ;test data outputs
002336 003F 4400      00039             dw  "?",0x4400      ;help
00233A 423F 4600      00040             dw  "?B",0x4600     ;help with buffer commands
00233E 4E3F 4800      00041             dw  "?N",0x4800     ;General ME2700 notes
002342 443F 4A00      00042             dw  "?D",0x4A00     ;help with diagnost commands
002346 453F 4C00      00043             dw  "?E",0x4C00     ;help help with EPROM commands
00234A 463F 4E00      00044             dw  "?F",0x4E00     ;help help with file transfer commands
00234E 4C3F 5000      00045             dw  "?L",0x5000     ;help with loader
002352 5345 5200      00046             dw  "ES",0x5200     ;Checksum EPROM
                      00047 
                      00048     if DEBUG
                      00049             dw  "PW",0x5400     ;Pulse width adjust
                      00050     endif
                      00051 
002356 0000           00052             dw  0               ;table end
                      00053 
                      00054 ;********************************************************************
                      00055 ; EPROM Editor Command Table                                        *
                      00056 ; Each entry is a null terminated ASCII string followed by a 1-byte *
                      00057 ; command index. Index 0 is reserved for non-existant commands.     *
                      00058 ;********************************************************************
002358 5054 4F52 0047 00059 ee_cmds:    dw  "TPROG",0x0200  ;test programming (requires goto)
       0200 
002360 5254 4145 0044 00060             dw  "TREAD",0x0600  ;test EPROM reading (requires goto)
       0600 
002368 4544 454C 4554 00061             dw  "DELETE",0x0A00 ;Delete EPROM
       0A00 
002370 4445 0C00      00062             dw  "ED",0x0C00     ;Display EPROM
002374 4E45 0E00      00063             dw  "EN",0x0E00     ;EPROM name
002378 0051 1000      00064             dw  "Q",0x1000      ;Quit to main
00237C 003F 1200      00065             dw  "?",0x1200      ;Help
002380 4256 0042 1400 00066             dw  "VBB",0x1400    ;Vbb definition
002386 4456 0044 1600 00067             dw  "VDD",0x1600    ;Vdd definition
00238C 3941 1800      00068             dw  "A9",0x1800     ;A9 pin
002390 3141 0030 1A00 00069             dw  "A10",0x1A00    ;A10 pin
002396 3141 0031 1C00 00070             dw  "A11",0x1C00    ;A11 pin
00239C 3141 0032 1E00 00071             dw  "A12",0x1E00    ;A12 pin
0023A2 454F 004E 2000 00072             dw  "OEN",0x2000    ;-OE pin
0023A8 5343 2200      00073             dw  "CS",0x2200     ;CE pin
0023AC 5343 0050 2400 00074             dw  "CSP",0x2400    ;CE polarity
0023B2 4750 004D 2600 00075             dw  "PGM",0x2600    ;PGM pin
0023B8 4750 0050 2800 00076             dw  "PGP",0x2800    ;PGM polarity
0023BE 5050 0050 2A00 00077             dw  "PPP",0x2A00    ;Vpp pin
0023C4 4356 0050 2C00 00078             dw  "VCP",0x2C00    ;VCC voltage during programming
0023CA 454F 0056 2E00 00079             dw  "OEV",0x2E00    ;Special OE voltage during programming
0023D0 5056 0050 3000 00080             dw  "VPP",0x3000    ;Vpp voltage
0023D6 5056 0052 3200 00081             dw  "VPR",0x3200    ;Vpp voltage during reading
0023DC 5550 004C 3400 00082             dw  "PUL",0x3400    ;Programming pulse on pin
0023E2 5450 0055 3600 00083             dw  "PTU",0x3600    ;Pulse time units
0023E8 5050 0057 3800 00084             dw  "PPW",0x3800    ;Programming pulse width
0023EE 5050 0053 3A00 00085             dw  "PPS",0x3A00    ;Programming pulse separation
0023F4 4F50 004C 3C00 00086             dw  "POL",0x3C00    ;EEPROM-style compltion polling
0023FA 5053 0041 3E00 00087             dw  "SPA",0x3E00    ;Simple Programming Algorithm
002400 5046 0031 4000 00088             dw  "FP1",0x4000    ;Fast Pass 1 type
002406 4E46 0031 4200 00089             dw  "FN1",0x4200    ;N value for pass 1
00240C 5046 0032 4400 00090             dw  "FP2",0x4400    ;Fast Pass 2 type
002412 4E46 0032 4600 00091             dw  "FN2",0x4600    ;N value for pass 2
002418 4D50 0058 4800 00092             dw  "PMX",0x4800    ;Max P value or total count
00241E 4646 0031 4A00 00093             dw  "FF1",0x4A00    ;first pass is EEPROM erase to FF
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 99
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

002424 5341 004E 4C00 00094             dw  "ASN",0x4C00    ;Define address strobe pin
00242A 4948 4E00      00095             dw  "HI",0x4E00     ;Define stuck-high pin
00242E 4342 004B 5000 00096             dw  "BCK",0x5000    ;Enable/disable blank check
002434 4F43 5950 5200 00097             dw  "COPY",0x5200   ;Copy EPROM specs
00243A 413F 5400      00098             dw  "?A",0x5400     ;Pin Assignment Help
00243E 503F 5600      00099             dw  "?P",0x5600     ;Programming parameter help
002442 0000           00100             dw  0               ;end of table
                      06621 
                      06622 ;********************************************************************************
                      06623 ; Strings accessed via FSR0
                      06624 ; Unlike TBLPTR, the FSRs can be loaded with a single instruction: LFSR. But
                      06625 ; the LFSR instruction takes a 12-bit literal, creating a 4K-byte limit.
                      06626 ;********************************************************************************
                      06627     #include    ShortStrings.inc
                      00001 ;################################################################################
                      00002 ;# Null-terminated strings                                                      #
                      00003 ;# Strings are located at the beginnig of code, because the LFSR instruction    #
                      00004 ;# demands that they all begin within the first 4K-bytes of program memory.     #
                      00005 ;# This is done so that printf can be called using FSR0, rather than TBLPTR.    #
                      00006 ;# Unlike TBLPTR, the FSRs can be loaded with a single instruction: LFSR. But   #
                      00007 ;# the LFSR instruction takes a 12-bit literal, creating this 4K-byte limit.    #
                      00008 ;################################################################################
002444                00009 sstrings:
002444 7954 6570 3F20 00010 cmdlst_msg:     dw  "Type ? for command list",0
       6620 726F 6320 
       6D6F 616D 646E 
       6C20 7369 0074 
       0000 
                      00011 
00245E 003E 0000      00012 prompt_msg:     dw  ">",0
                      00013 
002462 7548 3F68 0000 00014 bad_input_msg:  dw  "Huh?",0
002468 4545 0000      00015 eeprompt_msg:   dw  "EE",0
                      00016 
00246C 3F20 5220 6365 00017 recerror_msg:   dw  " ? Rec",0
       0000 
002474 3F20 4820 7865 00018 hexerror_msg:   dw  " ? Hex",0
       0000 
00247C 3F20 4320 6D73 00019 cksumerror_msg: dw  " ? Csm",0
       0000 
002484 3F20 4320 746E 00020 rcnterror_msg:  dw  " ? Cnt",0
       0000 
                      00021 
00248C 7542 6666 7265 00022 boffset_msg     dw  "Buffer Address Offset: ",0
       4120 6464 6572 
       7373 4F20 6666 
       6573 3A74 0020 
       0000 
                      00023 
0024A6 2820 6E69 6C63 00024 errorcount_msg: dw  " (including EOF record), Bad "     ;falls into reccount_msg
       6475 6E69 2067 
       4F45 2046 6572 
       6F63 6472 2C29 
       4220 6461 0020 
0024C4 6552 6F63 6472 00025 reccount_msg:   dw  "Records: ",0
       3A73 0020 0000 
0024D0 7220 6365 726F 00026 loadcount_msg:  dw  " records loaded in buffer with "   ;Fall into foffset_msg
       7364 6C20 616F 
       6564 2064 6E69 
       6220 6675 6566 
       2072 6977 6874 
       0020 
0024F0 6946 656C 4120 00027 foffset_msg:    dw  "File Address Offset: ",0
       6464 6572 7373 
       4F20 6666 6573 
       3A74 0020 0000 
002508 003A 0000      00028 int_start_rec:  dw  ":",0                               ;Intel record start
00250C 303A 3030 3030 00029 int_end_rec:    dw  ":00000001FF\r",0                   ;Intel EOF record
       3030 4631 0D46 
       0000 
00251A 3153 0000      00030 mot_start_rec:  dw  "S1",0                              ;Motorola record start
00251E 3953 3330 3030 00031 mot_end_rec:    dw  "S9030000FC\r",0                    ;Motorola EOF record
       3030 4346 000D 
       0000 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 100
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00032 
00252C 454D 4C20 616F 00033 loaderrev_msg:  dw  "ME Loader Kernel version ",0
       6564 2072 654B 
       6E72 6C65 7620 
       7265 6973 6E6F 
       0020 0000 
002548 454D 3732 3030 00034 fwrev_msg:      dw  "ME2700 firmware version "
       6620 7269 776D 
       7261 2065 6576 
       7372 6F69 206E 
002560 2E31           00035         dw  ('.' << 8) + (REV_MAJOR + '0')
002562 3330 0000      00036         dw  (((REV_MINOR & 0x0F) + '0') << 8) + (((REV_MINOR & 0xf0) >> 4) + '0' ),0
                      00037 
002566 7542 6666 7265 00038 buffer_msg:     dw  "Buffer ",0
       0020 0000 
002570 6863 6365 736B 00039 csum_msg:       dw  "checksum: ",0
       6D75 203A 0000 
00257C 6172 676E 2065 00040 range_msg:      dw  "range ",0
       0000 
002584 6345 6F68 003A 00041 echostate_msg:  dw  "Echo:",0
       0000 
00258C 5045 4F52 204D 00042 dinvert_msg:    dw  "EPROM data invert:",0
       6164 6174 6920 
       766E 7265 3A74 
       0000 
0025A0 7542 6666 7265 00043 buffill_msg:    dw  "Buffer filled with ",0
       6620 6C69 656C 
       2064 6977 6874 
       0020 0000 
0025B6 7561 6F74 616D 00044 auto_msg:       dw  "automatic",0
       6974 0063 0000 
                      00045 
0025C2 5045 4F52 204D 00046 eprom_msg:      dw  "EPROM ",0
       0000 
0025CA 6572 6461 6920 00047 read_msg:       dw  "read into buffer. ",0
       746E 206F 7562 
       6666 7265 202E 
       0000 
0025DE 616D 6374 6568 00048 cmpgood_msg:    dw  "matches buffer",0
       2073 7562 6666 
       7265 0000 
0025EE 7369 6220 616C 00049 isblank_msg:    dw  "is blank",0
       6B6E 0000 
0025F8 7954 6570 0020 00050 type_msg:       dw  "Type ",0
       0000 
                      00051 
002600 7257 7469 2065 00052 writefail_msg:  dw  "Write "            ;fall into fail_msg
002606 6146 6C69 0000 00053 fail_msg:       dw  "Fail",0
00260C 7553 6363 7365 00054 success_msg:    dw  "Success",0
       0073 0000 
                      00055 
002616 4120 6F62 7472 00056 abort_msg:      dw  " Abort",0
       0000 
00261E 410D 6F62 7472 00057 pto_msg:        de  "\rAbort: EEPROM polling timeout",0
       203A 4545 5250 
       4D4F 7020 6C6F 
       696C 676E 7420 
       6D69 6F65 7475 
       0000 
00263E 410D 6F62 7472 00058 hvpanic_msg:    dw  "\rAbort: Vpp is too high!",0
       203A 7056 2070 
       7369 7420 6F6F 
       6820 6769 2168 
       0000 
002658 410D 6F62 7472 00059 lvpanic_msg:    dw  "\rAbort: Vpp is too low!",0
       203A 7056 2070 
       7369 7420 6F6F 
       6C20 776F 0021 
       0000 
                      00060 
002672 6146 7473 6120 00061 smartrapid_msg: dw  "Fast algorithm:\r  Pass 1",0
       676C 726F 7469 
       6D68 0D3A 2020 
       6150 7373 3120 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 101
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       0000 
00268C 2020 6150 7373 00062 pass2_msg:      dw  "  Pass 2",0
       3220 0000 
002696 203A 7277 7469 00063 write_msg:      dw  ": write ",0
       2065 0000 
0026A0 4646 2068 6F74 00064 ff_msg:         dw  "FFh to ",0
       0020 0000 
0026AA 6165 6863 6220 00065 eachbyte_msg:   dw  "each byte ",0
       7479 2065 0000 
0026B6 7420 6D69 2865 00066 times_msg:      dw  " time(s)",0
       2973 0000 
0026C0 6E75 6974 206C 00067 matchp_msg:     dw  "until it matches (P)",0
       7469 6D20 7461 
       6863 7365 2820 
       2950 0000 
0026D6 0D2C 2020 2020 00068 andthen_msg:    dw  ",\r          and then ",0
       2020 2020 2020 
       6E61 2064 6874 
       6E65 0020 0000 
0026EE 6E61 746F 6568 00069 another_msg:    dw  "another ",0
       2072 0000 
0026F8 6977 6874 6F20 00070 withone_msg:    dw  "with one ",0
       656E 0020 0000 
002704 2A20 0020 0000 00071 mult_msg:       dw  " * ",0
00270A 7020 6C75 6573 00072 pulse_msg:      dw  " pulse",0
       0000 
                      00073 
002712 7250 676F 6172 00074 programing_msg: dw  "Programming  ",0
       6D6D 6E69 2067 
       0020 0000 
002722 2020 614D 6978 00075 maxp_msg:       dw  "  Maximum P=",0
       756D 206D 3D50 
       0000 
                      00076 
002730 6556 6972 7966 00077 verifying_msg:  dw  "Verifying",0
       6E69 0067 0000 
00273C 7553 7070 726F 00078 elist_msg:      dw  "Supported Device Types:\r",0
       6574 2064 6544 
       6976 6563 5420 
       7079 7365 0D3A 
       0000 
                      00079 
002756 7245 6F72 2072 00080 mismatcha_msg:  dw  "Error at address ",0
       7461 6120 6464 
       6572 7373 0020 
       0000 
00276A 2020 4220 6675 00081 mismatchb_msg:  dw  "   Buffer: ",0
       6566 3A72 0020 
       0000 
002778 2020 4520 5250 00082 mismatche_msg:  dw  "   EPROM"          ;falls into colonspace_msg
       4D4F 
002780 203A 0000      00083 colonspace_msg: dw  ": ",0
                      00084 
002784 6144 6174 5220 00085 dataread_msg:   dw  "Data Read: ",0
       6165 3A64 0020 
       0000 
002792 7543 7272 6E65 00086 etype_msg:      dw  "Current Device Type is ",0
       2074 6544 6976 
       6563 5420 7079 
       2065 7369 0020 
       0000 
0027AC 7245 6F72 3A72 00087 undef_msg:      dw  "Error: Undefined Device Type",0
       5520 646E 6665 
       6E69 6465 4420 
       7665 6369 2065 
       7954 6570 0000 
0027CA 6E55 7361 6973 00088 unassgn_msg:    dw  "Unassigned",0
       6E67 6465 0000 
0027D6 2820 654D 7361 00089 testvpp_msg:    dw  " (Measure at TP3)",0
       7275 2065 7461 
       5420 3350 0029 
       0000 
0027EA 7056 2070 6573 00090 setvpp_msg:     dw  "Vpp set for ",0
       2074 6F66 2072 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 102
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       0000 
                      00091 
0027F8 6F4E 6574 203A 00092 vp18_msg:       dw  "Note: Vpp will be about 0.7V higher on pin 18",0
       7056 2070 6977 
       6C6C 6220 2065 
       6261 756F 2074 
       2E30 5637 6820 
       6769 6568 2072 
       6E6F 7020 6E69 
       3120 0038 0000 
                      00093 
002828 7020 776F 7265 00094 pwroff_msg:     dw  " powered off",0
       6465 6F20 6666 
       0000 
002836 7220 6165 2064 00095 rmode_msg:      dw  " read mode ",0
       6F6D 6564 0020 
       0000 
002844 7020 6F72 7267 00096 pmode_msg:      dw  " programming mode ",0
       6D61 696D 676E 
       6D20 646F 2065 
       0000 
                      00097 
002858 6E69           00098 pinactive_msg:  dw  "in"                    ;fall into pactive_msg
00285A 6361 6974 6576 00099 pactive_msg:    dw  "active state",0
       7320 6174 6574 
       0000 
                      00100 
002868 7056 0070      00101 tvpp_msg:       dw  "Vpp"                   ;fall into pin_msg
00286C 7020 6E69 0020 00102 pin_msg:        dw  " pin ",0
       0000 
                      00103 
002874 6356 0063 0000 00104 tvcc_msg:       dw  "Vcc",0
00287A 6F20 006E 0000 00105 on_msg:         dw  " on",0
002880 6F20 6666 0000 00106 off_msg:        dw  " off",0
002886 6120 2074 7270 00107 apl_msg:        dw  " at programming level",0
       676F 6172 6D6D 
       6E69 2067 656C 
       6576 006C 0000 
00289E 6F64 7365 6E20 00108 nonexist_msg:   dw  "does not exist",0
       746F 6520 6978 
       7473 0000 
0028AE 6256 2062 6E61 00109 novbbvdd_msg:   dw  "Vbb and Vdd do not exist",0
       2064 6456 2064 
       6F64 6E20 746F 
       6520 6978 7473 
       0000 
0028C8 352D 2056 6256 00110 vbb_msg:        dw  "-5V Vbb pin 21 and +12V Vdd",0
       2062 6970 206E 
       3132 6120 646E 
       2B20 3231 2056 
       6456 0064 0000 
                      00111 
0028E6 7550 736C 6E69 00112 pulsing_msg:    dw  "Pulsing  ",0
       2067 0020 0000 
0028F2 6552 6461 6E69 00113 reading_msg:    dw  "Reading  ",0
       2067 0020 0000 
                      00114 
0028FE 7753 7469 6863 00115 swoff_msg:      dw  "Switcher is off",0
       7265 6920 2073 
       666F 0066 0000 
002910 3D3D 203E 614D 00116 adj_msg:        dw  "==> Manually adjust ",0
       756E 6C61 796C 
       6120 6A64 7375 
       2074 0000 
002926 2E36 5632 7320 00117 adjvcc_msg:     dw  "6.2V supply to ",0
       7075 6C70 2079 
       6F74 0020 0000 
002938 5620 7070 7320 00118 vppto_msg:      dw  " Vpp supply to ",0
       7075 6C70 2079 
       6F74 0020 0000 
00294A 3D0D 3E3D 5220 00119 req_msg:        dw  "\r==> Requires ",0
       7165 6975 6572 
       2073 0000 
                      00120 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 103
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00295A 3D3D 203E 6552 00121 readjvcc_msg:   dw  "==> Readjust 6.2V supply to 6.20V",0
       6461 756A 7473 
       3620 322E 2056 
       7573 7070 796C 
       7420 206F 2E36 
       3032 0056 0000 
00297E 3D3D 203E 6552 00122 readjvp_msg:    dw  "==> Readjust Vpp supply to nominal",0
       6461 756A 7473 
       5620 7070 7320 
       7075 6C70 2079 
       6F74 6E20 6D6F 
       6E69 6C61 0000 
0029A2 3D3D 203E 6552 00123 removej_msg:    dw  "==> Remove Intersil jumper & "         ;fall into extneg_msg
       6F6D 6576 4920 
       746E 7265 6973 
       206C 756A 706D 
       7265 2620 0020 
0029C0 7865 6574 6E72 00124 extneg_msg:     dw  "external supply",0
       6C61 7320 7075 
       6C70 0079 0000 
                      00125 
                      00126 
0029D2 6854 2065 5045 00127 notblank_msg:   dw  "The EPROM programming range is not blank"  ;fall into anyway_msg
       4F52 204D 7270 
       676F 6172 6D6D 
       6E69 2067 6172 
       676E 2065 7369 
       6E20 746F 6220 
       616C 6B6E 
0029FA 202E 7250 636F 00128 anyway_msg:     dw  ". Proceed anyway",0
       6565 2064 6E61 
       7779 7961 0000 
                      00129 
002A0C 7250 676F 6172 00130 ppw_msg:        dw  "Programming pulse width: ",0
       6D6D 6E69 2067 
       7570 736C 2065 
       6977 7464 3A68 
       0020 0000 
002A28 202C 6564 616C 00131 ppd_msg:        dw  ", delay between pulses: ",0
       2079 6562 7774 
       6565 206E 7570 
       736C 7365 203A 
       0000 
002A42 337E 3035 6E20 00132 ns500_msg:      dw  "~350 nS",0
       0053 0000 
002A4C 6D20 0053 0000 00133 ms_msg:         dw  " mS",0
002A52 2030 5375 0000 00134 us_msg:         dw  "0 uS",0
002A58 7250 676F 6172 00135 ppr_msg:        dw  "Programming cycles: ",0
       6D6D 6E69 2067 
       7963 6C63 7365 
       203A 0000 
002A6E 2B20 3231 2056 00136 p12v_msg:       dw  " +12V during programming",0
       7564 6972 676E 
       7020 6F72 7267 
       6D61 696D 676E 
       0000 
002A88 7056 2070 7564 00137 rvppat_msg:     dw  "Vpp during read: ",0
       6972 676E 7220 
       6165 3A64 0020 
       0000 
002A9C 7550 736C 6465 00138 pvpp_msg:       dw  "Pulsed from ",0
       6620 6F72 206D 
       0000 
002AAA 7420 206F 0000 00139 to_msg:         dw  " to ",0
002AB0 202C 6973 657A 00140 esize_msg:      dw  ", size: ",0
       203A 0000 
002ABA 7820 0020 0000 00141 by_msg:         dw  " x ",0
002AC0 6F4E 6220 616C 00142 eeprom_msg:     dw  "No blank check before programming",0
       6B6E 6320 6568 
       6B63 6220 6665 
       726F 2065 7270 
       676F 6172 6D6D 
       6E69 0067 0000 
002AE4 7250 676F 6172 00143 propulse_msg:   dw  "Programming pulse on ",0
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 104
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6D6D 6E69 2067 
       7570 736C 2065 
       6E6F 0020 0000 
002AFC 6F50 6C6C 6420 00144 poll_msg:       dw  "Poll data for write completion",0
       7461 2061 6F66 
       2072 7277 7469 
       2065 6F63 706D 
       656C 6974 6E6F 
       0000 
                      00145 
002B1C 6146 7473 7020 00146 sfail_msg:      dw  "Fast programming failed",0
       6F72 7267 6D61 
       696D 676E 6620 
       6961 656C 0064 
       0000 
                      00147 
002B36 6420 7665 6369 00148 ep_msg:         dw  " devices programmed ",0
       7365 7020 6F72 
       7267 6D61 656D 
       2064 0000 
002B4C 6E75           00149 epf_msg:        dw  "un"        ;fall into eps_msg
002B4E 7573 6363 7365 00150 eps_msg:        dw  "successfully",0
       6673 6C75 796C 
       0000 
                      00151 
002B5C 6E4F 796C 4420 00152 cantedit_msg:   dw  "Only Device Types "
       7665 6369 2065 
       7954 6570 2073 
                      00153  if (FEPROM_COUNT & 0x0F) < 0x0A
002B6E 3832           00154                 dw  ((FEPROM_COUNT>>4)+'0') + (((FEPROM_COUNT & 0x0F)+'0')<<8)
                      00155  else
                      00156                 dw  ((FEPROM_COUNT>>4)+'0') + (((FEPROM_COUNT & 0x0F)-0x0A + 'A')<<8)
                      00157  endif
002B70 7420 7268 756F 00158                 dw  " through "
       6867 0020 
                      00159  if ((FEPROM_COUNT+3) & 0x0F) < 0x0A
                      00160                 dw  (((FEPROM_COUNT+3)>>4)+'0') + ((((FEPROM_COUNT+3) & 0x0F)+'0')<<8)
                      00161  else
002B7A 4232           00162                 dw  (((FEPROM_COUNT+3)>>4)+'0') + ((((FEPROM_COUNT+3) & 0x0F)-0x0A + 'A')<<8)
                      00163  endif
002B7C 6320 6E61 6220 00164                 dw  " can be edited.",0
       2065 6465 7469 
       6465 002E 0000 
                      00165 
002B8E 7245 6F72 3A72 00166 novpp_msg:      dw  "Error: Vpp may only be on pins 18, 20, or 21",0
       5620 7070 6D20 
       7961 6F20 6C6E 
       2079 6562 6F20 
       206E 6970 736E 
       3120 2C38 3220 
       2C30 6F20 2072 
       3132 0000 
002BBC 7245 6F72 3A72 00167 oeverr_msg:     dw  "Error: -OE may be set to +12V on pins 19 and 20 only",0
       2D20 454F 6D20 
       7961 6220 2065 
       6573 2074 6F74 
       2B20 3231 2056 
       6E6F 7020 6E69 
       2073 3931 6120 
       646E 3220 2030 
       6E6F 796C 0000 
002BF2 7245 6F72 3A72 00168 oevperr_msg:    dw  "Error: -OE is currently also Vpp",0
       2D20 454F 6920 
       2073 7563 7272 
       6E65 6C74 2079 
       6C61 6F73 5620 
       7070 0000 
                      00169 
002C14 5630 0000      00170 v0_msg:         dw  "0V",0
002C18 5635 0000      00171 v5_msg:         dw  "5V",0
002C1C 2E36 5632 0000 00172 v6_msg:         dw  "6.2V",0
002C22 3231 0056 0000 00173 v12_msg:        dw  "12V",0
                      00174 
002C28 3231 372E 0056 00175 v1270_msg:      dw  "12.7V",0       ;These are for Vpp on pins 19-21
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 105
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       0000 
002C30 3331 312E 5635 00176 v1315_msg:      dw  "13.15V",0
       0000 
002C38 3132 0056 0000 00177 v21_msg:        dw  "21V",0
002C3E 3532 322E 0056 00178 v2510_msg:      dw  "25.2V",0
       0000 
                      00179 
002C46 3331 342E 0056 00180 v1340_msg:      dw  "13.4V",0       ;these are for Vpp on pin 18 only
       0000 
002C4E 3331 382E 5635 00181 v1385_msg:      dw  "13.85V",0
       0000 
002C56 3132 372E 0056 00182 v2170_msg:      dw  "21.7V",0
       0000 
002C5E 3532 392E 0056 00183 v2590_msg:      dw  "25.9V",0
       0000 
                      00184 
002C66 3941 0000      00185 A9_msg:         dw  "A9",0
002C6A 3141 0030 0000 00186 A10_msg:        dw  "A10",0
002C70 3141 0031 0000 00187 A11_msg:        dw  "A11",0
002C76 3141 0032 0000 00188 A12_msg:        dw  "A12",0
002C7C 7453 6375 2D6B 00189 stuckhi_msg:    dw  "Stuck-High",0
       6948 6867 0000 
002C88 412D 0053 0000 00190 as_msg:         dw  "-AS",0
002C8E 4F2D 0045 0000 00191 oe_msg:         dw  "-OE",0
002C94 002D           00192 csn_msg:        dw  "-"             ;fall into cs_msg
002C96 5343 0000      00193 cs_msg:         dw  "CS",0
002C9A 2D2F 4750 004D 00194 pgmn_msg:       dw  "/-PGM",0
       0000 
002CA2 502F 4D47 0000 00195 pgm_msg:        dw  "/PGM",0
002CA8 562F 7070 0020 00196 vpp_msg:        dw  "/Vpp ",0
       0000 
002CB0 6256 2062 352D 00197 vbb5v_msg:      dw  "Vbb -5V",0
       0056 0000 
002CBA 6456 2064 312B 00198 vdd12v_msg:     dw  "Vdd +12V",0
       5632 0000 
002CC4 532F 7574 6B63 00199 unassign_msg:   dw  "/Stuck-Low",0
       4C2D 776F 0000 
                      00200 
002CD0 2020 2020 0020 00201 space7_msg:     dw  "     "         ;fall into space2_msg
002CD6 2020 0000      00202 space2_msg:     dw  "  ",0
                      00203 
                      00204 ;                    123456789012345678901234567890123456789012345678901234567890
002CDA 2020 2020 2020 00205 ep1_msg:        dw  "       -----v-----\r"
       2D20 2D2D 2D2D 
       2D76 2D2D 2D2D 
       000D 
002CEE 4120 2037 2D20 00206                 dw  " A7  -| 1      24 |-  Vcc     Programming Vcc = ",0
       207C 2031 2020 
       2020 3220 2034 
       2D7C 2020 6356 
       2063 2020 2020 
       7250 676F 6172 
       6D6D 6E69 2067 
       6356 2063 203D 
       0000 
002D20 4120 2036 2D20 00207 ep2_msg:        dw  " A6  -| 2      23 |-  A8\r"
       207C 2032 2020 
       2020 3220 2033 
       2D7C 2020 3841 
       000D 
002D3A 4120 2035 2D20 00208                 dw  " A5  -| 3      22 |-  ",0
       207C 2033 2020 
       2020 3220 2032 
       2D7C 2020 0000 
002D52 4120 2034 2D20 00209 ep3_msg:        dw  " A4  -| 4      21 |-  ",0
       207C 2034 2020 
       2020 3220 2031 
       2D7C 2020 0000 
002D6A 4120 2033 2D20 00210 ep4_msg:        dw  " A3  -| 5      20 |-  ",0
       207C 2035 2020 
       2020 3220 2030 
       2D7C 2020 0000 
002D82 4120 2032 2D20 00211 ep5_msg:        dw  " A2  -| 6      19 |-  ",0
       207C 2036 2020 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 106
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       2020 3120 2039 
       2D7C 2020 0000 
002D9A 4120 2031 2D20 00212 ep6_msg:        dw  " A1  -| 7      18 |-  ",0
       207C 2037 2020 
       2020 3120 2038 
       2D7C 2020 0000 
002DB2 4120 2030 2D20 00213 ep7_msg:        dw  " A0  -| 8      17 |-  D7",0
       207C 2038 2020 
       2020 3120 2037 
       2D7C 2020 3744 
       0000 
002DCC 4420 2030 2D20 00214 ep8_msg:        dw  " D0  -| 9      16 |-  D6",0
       207C 2039 2020 
       2020 3120 2036 
       2D7C 2020 3644 
       0000 
002DE6 4420 2031 2D20 00215 ep9_msg:        dw  " D1  -| 10     15 |-  D5",0
       207C 3031 2020 
       2020 3120 2035 
       2D7C 2020 3544 
       0000 
002E00 4420 2032 2D20 00216 ep10_msg:       dw  " D2  -| 11     14 |-  D4",0
       207C 3131 2020 
       2020 3120 2034 
       2D7C 2020 3444 
       0000 
002E1A 4E47 2044 2D20 00217 ep11_msg:       dw  "GND  -| 12     13 |-  D3",0
       207C 3231 2020 
       2020 3120 2033 
       2D7C 2020 3344 
       0000 
002E34 2020 2020 2020 00218 ep12_msg:       dw  "       -----------      ",0
       2D20 2D2D 2D2D 
       2D2D 2D2D 2D2D 
       2020 2020 2020 
       0000 
                      00219 
002E4E 2020 2020 2020 00220 supdev_msg:     dw  "      Supported Devices:",0
       7553 7070 726F 
       6574 2064 6544 
       6976 6563 3A73 
       0000 
                      00221 
002E68 6544 656C 6574 00222 delce_msg:      dw  "Delete Device Type",0
       4420 7665 6369 
       2065 7954 6570 
       0000 
                      00223 
002E7C 5045 4F52 204D 00224 gname_msg:      dw  "EPROM Device Type is unassigned until it is named. (EN command)",0
       6544 6976 6563 
       5420 7079 2065 
       7369 7520 616E 
       7373 6769 656E 
       2064 6E75 6974 
       206C 7469 6920 
       2073 616E 656D 
       2E64 2820 4E45 
       6320 6D6F 616D 
       646E 0029 0000 
                      00225 
002EBE 7257 6E6F 2067 00226 wrongkern_msg:  dw  "Wrong ME Loader Kernel revision for this firmware!",0
       454D 4C20 616F 
       6564 2072 654B 
       6E72 6C65 7220 
       7665 7369 6F69 
       206E 6F66 2072 
       6874 7369 6620 
       7269 776D 7261 
       2165 0000 
002EF2 7257 6E6F 2067 00227 wrongprog_msg:  dw  "Wrong firmware for this programmer!\r",0
       6966 6D72 6177 
       6572 6620 726F 
       7420 6968 2073 
       7270 676F 6172 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 107
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6D6D 7265 0D21 
       0000 
                      00228 
002F18 614D 656B 7320 00229 ready2prog_msg: dw  "Make sure the correct Device Type is selected, and that the EPROM\r"
       7275 2065 6874 
       2065 6F63 7272 
       6365 2074 6544 
       6976 6563 5420 
       7079 2065 7369 
       7320 6C65 6365 
       6574 2C64 6120 
       646E 7420 6168 
       2074 6874 2065 
       5045 4F52 0D4D 
002F5A 7369 6920 736E 00230                 dw  "is inserted correctly, with pin 1 closest to the socket handle.\r"
       7265 6574 2064 
       6F63 7272 6365 
       6C74 2C79 7720 
       7469 2068 6970 
       206E 2031 6C63 
       736F 7365 2074 
       6F74 7420 6568 
       7320 636F 656B 
       2074 6168 646E 
       656C 0D2E 
002F9A 6552 6461 2079 00231                 dw  "Ready to program",0
       6F74 7020 6F72 
       7267 6D61 0000 
                      00232 
                      00233  if DEBUG
                      00234 shared_msg:     dw  "SHARED: ",0
                      00235  endif
                      00236 
                      00237 ;Longest message last
002FAC                00238 ss_almostend:
                      00239 
002FAC 2A0D 3D3D 3D3D 00240 signon_msg: dw  "\r*====================================*\r"
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 0D2A 
002FD4 202A 2020 2020 00241             dw  "*               ME2700               *\r"
       2020 2020 2020 
       2020 2020 454D 
       3732 3030 2020 
       2020 2020 2020 
       2020 2020 2020 
       2A20 000D 
002FFC 3D2A 3D3D 3D3D 00242             dw  "*====================================*\r"
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       2A3D 000D 
003024 202A 2020 2020 00243             dw  "*       Orphan EPROM Programmer      *\r"
       2020 724F 6870 
       6E61 4520 5250 
       4D4F 5020 6F72 
       7267 6D61 656D 
       2072 2020 2020 
       2A20 000D 
00304C 202A 2020 2020 00244             dw  "*         By Martin Eberhard         *\r"
       2020 2020 7942 
       4D20 7261 6974 
       206E 6245 7265 
       6168 6472 2020 
       2020 2020 2020 
       2A20 000D 
003074 202A 2020 2020 00245             dw  "*       Firmware Version  "
       2020 6946 6D72 
       6177 6572 5620 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 108
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       7265 6973 6E6F 
       2020 
00308E 2E31           00246             dw  (REV_MAJOR + '0') + ('.' << 8)
003090 3330           00247             dw  (((REV_MINOR & 0xf0) >> 4) + '0' ) + (((REV_MINOR & 0x0F) + '0') << 8)
003092 2020 2020 2020 00248             dw  "       *\r"
       2A20 000D 
00309C 3D2A 3D3D 3D3D 00249             dw  "*====================================*\r\r",0
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       3D3D 3D3D 3D3D 
       2A3D 0D0D 0000 
                      00250 
                      00251 ;*==============================================================================*
                      00252 ; Print an error message in the listing if this is section too big
                      00253 ;*==============================================================================*
                      00254     if  ss_almostend-sstrings > .4095
                      00255     error   "Martin sez: ShortStrings section is long!"
                      00256     endif
                      00257 
                      06628 
                      06629 ;********************************************************************************
                      06630 ; EPROM definition table
                      06631 ;********************************************************************************
                      06632     #include    EPROMTABLE.inc
                      00001 ;********************************************************************************
                      00002 ; EPROM Configuration Table. (See EPROMStructure file for explaination.)
                      00003 ; Note: you can't use the db directive here.
                      00004 ;********************************************************************************
0030C6                00005 eprom_table:
                      00006 
                      00007 ;+----+
                      00008 ;+ 00 +
                      00009 ;+---------------------------+
                      00010 ;+ Generic 2704 (3 supplies) +
                      00011 ;+---------------------------+
0030C6                00012 ep_2704:
0030C6 FF29           00013     dw      (0xFF<<8)+(es_2704-estrings)/8                          ;(ET_NAME)
                      00014 
0030C8 290E           00015     dw      (((es_2704-estrings)/8)<<8)+(es_intel-estrings)/8       ;(ET_PARTNO1)
0030CA 8A15           00016     dw      (((es_mm2704-estrings)/8)<<8)+(es_national-estrings)/8  ;(ET_PARTNO2)
0030CC 2920           00017     dw      (((es_2704-estrings)/8)<<8)+(es_signetics-estrings)/8   ;(ET_PARTNO3)
0030CE FFFF           00018     dw      0xFFFF              ;(ET_PARTNO4) null
0030D0 FFFF           00019     dw      0xFFFF              ;(ET_PARTNO5) null
0030D2 FFFF           00020     dw      0xFFFF              ;(ET_PARTNO6) null
0030D4 FFFF           00021     dw      0xFFFF              ;(ET_PARTNO7) null
0030D6 FFFF           00022     dw      0xFFFF              ;(ET_PARTNO8) null
0030D8 FFFF           00023     dw      0xFFFF              ;(ET_PARTNO9) null
0030DA FFFF           00024     dw      0xFFFF              ;(ET_PARTNO10) null
                      00025 
0030DC 0081           00026     dw      0x0081              ;(ET_BYTES)512 bytes, 8 bits/byte
                      00027                                 ;(ET_A9A10)no A9 pin, no A10 pin
                      00028 
0030DE B000           00029     dw      0xB000              ;(ET_A11A12)no A11 pin, no A12 pin, no A11 pin
                      00030                                 ;(ET_OECS)+12V -OE on pin 20, no CS pin
                      00031 
0030E0 3101           00032     dw      0x3101              ;(ET_PGMVPP)no PGM pin, Vpp on pin 18
                      00033                                 ;(ET_VBBVDD)Vbb=-5V & Vdd=12V, Vcc=5V
                      00034 
0030E2 7040           00035     dw      (.112<<8)+0x40      ;(ET_VPPSETUP)Vpp = 26V, 0V during read, Pulsed Vpp, return to 0V
                      00036                                 ;(ET_PROGREPS) 112 repetitions
                      00037 
0030E4 005A           00038     dw      (0x00<<8)+.90       ;(ET_PROGPULSE) 900 uS programming pulse width
                      00039                                 ;(ET_PPDELAY) no delay between pulses
                      00040 
0030E6 0000           00041     dw      0x0000              ;(ET_SMART1) No smart programming
                      00042                                 ;(ET_SMART2)
                      00043 
0030E8 0000           00044     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00045                                 ;(ET_RESERVED)
                      00046 
                      00047 ;+----+
                      00048 ;+ 01 +
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 109
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00049 ;+--------------------------+
                      00050 ;+ 512x8 EEPROM, no polling +
                      00051 ;+--------------------------+
0030EA                00052 ep_2804a:
0030EA FF2A           00053     dw      (0xFF<<8)+(es_2804a-estrings)/8                         ;(ET_NAME)
                      00054 
0030EC 6707           00055     dw      (((es_xl2804a-estrings)/8)<<8)+(es_exel-estrings)/8     ;(ET_PARTNO1)
0030EE 2A1D           00056     dw      (((es_2804a-estrings)/8)<<8)+(es_seeq-estrings)/8       ;(ET_PARTNO2)
0030F0 B928           00057     dw      (((es_x2804a-estrings)/8)<<8)+(es_xicor-estrings)/8     ;(ET_PARTNO3)
0030F2 FFFF           00058     dw      0xFFFF              ;(ET_PARTNO4) null
0030F4 FFFF           00059     dw      0xFFFF              ;(ET_PARTNO5) null
0030F6 FFFF           00060     dw      0xFFFF              ;(ET_PARTNO6) null
0030F8 FFFF           00061     dw      0xFFFF              ;(ET_PARTNO7) null
0030FA FFFF           00062     dw      0xFFFF              ;(ET_PARTNO8) null
0030FC FFFF           00063     dw      0xFFFF              ;(ET_PARTNO9) null
0030FE FFFF           00064     dw      0xFFFF              ;(ET_PARTNO10) null
                      00065 
003100 0081           00066     dw      0x0081              ;(ET_BYTES)512 bytes, 8 bits/byte
                      00067                                 ;(ET_A9A10)No A9, no A10
                      00068 
003102 3100           00069     dw      0x3100              ;(ET_A11A12)no A11 pin, no A12 pin
                      00070                                 ;(ET_OECS)-OE on pin 20, active-low CS on pin 18
                      00071 
003104 0140           00072     dw      0x0140              ;(ET_PGMVPP)active-low PGM on pin 21, no Vpp pin
                      00073                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00074 
003106 0106           00075     dw      (.01<<8)+0x06       ;(ET_VPPSETUP)Vpp switcher off, 5V during read, pulsed PGM
                      00076                                 ;(ET_PROGREPS) write once
                      00077 
003108 8C00           00078     dw      ((.12+80h)<<8)+0x00 ;(ET_PROGPULSE) 250 nS programming pulse width
                      00079                                 ;(ET_PPDELAY) 12 mS between writes
                      00080 
00310A 0000           00081     dw      0x0000              ;(ET_SMART1) No smart programming
                      00082                                 ;(ET_SMART2)
                      00083 
00310C 0008           00084     dw      0x0008              ;(ET_SPECIAL) no blank check
                      00085                                 ;(ET_RESERVED)
                      00086 
                      00087 ;+----+
                      00088 ;+ 02 +
                      00089 ;+--------------+
                      00090 ;+ 512x8 EEPROM +
                      00091 ;+--------------+
00310E                00092 ep_28C04:
00310E FF2B           00093     dw      (0xFF<<8)+(es_28c04-estrings)/8                         ;(ET_NAME)
                      00094 
003110 5B02           00095     dw      (((es_at28c04-estrings)/8)<<8)+(es_atmel-estrings)/8    ;(ET_PARTNO1)
003112 2B0B           00096     dw      (((es_28c04-estrings)/8)<<8)+(es_gi-estrings)/8         ;(ET_PARTNO2)
003114 8010           00097     dw      (((es_28c04a-estrings)/8)<<8)+(es_microchip-estrings)/8 ;(ET_PARTNO3)
003116 FFFF           00098     dw      0xFFFF              ;(ET_PARTNO4) null
003118 FFFF           00099     dw      0xFFFF              ;(ET_PARTNO5) null
00311A FFFF           00100     dw      0xFFFF              ;(ET_PARTNO6) null
00311C FFFF           00101     dw      0xFFFF              ;(ET_PARTNO7) null
00311E FFFF           00102     dw      0xFFFF              ;(ET_PARTNO8) null
003120 FFFF           00103     dw      0xFFFF              ;(ET_PARTNO9) null
003122 FFFF           00104     dw      0xFFFF              ;(ET_PARTNO10) null
                      00105 
003124 0081           00106     dw      0x0081              ;(ET_BYTES)512 bytes, 8 bits/byte
                      00107                                 ;(ET_A9A10)No A9, no A10
                      00108 
003126 3100           00109     dw      0x3100              ;(ET_A11A12)no A11 pin, no A12 pin
                      00110                                 ;(ET_OECS)-OE on pin 20, active-low CS on pin 18
                      00111 
003128 0140           00112     dw      0x0140              ;(ET_PGMVPP)active-low PGM on pin 21, no Vpp pin
                      00113                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00114 
00312A 0106           00115     dw      (.01<<8)+0x06       ;(ET_VPPSETUP)Vpp = switcher off, 5V during read, pulsed PGM
                      00116                                 ;(ET_PROGREPS) write once
                      00117 
00312C 0100           00118     dw      0x0100              ;(ET_PROGPULSE) 250 nS programming pulse width
                      00119                                 ;(ET_PPDELAY) poll for completion between pulses
                      00120 
00312E 0000           00121     dw      0x0000              ;(ET_SMART1) No smart programming
                      00122                                 ;(ET_SMART2)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 110
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00123 
003130 0008           00124     dw      0x0008              ;(ET_SPECIAL) no blank check
                      00125                                 ;(ET_RESERVED)
                      00126 
                      00127 ;+----+
                      00128 ;+ 03 +
                      00129 ;+--------------------------------+
                      00130 ;+ Intersil IM6654                +
                      00131 ;+ Requires external negative Vpp +
                      00132 ;+--------------------------------+
003132                00133 ep_IM6654:
003132 FF2C           00134     dw      (0xFF<<8)+(es_im6654-estrings)/8                        ;(ET_NAME)
                      00135 
003134 2C0F           00136     dw      (((es_im6654-estrings)/8)<<8)+(es_intersil-estrings)/8  ;(ET_PARTNO1)
003136 FFFF           00137     dw      0xFFFF              ;(ET_PARTNO2) null
003138 FFFF           00138     dw      0xFFFF              ;(ET_PARTNO3) null
00313A FFFF           00139     dw      0xFFFF              ;(ET_PARTNO4) null
00313C FFFF           00140     dw      0xFFFF              ;(ET_PARTNO5) null
00313E FFFF           00141     dw      0xFFFF              ;(ET_PARTNO6) null
003140 FFFF           00142     dw      0xFFFF              ;(ET_PARTNO7) null
003142 FFFF           00143     dw      0xFFFF              ;(ET_PARTNO8) null
003144 FFFF           00144     dw      0xFFFF              ;(ET_PARTNO9) null
                      00145 
003146 C2FF           00146     dw      (((es_n40v-estrings)/8)<<8)+0xFF    ;(ET_VPPMSG)
                      00147                                                 ;(ET_VCCMSG) null
                      00148 
003148 0081           00149     dw      0x0081                  ;(ET_BYTES)512 bytes, 8 bits/byte
                      00150                                     ;(ET_A9A10)no A9, no A10
                      00151 
00314A 40AB           00152     dw      0x40AB                  ;(ET_A11A12)Pin 19 stuck-high (+5V Vdd), -Address Strobe (-AS) on pi
                            n 20
                      00153                                     ;(ET_OECS)-OE on pin 21, no CS pin
                      00154 
00314C 0101           00155     dw      0x0101                  ;(ET_PGMVPP)No PGM pin, Vpp on pin 18
                      00156                                     ;(ET_VBBVDD)no Vbb or Vdd (Vdd pin 19 is a stuck-high pin)
                      00157 
00314E 0255           00158     dw      (.2<<8)+0x55            ;(ET_VPPSETUP)External Vpp, 5V during read, pulsed Vpp, return to +5
                            V
                      00159                                     ;(ET_PROGREPS) max 2 passes for P
                      00160 
003150 8794           00161     dw      ((.7+0x80)<<8)+.20+0x80 ;(ET_PROGPULSE) 20 mS programming pulse width
                      00162                                     ;(ET_PPDELAY) 7 mS delay between pulses
                      00163 
003152 0024           00164     dw      0x0024                  ;(ET_SMART1) P+4P smart programming
                      00165                                     ;(ET_SMART1) no second pass
                      00166 
003154 0004           00167     dw      0x0004                  ;(ET_SPECIAL)requires external negative Vpp
                      00168                                     ;(ET_RESERVED)
                      00169 
                      00170 ;+----+
                      00171 ;+ 04 +
                      00172 ;+---------------------------+
                      00173 ;+ Generic 2708 (3 supplies) +
                      00174 ;+---------------------------+
003156                00175 ep_2708:
003156 FF2D           00176     dw      (0xFF<<8)+(es_2708-estrings)/8                              ;(ET_NAME)
                      00177 
003158 5401           00178     dw      (((es_am2708-estrings)/8)<<8)+(es_amd-estrings)/8           ;(ET_PARTNO1)
00315A 6604           00179     dw      (((es_ea2708-estrings)/8)<<8)+(es_elecarrays-estrings)/8    ;(ET_PARTNO2)
00315C 6E08           00180     dw      (((es_f2708-estrings)/8)<<8)+(es_fairchild-estrings)/8      ;(ET_PARTNO3)
00315E 2D0E           00181     dw      (((es_2708-estrings)/8)<<8)+(es_intel-estrings)/8           ;(ET_PARTNO4)
003160 8313           00182     dw      (((es_u555c-estrings)/8)<<8)+(es_mme-estrings)/8            ;(ET_PARTNO5)
003162 8B15           00183     dw      (((es_mm2708-estrings)/8)<<8)+(es_national-estrings)/8      ;(ET_PARTNO6)
003164 9318           00184     dw      (((es_nte2708-estrings)/8)<<8)+(es_nte-estrings)/8          ;(ET_PARTNO7)
003166 2D20           00185     dw      (((es_2708-estrings)/8)<<8)+(es_signetics-estrings)/8       ;(ET_PARTNO8)
003168 A424           00186     dw      (((es_mhb8708c-estrings)/8)<<8)+(es_tesla-estrings)/8       ;(ET_PARTNO9)
00316A A825           00187     dw      (((es_tms2708-estrings)/8)<<8)+(es_ti-estrings)/8           ;(ET_PARTNO10)
                      00188 
00316C 5082           00189     dw      0x5082              ;(ET_BYTES)1024 bytes, 8 bits/byte
                      00190                                 ;(ET_A9A10)A9 on pin 22, no A10 pin
                      00191 
00316E B000           00192     dw      0xB000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00193                                 ;(ET_OECS)+12V -OE on pin 20, no CS pin
                      00194 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 111
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

003170 3101           00195     dw      0x3101              ;(ET_PGMVPP)no PGM pin, Vpp on pin 18
                      00196                                 ;(ET_VBBVDD)Vbb=-5V & Vdd=12V, Vcc = 5V
                      00197 
003172 7040           00198     dw      (.112<<8)+0x40      ;(ET_VPPSETUP)Vpp = 26V, 0V during read, Pulsed Vpp, return to 0V
                      00199                                 ;(ET_PROGREPS) 112 repetitions
                      00200 
003174 005A           00201     dw      (0x00<<8)+.90       ;(ET_PROGPULSE) 900 uS programming pulse width
                      00202                                 ;(ET_PPDELAY) no delay between pulses
                      00203 
003176 0000           00204     dw      0x0000              ;(ET_SMART1) No smart programming
                      00205                                 ;(ET_SMART2)
                      00206 
003178 0000           00207     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00208                                 ;(ET_RESERVED)
                      00209 
                      00210 ;+----+
                      00211 ;+ 05 +
                      00212 ;+---------------------------+
                      00213 ;+ Single-voltage 1Kx8 EPROM +
                      00214 ;+ (Made from half of a 2716)+
                      00215 ;+---------------------------+
00317A                00216 ep_2758:
00317A FF2E           00217     dw      (0xFF<<8)+(es_2758-estrings)/8                          ;(ET_NAME)
                      00218 
00317C 790C           00219     dw      (((es_hm6758-estrings)/8)<<8)+(es_harris-estrings)/8    ;(ET_PARTNO1)
00317E 2E0E           00220     dw      (((es_2758-estrings)/8)<<8)+(es_intel-estrings)/8       ;(ET_PARTNO2)
003180 8E15           00221     dw      (((es_mm2758A-estrings)/8)<<8)+(es_national-estrings)/8 ;(ET_PARTNO3)
003182 971A           00222     dw      (((es_msm2758-estrings)/8)<<8)+(es_oki-estrings)/8      ;(ET_PARTNO4)
003184 A525           00223     dw      (((es_tms2508-estrings)/8)<<8)+(es_ti-estrings)/8       ;(ET_PARTNO5)
003186 A925           00224     dw      (((es_tms2758jl0-estrings)/8)<<8)+(es_ti-estrings)/8    ;(ET_PARTNO6)
003188 FFFF           00225     dw      0xFFFF              ;(ET_PARTNO7) null
00318A FFFF           00226     dw      0xFFFF              ;(ET_PARTNO8) null
00318C FFFF           00227     dw      0xFFFF              ;(ET_PARTNO9) null
00318E FFFF           00228     dw      0xFFFF              ;(ET_PARTNO10) null
                      00229 
003190 5082           00230     dw      0x5082              ;(ET_BYTES)1024 bytes, 8 bits/byte
                      00231                                 ;(ET_A9A10)A9 on pin 22, no A10 pin
                      00232 
003192 3000           00233     dw      0x3000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00234                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      00235 
003194 0194           00236     dw      0x0194              ;(ET_PGMVPP)active-high PGM on pin 18, Vpp on pin 21
                      00237                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00238 
003196 0146           00239     dw      (.01<<8)+0x46       ;(ET_VPPSETUP)Vpp = 26V, 5V during read, Pulsed PGM
                      00240                                 ;(ET_PROGREPS) write once
                      00241 
003198 00B2           00242     dw      (0x00<<8)+.50+0x80  ;(ET_PROGPULSE) 50 mS programming pulse width
                      00243                                 ;(ET_PPDELAY) no delay between pulses
                      00244 
00319A 0000           00245     dw      0x0000              ;(ET_SMART1) No smart programming
                      00246                                 ;(ET_SMART2)
                      00247 
00319C 0000           00248     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00249                                 ;(ET_RESERVED)
                      00250 
                      00251 ;+----+
                      00252 ;+ 06 +
                      00253 ;+------------------------+
                      00254 ;+ Generic 2716 (Vpp=25V) +
                      00255 ;+------------------------+
00319E                00256 ep_2716:
00319E FF2F           00257     dw      (0xFF<<8)+(es_2716-estrings)/8                          ;(ET_NAME)
                      00258 
                      00259 ;   dw      (((es_et2716q-estrings)/8)<<8)+(es_eurotech-estrings)/8 ;(also)
                      00260 ;   dw      (((es_nte2716-estrings)/8)<<8)+(es_nte-estrings)/8      ;(also)
                      00261 
0031A0 5501           00262     dw      (((es_am2716-estrings)/8)<<8)+(es_amd-estrings)/8       ;(ET_PARTNO1)
0031A2 7609           00263     dw      (((es_mbm2716-estrings)/8)<<8)+(es_fujitsu-estrings)/8  ;(ET_PARTNO2)
0031A4 7C0D           00264     dw      (((es_hn462716-estrings)/8)<<8)+(es_hitachi-estrings)/8 ;(ET_PARTNO3)
0031A6 2F0E           00265     dw      (((es_2716-estrings)/8)<<8)+(es_intel-estrings)/8       ;(ET_PARTNO4)
0031A8 8C15           00266     dw      (((es_mm2716e-estrings)/8)<<8)+(es_national-estrings)/8 ;(ET_PARTNO5)
0031AA 951A           00267     dw      (((es_msm2716as-estrings)/8)<<8)+(es_oki-estrings)/8    ;(ET_PARTNO6)
0031AC 9E23           00268     dw      (((es_m2716-estrings)/8)<<8)+(es_st-estrings)/8         ;(ET_PARTNO7)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 112
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0031AE 2F20           00269     dw      (((es_2716-estrings)/8)<<8)+(es_signetics-estrings)/8   ;(ET_PARTNO8)
0031B0 9C22           00270     dw      (((es_573RF2-estrings)/8)<<8)+(es_soviet-estrings)/8    ;(ET_PARTNO9)   
0031B2 A625           00271     dw      (((es_tms2516-estrings)/8)<<8)+(es_ti-estrings)/8       ;(ET_PARTNO10)
                      00272 
0031B4 5283           00273     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00274                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00275 
0031B6 3000           00276     dw      0x3000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00277                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      00278 
0031B8 0194           00279     dw      0x0194              ;(ET_PGMVPP)active-high PGM on pin 18, Vpp on pin 21
                      00280                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00281 
0031BA 0146           00282     dw      (.01<<8)+0x46       ;(ET_VPPSETUP)Vpp = 25V, 5V during read, pulsed PGM
                      00283                                 ;(ET_PROGREPS) write once
                      00284 
0031BC 00B2           00285     dw      (0x00<<8)+.50+0x80  ;(ET_PROGPULSE) 50 mS programming pulse width
                      00286                                 ;(ET_PPDELAY) no delay between pulses
                      00287 
0031BE 0000           00288     dw      0x0000              ;(ET_SMART1) No smart programming
                      00289                                 ;(ET_SMART2)
                      00290 
0031C0 0000           00291     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00292                                 ;(ET_RESERVED)
                      00293 
                      00294 ;+----+
                      00295 ;+ 07 +
                      00296 ;+-------------------+
                      00297 ;+ 2716 with Vpp=21V +
                      00298 ;+-------------------+
0031C2                00299 ep_2716A:
0031C2 FF30           00300     dw      (0xFF<<8)+(es_2716a-estrings)/8         ;(ET_NAME)
                      00301 
0031C4 FFFF           00302     dw      0xFFFF                                  ;(ET_PARTNO1) null
0031C6 FFFF           00303     dw      0xFFFF                                  ;(ET_PARTNO2) null
0031C8 FFFF           00304     dw      0xFFFF                                  ;(ET_PARTNO3) null
0031CA FFFF           00305     dw      0xFFFF                                  ;(ET_PARTNO4) null
0031CC FFFF           00306     dw      0xFFFF                                  ;(ET_PARTNO5) null
0031CE FFFF           00307     dw      0xFFFF                                  ;(ET_PARTNO6) null
0031D0 FFFF           00308     dw      0xFFFF                                  ;(ET_PARTNO7) null
0031D2 FFFF           00309     dw      0xFFFF                                  ;(ET_PARTNO8) null
0031D4 FFFF           00310     dw      0xFFFF                                  ;(ET_PARTNO9) null
0031D6 FFFF           00311     dw      0xFFFF                                  ;(ET_PARTNO10) null
                      00312 
0031D8 5283           00313     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00314                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00315 
0031DA 3000           00316     dw      0x3000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00317                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      00318 
0031DC 0194           00319     dw      0x0194              ;(ET_PGMVPP)active-high PGM on pin 18, Vpp on pin 21
                      00320                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00321 
0031DE 0136           00322     dw      (.01<<8)+0x36       ;(ET_VPPSETUP)Vpp = 21V, 5V during read, pulsed PGM
                      00323                                 ;(ET_PROGREPS) write once
                      00324 
0031E0 00B2           00325     dw      (0x00<<8)+.50+0x80  ;(ET_PROGPULSE) 50 mS programming pulse width
                      00326                                 ;(ET_PPDELAY) no delay between pulses
                      00327 
0031E2 0000           00328     dw      0x0000              ;(ET_SMART1) No smart programming
                      00329                                 ;(ET_SMART2)
                      00330 
0031E4 0000           00331     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00332                                 ;(ET_RESERVED)
                      00333 
                      00334 ;+----+
                      00335 ;+ 08 +
                      00336 ;+-------------------------+
                      00337 ;+ 2716 with Vpp=21V, Fast +
                      00338 ;+-------------------------+
0031E6                00339 ep_2716Afast:
0031E6 FF31           00340     dw      (0xFF<<8)+(es_2716afast-estrings)/8         ;(ET_NAME)
                      00341 
0031E8 9F23           00342     dw      (((es_m2716af-estrings)/8)<<8)+(es_st-estrings)/8   ;(ET_PARTNO1)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 113
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0031EA FFFF           00343     dw      0xFFFF                                              ;(ET_PARTNO2) null
0031EC FFFF           00344     dw      0xFFFF                                              ;(ET_PARTNO3) null
0031EE FFFF           00345     dw      0xFFFF                                              ;(ET_PARTNO4) null
0031F0 FFFF           00346     dw      0xFFFF                                              ;(ET_PARTNO5) null
0031F2 FFFF           00347     dw      0xFFFF                                              ;(ET_PARTNO6) null
0031F4 FFFF           00348     dw      0xFFFF                                              ;(ET_PARTNO7) null
0031F6 FFFF           00349     dw      0xFFFF                                              ;(ET_PARTNO8) null
0031F8 FFFF           00350     dw      0xFFFF                                              ;(ET_PARTNO9) null
0031FA FFFF           00351     dw      0xFFFF                                              ;(ET_PARTN10) null
                      00352 
0031FC 5283           00353     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00354                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00355 
0031FE 3000           00356     dw      0x3000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00357                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      00358 
003200 0294           00359     dw      0x0294              ;(ET_PGMVPP)active-high PGM on pin 18, Vpp on pin 21
                      00360                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 6.0V
                      00361 
003202 1936           00362     dw      (.25<<8)+0x36       ;(ET_VPPSETUP)Vpp = 21V, 5V during read, pulsed PGM
                      00363                                 ;(ET_PROGREPS) max 25 tries
                      00364 
003204 0064           00365     dw      (0x00<<8)+.100      ;(ET_PROGPULSE) 1 mS programming pulse width
                      00366                                 ;(ET_PPDELAY) no delay between pulses
                      00367 
003206 0033           00368     dw      0x0033              ;(ET_SMART1) P+3P*ET_PROGPULSE smart programming
                      00369                                 ;(ET_SMART2) no second pass
                      00370 
003208 0000           00371     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00372                                 ;(ET_RESERVED)
                      00373 
                      00374 ;+----+
                      00375 ;+ 09 +
                      00376 ;+----------------------+
                      00377 ;+ 2716 with Vpp=12.75V +
                      00378 ;+----------------------+
00320A                00379 ep_2716B:
00320A FF33           00380     dw      (0xFF<<8)+(es_2716b-estrings)/8                     ;(ET_NAME)
                      00381 
00320C 5601           00382     dw      (((es_am2716b-estrings)/8)<<8)+(es_amd-estrings)/8  ;(ET_PARTNO1)
00320E FFFF           00383     dw      0xFFFF              ;(ET_PARTNO2) null
003210 FFFF           00384     dw      0xFFFF              ;(ET_PARTNO3) null
003212 FFFF           00385     dw      0xFFFF              ;(ET_PARTNO4) null
003214 FFFF           00386     dw      0xFFFF              ;(ET_PARTNO5) null
003216 FFFF           00387     dw      0xFFFF              ;(ET_PARTNO6) null
003218 FFFF           00388     dw      0xFFFF              ;(ET_PARTNO7) null
00321A FFFF           00389     dw      0xFFFF              ;(ET_PARTNO8) null
00321C FFFF           00390     dw      0xFFFF              ;(ET_PARTNO9) null
00321E FFFF           00391     dw      0xFFFF              ;(ET_PARTNO10) null
                      00392 
003220 5283           00393     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00394                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00395 
003222 3000           00396     dw      0x3000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00397                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      00398 
003224 0194           00399     dw      0x0194              ;(ET_PGMVPP)active-high PGM on pin 18, Vpp on pin 21
                      00400                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00401 
003226 0F16           00402     dw      (.15<<8)+0x16       ;(ET_VPPSETUP)Vpp = 12.75V, 5V during read, pulsed PGM
                      00403                                 ;(ET_PROGREPS) max 15 reps
                      00404 
003228 0064           00405     dw      (0x00<<8)+.100      ;(ET_PROGPULSE) 1 mS programming pulse width
                      00406                                 ;(ET_PPDELAY) no delay between pulses
                      00407 
00322A 0012           00408     dw      0x0012              ;(ET_SMART1) P+2*ET_PROGPULSE smart
                      00409                                 ;(ET_SMART2) No second pass
                      00410 
00322C 0000           00411     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00412                                 ;(ET_RESERVED)
                      00413 
                      00414 ;+----+
                      00415 ;+ 0A +
                      00416 ;+-------------------+
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 114
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00417 ;+ 2716H             +
                      00418 ;+-------------------+
00322E                00419 ep_27c16h:
00322E FF34           00420     dw      (0xFF<<8)+(es_27c16h-estrings)/8                            ;(ET_NAME)
                      00421 
003230 7008           00422     dw      (((es_nmc27c16h-estrings)/8)<<8)+(es_fairchild-estrings)/8  ;(ET_PARTNO1)
003232 7015           00423     dw      (((es_nmc27c16h-estrings)/8)<<8)+(es_national-estrings)/8   ;(ET_PARTNO2)
003234 FFFF           00424     dw      0xFFFF              ;(ET_PARTNO3) null
003236 FFFF           00425     dw      0xFFFF              ;(ET_PARTNO4) null
003238 FFFF           00426     dw      0xFFFF              ;(ET_PARTNO5) null
00323A FFFF           00427     dw      0xFFFF              ;(ET_PARTNO6) null
00323C FFFF           00428     dw      0xFFFF              ;(ET_PARTNO7) null
00323E FFFF           00429     dw      0xFFFF              ;(ET_PARTNO8) null
003240 FFFF           00430     dw      0xFFFF              ;(ET_PARTNO9) null
003242 FFFF           00431     dw      0xFFFF              ;(ET_PARTNO10) null
                      00432 
003244 5283           00433     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00434                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00435 
003246 3000           00436     dw      0x3000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00437                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      00438 
003248 0194           00439     dw      0x0194              ;(ET_PGMVPP)active-high PGM on pin 18, Vpp on pin 21
                      00440                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00441 
00324A 0146           00442     dw      (.01<<8)+0x46       ;(ET_VPPSETUP)Vpp = 25V, 5V during read, pulsed PGM
                      00443                                 ;(ET_PROGREPS) write once
                      00444 
00324C 008A           00445     dw      (0x00<<8)+.10+0x80  ;(ET_PROGPULSE) 10 mS programming pulse width
                      00446                                 ;(ET_PPDELAY) no delay between pulses
                      00447 
00324E 0000           00448     dw      0x0000              ;(ET_SMART1) No smart programming
                      00449                                 ;(ET_SMART2)
                      00450 
003250 0000           00451     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00452                                 ;(ET_RESERVED)
                      00453 
                      00454 ;+----+
                      00455 ;+ 0B +
                      00456 ;+-----------------------+
                      00457 ;+ 27C16 with Vpp=12.75V +
                      00458 ;+-----------------------+
003252                00459 ep_27C16B:
003252 FF35           00460     dw  (   0xFF<<8)+(es_27c16b-estrings)/8                             ;(ET_NAME)
                      00461 
003254 6F08           00462     dw      (((es_nmc27c16b-estrings)/8)<<8)+(es_fairchild-estrings)/8  ;(ET_PARTNO1)
003256 FFFF           00463     dw      0xFFFF              ;(ET_PARTNO2) null
003258 FFFF           00464     dw      0xFFFF              ;(ET_PARTNO3) null
00325A FFFF           00465     dw      0xFFFF              ;(ET_PARTNO4) null
00325C FFFF           00466     dw      0xFFFF              ;(ET_PARTNO5) null
00325E FFFF           00467     dw      0xFFFF              ;(ET_PARTNO6) null
003260 FFFF           00468     dw      0xFFFF              ;(ET_PARTNO7) null
003262 FFFF           00469     dw      0xFFFF              ;(ET_PARTNO8) null
003264 FFFF           00470     dw      0xFFFF              ;(ET_PARTNO9) null
003266 FFFF           00471     dw      0xFFFF              ;(ET_PARTNO10) null
                      00472 
003268 5283           00473     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00474                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00475 
00326A 3000           00476     dw      0x3000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00477                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      00478 
00326C 0294           00479     dw      0x0294              ;(ET_PGMVPP)active-high PGM on pin 18, Vpp on pin 21
                      00480                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 6.2V
                      00481 
00326E 1416           00482     dw      (.20<<8)+0x16       ;(ET_VPPSETUP)Vpp = 12.75V, 5V during read, pulsed PGM
                      00483                                 ;(ET_PROGREPS) max 20 reps
                      00484 
003270 000A           00485     dw      (0x00<<8)+.10       ;(ET_PROGPULSE) 100 uS programming pulse width
                      00486                                 ;(ET_PPDELAY) no delay between pulses
                      00487 
003272 0080           00488     dw      0x0080              ;(ET_SMART1) P, n=0 (msb set so it is a P algorithm)
                      00489                                 ;(ET_SMART2) No second pass
                      00490 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 115
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

003274 0000           00491     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00492                                 ;(ET_RESERVED)
                      00493 
                      00494 ;+----+
                      00495 ;+ 0C +
                      00496 ;+----------------------------------------+
                      00497 ;+ Texas Instruments 3-voltage 2Kx8 EPROM +
                      00498 ;+----------------------------------------+
003276                00499 ep_TMS2716:
003276 FF36           00500     dw      (0xFF<<8)+(es_tms2716-estrings)/8                   ;(ET_NAME)
                      00501 
003278 3614           00502     dw      (((es_tms2716-estrings)/8)<<8)+(es_motorola-estrings)/8 ;(ET_PARTNO1)
00327A 3625           00503     dw      (((es_tms2716-estrings)/8)<<8)+(es_ti-estrings)/8       ;(ET_PARTNO2)
00327C FFFF           00504     dw      0xFFFF              ;(ET_PARTNO3) null
00327E FFFF           00505     dw      0xFFFF              ;(ET_PARTNO4) null
003280 FFFF           00506     dw      0xFFFF              ;(ET_PARTNO5) null
003282 FFFF           00507     dw      0xFFFF              ;(ET_PARTNO6) null
003284 FFFF           00508     dw      0xFFFF              ;(ET_PARTNO7) null
003286 FFFF           00509     dw      0xFFFF              ;(ET_PARTNO8) null
003288 FFFF           00510     dw      0xFFFF              ;(ET_PARTNO9) null
00328A FFFF           00511     dw      0xFFFF              ;(ET_PARTNO10) null
                      00512 
00328C 5383           00513     dw      0x5383              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00514                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 20
                      00515 
00328E 0000           00516     dw      0x0000              ;(ET_A11A12)no A11 pin, no A12 pin
                      00517                                 ;(ET_OECS)no -OE pin, No CS pin
                      00518 
003290 3301           00519     dw      0x3301              ;(ET_PGMVPP)No PGM pin, Vpp on pin 18
                      00520                                 ;(ET_VBBVDD)Vbb = -5V & Vdd = 12V, Vcc = 12V
                      00521 
003292 7040           00522     dw      (.112<<8)+0x40      ;(ET_VPPSETUP)Vpp = 25V, 0V during read, pulsed Vpp, return to 0V
                      00523                                 ;(ET_PROGREPS) 112 repetitions
                      00524 
003294 005A           00525     dw      (0x00<<8)+.90       ;(ET_PROGPULSE) 90 uS programming pulse width
                      00526                                 ;(ET_PPDELAY) no delay between pulses
                      00527 
003296 0000           00528     dw      0x0000              ;(ET_SMART1) No smart programming
                      00529                                 ;(ET_SMART2)
                      00530 
003298 0000           00531     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00532                                 ;(ET_RESERVED)
                      00533 
                      00534 ;+----+
                      00535 ;+ 0D +
                      00536 ;+--------------------------------------------------+
                      00537 ;+ WSI 2Kx8 EPROM, with Vcc=5.5V during programming +
                      00538 ;+--------------------------------------------------+
00329A                00539 ep_57C191:
00329A FF37           00540     dw      (0xFF<<8)+(es_57c191-estrings)/8                        ;(ET_NAME)
                      00541 
00329C AC27           00542     dw      (((es_ws57c191-estrings)/8)<<8)+(es_wsi-estrings)/8     ;(ET_PARTNO1)
00329E AD27           00543     dw      (((es_ws57c191b-estrings)/8)<<8)+(es_wsi-estrings)/8    ;(ET_PARTNO2)
0032A0 B027           00544     dw      (((es_ws57c291-estrings)/8)<<8)+(es_wsi-estrings)/8     ;(ET_PARTNO3)
0032A2 B127           00545     dw      (((es_ws57c291b-estrings)/8)<<8)+(es_wsi-estrings)/8    ;(ET_PARTNO4)
0032A4 FFFF           00546     dw      0xFFFF              ;(ET_PARTNO5) null
0032A6 FFFF           00547     dw      0xFFFF              ;(ET_PARTNO6) null
0032A8 FFFF           00548     dw      0xFFFF              ;(ET_PARTNO7) null
0032AA FFFF           00549     dw      0xFFFF              ;(ET_PARTNO8) null
0032AC FFFF           00550     dw      0xFFFF              ;(ET_PARTNO9) null
                      00551 
0032AE FFBB           00552     dw      (0xFF<<8)+(es_55v-estrings)/8       ;(ET_VCCMSG)prog. Vcc needs adjustment
                      00553                                                 ;(ET_VPPMSG) null
                      00554 
0032B0 5483           00555     dw      0x5483              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00556                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      00557 
0032B2 3A90           00558     dw      0x3A90              ;(ET_A11A12)Force pin 18 high (CS3), no A12
                      00559                                 ;(ET_OECS)-OE on pin 20, active-high CS on pin 19 (CS2)
                      00560 
0032B4 0203           00561     dw      0x0203              ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      00562                                 ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      00563 
0032B6 0121           00564     dw      (.01<<8)+0x21       ;(ET_VPPSETUP)Vpp = 13.15V, 0V during read, pulsed Vpp, return to +5V
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 116
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00565                                 ;(ET_PROGREPS) write once
                      00566 
0032B8 008A           00567     dw      (0x00<<8)+.10+0x80  ;(ET_PROGPULSE) 10 mS programming pulse width
                      00568                                 ;(ET_PPDELAY) no delay between pulses
                      00569 
0032BA 0000           00570     dw      0x0000              ;(ET_SMART1) No smart programming
                      00571                                 ;(ET_SMART2)
                      00572 
0032BC 0001           00573     dw      0x0001              ;(ET_SPECIAL) Programming Vcc requires adjustment
                      00574                                 ;(ET_RESERVED)
                      00575 
                      00576 ;+----+
                      00577 ;+ 0E +
                      00578 ;+---------------------------------------------------+
                      00579 ;+ WSI 2Kx8 EPROM, with Vcc=6.2V during programming +
                      00580 ;+---------------------------------------------------+
0032BE                00581 ep_57C191C:
0032BE FF38           00582     dw      (0xFF<<8)+(es_57c191c-estrings)/8                       ;(ET_NAME)
                      00583 
0032C0 AF27           00584     dw      (((es_ws57c191c-estrings)/8)<<8)+(es_wsi-estrings)/8    ;(ET_PARTNO1)
0032C2 B327           00585     dw      (((es_ws57c291c-estrings)/8)<<8)+(es_wsi-estrings)/8    ;(ET_PARTNO2)
0032C4 FFFF           00586     dw      0xFFFF              ;(ET_PARTNO3) null
0032C6 FFFF           00587     dw      0xFFFF              ;(ET_PARTNO4) null
0032C8 FFFF           00588     dw      0xFFFF              ;(ET_PARTNO5) null
0032CA FFFF           00589     dw      0xFFFF              ;(ET_PARTNO6) null
0032CC FFFF           00590     dw      0xFFFF              ;(ET_PARTNO7) null
0032CE FFFF           00591     dw      0xFFFF              ;(ET_PARTNO8) null
0032D0 FFFF           00592     dw      0xFFFF              ;(ET_PARTNO9) null
0032D2 FFFF           00593     dw      0xFFFF              ;(ET_PARTN10) null
                      00594 
0032D4 5483           00595     dw      0x5483              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00596                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      00597 
0032D6 3A90           00598     dw      0x3A90              ;(ET_A11A12)Force pin 18 high (CS3), no A12
                      00599                                 ;(ET_OECS)-OE on pin 20, active-high CS on pin 19 (CS2)
                      00600 
0032D8 0203           00601     dw      0x0203              ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      00602                                 ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      00603 
0032DA 1911           00604     dw      (.25<<8)+0x11       ;(ET_VPPSETUP)Vpp = 12.75V, 0V during read, pulsed Vpp, return to +5V
                      00605                                 ;(ET_PROGREPS) max p = 25
                      00606 
0032DC 000F           00607     dw      (0x00<<8)+.15       ;(ET_PROGPULSE) 150 uS programming pulse width
                      00608                                 ;(ET_PPDELAY) no delay between pulses
                      00609 
0032DE 0001           00610     dw      0x0001              ;(ET_SMART1) P+1
                      00611                                 ;(ET_SMART2) No second pass
                      00612 
0032E0 0000           00613     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00614                                 ;(ET_RESERVED)
                      00615 
                      00616 ;+----+
                      00617 ;+ 0F +
                      00618 ;+-------------+
                      00619 ;+ 2Kx8 EEPROM +
                      00620 ;+-------------+
0032E2                00621 ep_2816a:
0032E2 FF39           00622     dw      (0xFF<<8)+(es_2816a-estrings)/8                         ;(ET_NAME)
                      00623 
0032E4 991C           00624     dw      (((es_km2816a-estrings)/8)<<8)+(es_samsung-estrings)/8  ;(ET_PARTNO1)
0032E6 391D           00625     dw      (((es_2816a-estrings)/8)<<8)+(es_seeq-estrings)/8       ;(ET_PARTNO2)
0032E8 9B1D           00626     dw      (((es_5516a-estrings)/8)<<8)+(es_seeq-estrings)/8       ;(ET_PARTNO3)
0032EA FFFF           00627     dw      0xFFFF              ;(ET_PARTNO4) null
0032EC FFFF           00628     dw      0xFFFF              ;(ET_PARTNO5) null
0032EE FFFF           00629     dw      0xFFFF              ;(ET_PARTNO6) null
0032F0 FFFF           00630     dw      0xFFFF              ;(ET_PARTNO7) null
0032F2 FFFF           00631     dw      0xFFFF              ;(ET_PARTNO8) null
0032F4 FFFF           00632     dw      0xFFFF              ;(ET_PARTNO9) null
0032F6 FFFF           00633     dw      0xFFFF              ;(ET_PARTNO10) null
                      00634 
0032F8 5283           00635     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00636                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00637 
0032FA 3100           00638     dw      0x3100              ;(ET_A11A12)no A11 pin, no A12 pin
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 117
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00639                                 ;(ET_OECS)-OE on pin 20, active-low CS on pin 18
                      00640 
0032FC 0140           00641     dw      0x0140              ;(ET_PGMVPP)active-low PGM on pin 21, no Vpp pin
                      00642                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00643 
0032FE 0106           00644     dw      (.01<<8)+0x06       ;(ET_VPPSETUP)Vpp switcher off, 5V during read, pulsed PGM
                      00645                                 ;(ET_PROGREPS) write once
                      00646 
003300 8C00           00647     dw      ((.12+80h)<<8)+0x00 ;(ET_PROGPULSE) 250 nS programming pulse width
                      00648                                 ;(ET_PPDELAY) 12 mS between writes
                      00649 
003302 0000           00650     dw      0x0000              ;(ET_SMART1) No smart programming
                      00651                                 ;(ET_SMART2)
                      00652 
003304 0008           00653     dw      0x0008              ;(ET_SPECIAL) no blank check
                      00654                                 ;(ET_RESERVED)
                      00655 
                      00656 ;+----+
                      00657 ;+ 10 +
                      00658 ;+-------------+
                      00659 ;+ 2Kx8 EEPROM +
                      00660 ;+-------------+
003306                00661 ep_28C16:
003306 FF3A           00662     dw      (0xFF<<8)+(es_28c16-estrings)/8                             ;(ET_NAME)
                      00663 
003308 5C02           00664     dw      (((es_at28c16-estrings)/8)<<8)+(es_atmel-estrings)/8        ;(ET_PARTNO1)
00330A 5E02           00665     dw      (((es_at28c16e-estrings)/8)<<8)+(es_atmel-estrings)/8       ;(ET_PARTNO2)
00330C 6503           00666     dw      (((es_cat28c16a-estrings)/8)<<8)+(es_catalyst-estrings)/8   ;(ET_PARTNO3)
00330E 6907           00667     dw      (((es_xl2816a-estrings)/8)<<8)+(es_exel-estrings)/8         ;(ET_PARTNO4)
003310 6A07           00668     dw      (((es_xl28c16a-estrings)/8)<<8)+(es_exel-estrings)/8        ;(ET_PARTNO5)
003312 8110           00669     dw      (((es_28c16a-estrings)/8)<<8)+(es_microchip-estrings)/8     ;(ET_PARTNO6)
003314 6519           00670     dw      (((es_cat28c16a-estrings)/8)<<8)+(es_onsemi-estrings)/8     ;(ET_PARTNO7)
003316 BA28           00671     dw      (((es_x2816b-estrings)/8)<<8)+(es_xicor-estrings)/8     ;(ET_PARTNO8)
003318 FFFF           00672     dw      0xFFFF              ;(ET_PARTNO9) null
00331A FFFF           00673     dw      0xFFFF              ;(ET_PARTNO10) null
                      00674 
00331C 5283           00675     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00676                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00677 
00331E 3100           00678     dw      0x3100              ;(ET_A11A12)no A11 pin, no A12 pin
                      00679                                 ;(ET_OECS)-OE on pin 20, active-low CS on pin 18
                      00680 
003320 0140           00681     dw      0x0140              ;(ET_PGMVPP)active-low PGM on pin 21, no Vpp pin
                      00682                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00683 
003322 0106           00684     dw      (.01<<8)+0x06       ;(ET_VPPSETUP)Vpp switcher off, 5V during read, pulsed PGM
                      00685                                 ;(ET_PROGREPS) write once
                      00686 
003324 0100           00687     dw      0x0100              ;(ET_PROGPULSE) 250 nS programming pulse width
                      00688                                 ;(ET_PPDELAY) poll for completion between pulses
                      00689 
003326 0000           00690     dw      0x0000              ;(ET_SMART1) No smart programming
                      00691                                 ;(ET_SMART2)
                      00692 
003328 0008           00693     dw      0x0008              ;(ET_SPECIAL) no blank check
                      00694                                 ;(ET_RESERVED)
                      00695 
                      00696 ;+----+
                      00697 ;+ 11 +
                      00698 ;+-----------------------------------+
                      00699 ;+ 2Kx8 EEPROM                       +
                      00700 ;+ Not self-timed, 12 mS write pulse +
                      00701 ;+-----------------------------------+
00332A                00702 ep_2816ai:
00332A FF3B           00703     dw      (0xFF<<8)+(es_2816ai-estrings)/8                    ;(ET_NAME)
                      00704 
00332C 390E           00705     dw      (((es_2816a-estrings)/8)<<8)+(es_intel-estrings)/8  ;(ET_PARTNO1)
00332E 9A1D           00706     dw      (((es_52b13-estrings)/8)<<8)+(es_seeq-estrings)/8   ;(ET_PARTNO2)
003330 FFFF           00707     dw      0xFFFF              ;(ET_PARTNO3) null
003332 FFFF           00708     dw      0xFFFF              ;(ET_PARTNO4) null
003334 FFFF           00709     dw      0xFFFF              ;(ET_PARTNO5) null
003336 FFFF           00710     dw      0xFFFF              ;(ET_PARTNO6) null
003338 FFFF           00711     dw      0xFFFF              ;(ET_PARTNO7) null
00333A FFFF           00712     dw      0xFFFF              ;(ET_PARTNO8) null
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 118
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00333C FFFF           00713     dw      0xFFFF              ;(ET_PARTNO9) null
00333E FFFF           00714     dw      0xFFFF              ;(ET_PARTNO10) null
                      00715 
003340 5283           00716     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      00717                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00718 
003342 3100           00719     dw      0x3100              ;(ET_A11A12)no A11 pin, no A12 pin
                      00720                                 ;(ET_OECS)-OE on pin 20, active-low CS on pin 18
                      00721 
003344 0140           00722     dw      0x0140              ;(ET_PGMVPP)active-low PGM on pin 21, no Vpp pin
                      00723                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00724 
003346 0106           00725     dw      (.01<<8)+0x06       ;(ET_VPPSETUP)Vpp switcher off, 5V during read, pulsed PGM
                      00726                                 ;(ET_PROGREPS) write once
                      00727 
003348 008C           00728     dw      (0x00<<8)+.12+80h   ;(ET_PROGPULSE) 12 mS programming pulse width
                      00729                                 ;(ET_PPDELAY) no delay between pulses
                      00730 
00334A 4149           00731     dw      0x4149              ;(ET_SMART1) pass 1 erases the EEPROM
                      00732                                 ;(ET_SMART2) pass 2 writes it
                      00733 
00334C 0008           00734     dw      0x0008              ;(ET_SPECIAL) no blank check
                      00735                                 ;(ET_RESERVED)
                      00736 
                      00737 ;+----+
                      00738 ;+ 12 +
                      00739 ;+------------------------+
                      00740 ;+ Generic 2732 (Vpp=25V) +
                      00741 ;+------------------------+
                      00742 
00334E                00743 ep_2732:
00334E FF3C           00744     dw      (0xFF<<8)+(es_2732-estrings)/8                              ;(ET_NAME)
                      00745 
                      00746 ;   dw      (((es_et2732q-estrings)/8)<<8)+(es_eurotech-estrings)/8     ;(also)
                      00747 
003350 5801           00748     dw      (((es_am2732-estrings)/8)<<8)+(es_amd-estrings)/8           ;(ET_PARTNO1)
003352 7208           00749     dw      (((es_f2732-estrings)/8)<<8)+(es_fairchild-estrings)/8      ;(ET_PARTNO2)
003354 7709           00750     dw      (((es_mbm2732-estrings)/8)<<8)+(es_fujitsu-estrings)/8      ;(ET_PARTNO3)
003356 7D0D           00751     dw      (((es_hn462732g-estrings)/8)<<8)+(es_hitachi-estrings)/8    ;(ET_PARTNO4)
003358 3C0E           00752     dw      (((es_2732-estrings)/8)<<8)+(es_intel-estrings)/8           ;(ET_PARTNO5)
00335A 8212           00753     dw      (((es_m5l2732k-estrings)/8)<<8)+(es_mitsubishi-estrings)/8  ;(ET_PARTNO6)
00335C 8413           00754     dw      (((es_u2732-estrings)/8)<<8)+(es_mme-estrings)/8            ;(ET_PARTNO7)
00335E 8714           00755     dw      (((es_mcm2732-estrings)/8)<<8)+(es_motorola-estrings)/8     ;(ET_PARTNO8)
003360 8F17           00756     dw      (((es_upd2732-estrings)/8)<<8)+(es_nec-estrings)/8          ;(ET_PARTNO8)
003362 AB26           00757     dw      (((es_tmm2732d-estrings)/8)<<8)+(es_toshiba-estrings)/8     ;(ET_PARTNO10)
                      00758 
003364 5284           00759     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      00760                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00761 
003366 1340           00762     dw      0x1340              ;(ET_A11A12)A11 on pin 21, no A12 pin
                      00763                                 ;(ET_OECS)-OE on pin 18, active-low -CS on pin 20
                      00764 
003368 0113           00765     dw      0x0113              ;(ET_PGMVPP)acive low PGM on pin 18, Vpp on pin 20
                      00766                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00767 
00336A 0142           00768     dw      (.01<<8)+0x42       ;(ET_VPPSETUP)Vpp = 25V, 0V during read, Pulsed -PGM
                      00769                                 ;(ET_PROGREPS) write once
                      00770 
00336C 00B2           00771     dw      (0x00<<8)+.50+0x80  ;(ET_PROGPULSE) 50 mS programming pulse width
                      00772                                 ;(ET_PPDELAY) no delay between pulses
                      00773 
00336E 0000           00774     dw      0x0000              ;(ET_SMART1) No smart programming
                      00775                                 ;(ET_SMART2)
                      00776 
003370 0000           00777     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00778                                 ;(ET_RESERVED)
                      00779 
                      00780 ;+----+
                      00781 ;+ 13 +
                      00782 ;+-------------------+
                      00783 ;+ 2732 with Vpp=21V +
                      00784 ;+-------------------+
003372                00785 ep_2732A:
003372 FF3D           00786     dw      (0xFF<<8)+(es_2732a-estrings)/8                             ;(ET_NAME)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 119
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00787 
003374 5901           00788     dw      (((es_am2732a-estrings)/8)<<8)+(es_amd-estrings)/8          ;(ET_PARTNO1)
003376 7809           00789     dw      (((es_mbm2732a-estrings)/8)<<8)+(es_fujitsu-estrings)/8     ;(ET_PARTNO2)
003378 7F0D           00790     dw      (((es_hn482732ag-estrings)/8)<<8)+(es_hitachi-estrings)/8   ;(ET_PARTNO3)
00337A 3D0E           00791     dw      (((es_2732a-estrings)/8)<<8)+(es_intel-estrings)/8          ;(ET_PARTNO4)
00337C 9017           00792     dw      (((es_upd2732a-estrings)/8)<<8)+(es_nec-estrings)/8         ;(ET_PARTNO5)
00337E 981B           00793     dw      (((es_r87C32-estrings)/8)<<8)+(es_rockwell-estrings)/8      ;(ET_PARTNO6)
003380 A123           00794     dw      (((es_m2732a-estrings)/8)<<8)+(es_st-estrings)/8            ;(ET_PARTNO7)
003382 4525           00795     dw      (((es_tms2732a-estrings)/8)<<8)+(es_ti-estrings)/8          ;(ET_PARTNO8)
003384 FFFF           00796     dw      0xFFFF              ;(ET_PARTNO9) null
003386 FFFF           00797     dw      0xFFFF              ;(ET_PARTNO10) null
                      00798 
003388 5284           00799     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      00800                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00801 
00338A 1340           00802     dw      0x1340              ;(ET_A11A12)A11 on pin 21, no A12 pin
                      00803                                 ;(ET_OECS)-OE on pin 18, active-low -CS on pin 20
                      00804 
00338C 0113           00805     dw      0x0113              ;(ET_PGMVPP)acive low PGM on pin 18, Vpp on pin 20
                      00806                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00807 
00338E 0132           00808     dw      (.01<<8)+0x32       ;(ET_VPPSETUP)Vpp = 21V, 0V during read, Pulsed -PGM
                      00809                                 ;(ET_PROGREPS) write once
                      00810 
003390 00B2           00811     dw      (0x00<<8)+.50+0x80  ;(ET_PROGPULSE) 50 mS programming pulse width
                      00812                                 ;(ET_PPDELAY) no delay between pulses
                      00813 
003392 0000           00814     dw      0x0000              ;(ET_SMART1) No smart programming
                      00815                                 ;(ET_SMART2)
                      00816 
003394 0000           00817     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00818                                 ;(ET_RESERVED)
                      00819 
                      00820 ;+----+
                      00821 ;+ 14 +
                      00822 ;+-------------------------+
                      00823 ;+ 2732 with Vpp=21V, FAST +
                      00824 ;+-------------------------+
003396                00825 ep_2732af:
003396 FF3E           00826     dw      (0xFF<<8)+(es_2732afast-estrings)/8                 ;(ET_NAME)
                      00827 
003398 A223           00828     dw      (((es_m2732af-estrings)/8)<<8)+(es_st-estrings)/8   ;(ET_PARTNO1)
00339A FFFF           00829     dw      0xFFFF                                              ;(ET_PARTNO2) null
00339C FFFF           00830     dw      0xFFFF                                              ;(ET_PARTNO3) null
00339E FFFF           00831     dw      0xFFFF                                              ;(ET_PARTNO4) null
0033A0 FFFF           00832     dw      0xFFFF                                              ;(ET_PARTNO5) null
0033A2 FFFF           00833     dw      0xFFFF                                              ;(ET_PARTNO6) null
0033A4 FFFF           00834     dw      0xFFFF                                              ;(ET_PARTNO7) null
0033A6 FFFF           00835     dw      0xFFFF                                              ;(ET_PARTNO8) null
0033A8 FFFF           00836     dw      0xFFFF                                              ;(ET_PARTNO9) null
0033AA FFFF           00837     dw      0xFFFF                                              ;(ET_PARTN10) null
                      00838 
0033AC 5284           00839     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      00840                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00841 
0033AE 1340           00842     dw      0x1340              ;(ET_A11A12)A11 on pin 21, no A12 pin
                      00843                                 ;(ET_OECS)-OE on pin 18, active-low -CS on pin 20
                      00844 
0033B0 0213           00845     dw      0x0213              ;(ET_PGMVPP)acive low PGM on pin 18, Vpp on pin 20
                      00846                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 6V
                      00847 
0033B2 1932           00848     dw      (.25<<8)+0x32       ;(ET_VPPSETUP)Vpp = 21V, 0V during read, Pulsed -PGM
                      00849                                 ;(ET_PROGREPS) max P=25
                      00850 
0033B4 0064           00851     dw      (0x00<<8)+.100      ;(ET_PROGPULSE) 1000 uS programming pulse width
                      00852                                 ;(ET_PPDELAY) no delay between pulses
                      00853 
0033B6 0033           00854     dw      0x0033              ;(ET_SMART1) P+3P*ET_PROGPULSE smart programming
                      00855                                 ;(ET_SMART2) no second pass
                      00856 
0033B8 0000           00857     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00858 
                      00859 ;+----+
                      00860 ;+ 15 +
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 120
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00861 ;+----------------------+
                      00862 ;+ 2732 with Vpp=12.75V +
                      00863 ;+----------------------+
0033BA                00864 ep_2732B:
0033BA FF40           00865     dw      (0xFF<<8)+(es_2732b-estrings)/8                     ;(ET_NAME)
                      00866 
0033BC 5A01           00867     dw      (((es_am2732b-estrings)/8)<<8)+(es_amd-estrings)/8  ;(ET_PARTNO1)
0033BE FFFF           00868     dw      0xFFFF                                              ;(ET_PARTNO2) null
0033C0 FFFF           00869     dw      0xFFFF                                              ;(ET_PARTNO3) null
0033C2 FFFF           00870     dw      0xFFFF                                              ;(ET_PARTNO4) null
0033C4 FFFF           00871     dw      0xFFFF                                              ;(ET_PARTNO5) null
0033C6 FFFF           00872     dw      0xFFFF                                              ;(ET_PARTNO6) null
0033C8 FFFF           00873     dw      0xFFFF                                              ;(ET_PARTNO7) null
0033CA FFFF           00874     dw      0xFFFF                                              ;(ET_PARTNO8) null
0033CC FFFF           00875     dw      0xFFFF                                              ;(ET_PARTNO9) null
0033CE FFFF           00876     dw      0xFFFF                                              ;(ET_PARTNO10) null
                      00877 
0033D0 5284           00878     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      00879                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00880 
0033D2 1340           00881     dw      0x1340              ;(ET_A11A12)A11 on pin 21, no A12 pin
                      00882                                 ;(ET_OECS)-OE on pin 18, active-low -CS on pin 20
                      00883 
0033D4 0113           00884     dw      0x0113              ;(ET_PGMVPP)acive low PGM on pin 18, Vpp on pin 20
                      00885                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00886 
0033D6 0F12           00887     dw      (.15<<8)+0x12       ;(ET_VPPSETUP)Vpp = 12.75V, 0V during read, Pulsed -PGM
                      00888                                 ;(ET_PROGREPS) max 15 tries
                      00889 
0033D8 0064           00890     dw      (0x00<<8)+.100      ;(ET_PROGPULSE) 1000 uS programming pulse width
                      00891                                 ;(ET_PPDELAY) no delay between pulses
                      00892 
0033DA 0012           00893     dw      0x0012              ;(ET_SMART1) P+2*ET_PROGPULSE smart
                      00894                                 ;(ET_SMART2) No second pass
                      00895 
0033DC 0000           00896     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00897                                 ;(ET_RESERVED)
                      00898 
                      00899 ;+----+
                      00900 ;+ 16 +
                      00901 ;+----------------------+
                      00902 ;+ 2732H                +
                      00903 ;+----------------------+
0033DE                00904 ep_2732H:
0033DE FF41           00905     dw      (0xFF<<8)+(es_27c32h-estrings)/8                            ;(ET_NAME)
                      00906 
0033E0 7408           00907     dw      (((es_nmc27c32h-estrings)/8)<<8)+(es_fairchild-estrings)/8  ;(ET_PARTNO1)
0033E2 7415           00908     dw      (((es_nmc27c32h-estrings)/8)<<8)+(es_national-estrings)/8   ;(ET_PARTNO2)
0033E4 FFFF           00909     dw      0xFFFF                                                      ;(ET_PARTNO3) null
0033E6 FFFF           00910     dw      0xFFFF                                                      ;(ET_PARTNO4) null
0033E8 FFFF           00911     dw      0xFFFF                                                      ;(ET_PARTNO5) null
0033EA FFFF           00912     dw      0xFFFF                                                      ;(ET_PARTNO6) null
0033EC FFFF           00913     dw      0xFFFF                                                      ;(ET_PARTNO7) null
0033EE FFFF           00914     dw      0xFFFF                                                      ;(ET_PARTNO8) null
0033F0 FFFF           00915     dw      0xFFFF                                                      ;(ET_PARTNO9) null
0033F2 FFFF           00916     dw      0xFFFF                                                      ;(ET_PARTNO10) null
                      00917 
0033F4 5284           00918     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      00919                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00920 
0033F6 1340           00921     dw      0x1340              ;(ET_A11A12)A11 on pin 21, no A12 pin
                      00922                                 ;(ET_OECS)-OE on pin 18, active-low -CS on pin 20
                      00923 
0033F8 0113           00924     dw      0x0113              ;(ET_PGMVPP)acive low PGM on pin 18, Vpp on pin 20
                      00925                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      00926 
0033FA 0112           00927     dw      (.01<<8)+0x12       ;(ET_VPPSETUP)Vpp = 12.75V, 0V during read, Pulsed -PGM
                      00928                                 ;(ET_PROGREPS) write once
                      00929 
0033FC 008A           00930     dw      (0x00<<8)+.10+0x80  ;(ET_PROGPULSE) 10 mS programming pulse width
                      00931                                 ;(ET_PPDELAY) no delay between pulses
                      00932 
0033FE 0000           00933     dw      0x0000              ;(ET_SMART1) No smart programming
                      00934                                 ;(ET_SMART2)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 121
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00935 
003400 0000           00936     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00937                                 ;(ET_RESERVED)
                      00938 
                      00939 ;+----+
                      00940 ;+ 17 +
                      00941 ;+-----------------------+
                      00942 ;+ 27C32 with Vpp=12.75V +
                      00943 ;+-----------------------+
003402                00944 ep_27C32B:
003402 FF42           00945     dw      (0xFF<<8)+(es_27c32b-estrings)/8                            ;(ET_NAME)
                      00946 
003404 7308           00947     dw      (((es_nmc27c32b-estrings)/8)<<8)+(es_fairchild-estrings)/8  ;(ET_PARTNO1)
003406 7315           00948     dw      (((es_nmc27c32b-estrings)/8)<<8)+(es_national-estrings)/8   ;(ET_PARTNO2)
003408 FFFF           00949     dw      0xFFFF                                                      ;(ET_PARTNO3) null
00340A FFFF           00950     dw      0xFFFF                                                      ;(ET_PARTNO4) null
00340C FFFF           00951     dw      0xFFFF                                                      ;(ET_PARTNO5) null
00340E FFFF           00952     dw      0xFFFF                                                      ;(ET_PARTNO6) null
003410 FFFF           00953     dw      0xFFFF                                                      ;(ET_PARTNO7) null
003412 FFFF           00954     dw      0xFFFF                                                      ;(ET_PARTNO8) null
003414 FFFF           00955     dw      0xFFFF                                                      ;(ET_PARTNO9) null
003416 FFFF           00956     dw      0xFFFF                                                      ;(ET_PARTNO10) null
                      00957 
003418 5284           00958     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      00959                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      00960 
00341A 1340           00961     dw      0x1340              ;(ET_A11A12)A11 on pin 21, no A12 pin
                      00962                                 ;(ET_OECS)-OE on pin 18, active-low -CS on pin 20
                      00963 
00341C 0213           00964     dw      0x0213              ;(ET_PGMVPP)acive low PGM on pin 18, Vpp on pin 20
                      00965                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 6.2V
                      00966 
00341E 1412           00967     dw      (.20<<8)+0x12       ;(ET_VPPSETUP)Vpp = 12.75V, 0V during read, Pulsed -PGM
                      00968                                 ;(ET_PROGREPS) max 20 tries
                      00969 
003420 000A           00970     dw      (0x00<<8)+.10       ;(ET_PROGPULSE) 100 uS programming pulse width
                      00971                                 ;(ET_PPDELAY) no delay between pulses
                      00972 
003422 0080           00973     dw      0x0080              ;(ET_SMART1) P, n=0 (msb set so it is a P algorithm)
                      00974                                 ;(ET_SMART2) No second pass
                      00975 
003424 0000           00976     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      00977                                 ;(ET_RESERVED)
                      00978 
                      00979 ;+----+
                      00980 ;+ 18 +
                      00981 ;+-----------------------------------------------------+
                      00982 ;+ Texas Instruments 4Kx8 EPROM, active-low PGM signal +
                      00983 ;+ Vpp = 25V                                           +
                      00984 ;+-----------------------------------------------------+
003426                00985 ep_TMS2532:
003426 FF43           00986     dw      (0xFF<<8)+(es_tms2532-estrings)/8                       ;(ET_NAME)
                      00987 
003428 7B0D           00988     dw      (((es_hn462532-estrings)/8)<<8)+(es_hitachi-estrings)/8 ;(ET_PARTNO1)
00342A 8514           00989     dw      (((es_mcm2532-estrings)/8)<<8)+(es_motorola-estrings)/8 ;(ET_PARTNO2)
00342C 9D1E           00990     dw      (((es_m2532-estrings)/8)<<8)+(es_sgs-estrings)/8        ;(ET_PARTNO3)
00342E 4325           00991     dw      (((es_tms2532-estrings)/8)<<8)+(es_ti-estrings)/8       ;(ET_PARTNO4)
003430 FFFF           00992     dw      0xFFFF                                                  ;(ET_PARTNO5) null
003432 FFFF           00993     dw      0xFFFF                                                  ;(ET_PARTNO6) null
003434 FFFF           00994     dw      0xFFFF                                                  ;(ET_PARTNO7) null
003436 FFFF           00995     dw      0xFFFF                                                  ;(ET_PARTNO8) null
003438 FFFF           00996     dw      0xFFFF                                                  ;(ET_PARTNO9) null
00343A FFFF           00997     dw      0xFFFF                                                  ;(ET_PARTNO10) null
                      00998 
00343C 5284           00999     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      01000                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      01001 
00343E 0310           01002     dw      0x0310              ;(ET_A11A12)A11 on pin 18, no A12 pin
                      01003                                 ;(ET_OECS)no -OE pin, active-low -CS on pin 20
                      01004 
003440 0134           01005     dw      0x0134              ;(ET_PGMVPP)Active low PGM on pin 20, Vpp on pin 21
                      01006                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      01007 
003442 0146           01008     dw      (.01<<8)+0x46       ;(ET_VPPSETUP)Vpp = 25V, high during read, pulsed -PGM
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 122
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01009                                 ;(ET_PROGREPS) write once
                      01010 
003444 00B2           01011     dw      (0x00<<8)+.50+0x80  ;(ET_PROGPULSE) 50 mS programming pulse width
                      01012                                 ;(ET_PPDELAY) no delay between pulses
                      01013 
003446 0000           01014     dw      0x0000              ;(ET_SMART1) No smart programming
                      01015                                 ;(ET_SMART2)
                      01016 
003448 0000           01017     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      01018                                 ;(ET_RESERVED)
                      01019 
                      01020 ;+----+
                      01021 ;+ 19 +
                      01022 ;+-----------------------------------------------------+
                      01023 ;+ Texas Instruments 4Kx8 EPROM, active-low PGM signal +
                      01024 ;+ Vpp = 21V                                           +
                      01025 ;+-----------------------------------------------------+
00344A                01026 ep_TMS2532A:
00344A FF44           01027     dw      (0xFF<<8)+(es_tms2532a-estrings)/8                  ;(ET_NAME)
                      01028 
00344C 4425           01029     dw      (((es_tms2532a-estrings)/8)<<8)+(es_ti-estrings)/8  ;(ET_PARTNO1)
00344E FFFF           01030     dw      0xFFFF                                              ;(ET_PARTNO2) null
003450 FFFF           01031     dw      0xFFFF                                              ;(ET_PARTNO3) null
003452 FFFF           01032     dw      0xFFFF                                              ;(ET_PARTNO4) null
003454 FFFF           01033     dw      0xFFFF                                              ;(ET_PARTNO5) null
003456 FFFF           01034     dw      0xFFFF                                              ;(ET_PARTNO6) null
003458 FFFF           01035     dw      0xFFFF                                              ;(ET_PARTNO7) null
00345A FFFF           01036     dw      0xFFFF                                              ;(ET_PARTNO8) null
00345C FFFF           01037     dw      0xFFFF                                              ;(ET_PARTNO9) null
00345E FFFF           01038     dw      0xFFFF                                              ;(ET_PARTNO10) null
                      01039 
003460 5284           01040     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      01041                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      01042 
003462 0310           01043     dw      0x0310              ;(ET_A11A12)A11 on pin 18, no A12 pin
                      01044                                 ;(ET_OECS)no -OE pin, active-low -CS on pin 20
                      01045 
003464 0134           01046     dw      0x0134              ;(ET_PGMVPP)Active low PGM on pin 20, Vpp on pin 21
                      01047                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      01048 
003466 0136           01049     dw      (.01<<8)+0x36       ;(ET_VPPSETUP)Vpp = 21V, high during read, pulsed -PGM
                      01050                                 ;(ET_PROGREPS) write once
                      01051 
003468 00B2           01052     dw      (0x00<<8)+.50+0x80  ;(ET_PROGPULSE) 50 mS programming pulse width
                      01053                                 ;(ET_PPDELAY) no delay between pulses
                      01054 
00346A 0000           01055     dw      0x0000              ;(ET_SMART1) No smart programming
                      01056                                 ;(ET_SMART2)
                      01057 
00346C 0000           01058     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      01059                                 ;(ET_RESERVED)
                      01060 
                      01061 ;+----+
                      01062 ;+ 1A +
                      01063 ;+----------------------+
                      01064 ;+ TI 2732 with Vpp=21V +
                      01065 ;+----------------------+
00346E                01066 ep_TMS2732A:
00346E FF45           01067     dw      (0xFF<<8)+(es_tms2732a-estrings)/8                  ;(ET_NAME)
                      01068 
003470 4525           01069     dw      (((es_tms2732a-estrings)/8)<<8)+(es_ti-estrings)/8  ;(ET_PARTNO1)
003472 FFFF           01070     dw      0xFFFF                                              ;(ET_PARTNO2) null
003474 FFFF           01071     dw      0xFFFF                                              ;(ET_PARTNO3) null
003476 FFFF           01072     dw      0xFFFF                                              ;(ET_PARTNO4) null
003478 FFFF           01073     dw      0xFFFF                                              ;(ET_PARTNO5) null
00347A FFFF           01074     dw      0xFFFF                                              ;(ET_PARTNO6) null
00347C FFFF           01075     dw      0xFFFF                                              ;(ET_PARTNO7) null
00347E FFFF           01076     dw      0xFFFF                                              ;(ET_PARTNO8) null
003480 FFFF           01077     dw      0xFFFF                                              ;(ET_PARTNO9) null
003482 FFFF           01078     dw      0xFFFF                                              ;(ET_PARTNO10) null
003484 5284           01079     dw      0x5284              ;(ET_BYTES)4096 bytes, 8 bits/byte
                      01080                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      01081 
003486 1340           01082     dw      0x1340              ;(ET_A11A12)A11 on pin 21, no A12 pin
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 123
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01083                                 ;(ET_OECS)-OE on pin 18, active-low -CS on pin 20
                      01084 
003488 0113           01085     dw      0x0113              ;(ET_PGMVPP)acive low PGM on pin 18, Vpp on pin 20
                      01086                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      01087 
00348A 0132           01088     dw      (.01<<8)+0x32       ;(ET_VPPSETUP)Vpp = 21V, 0V during read, Pulsed -PGM
                      01089                                 ;(ET_PROGREPS) write once
                      01090 
00348C 008A           01091     dw      (0x00<<8)+.10+0x80  ;(ET_PROGPULSE) 10 mS programming pulse width
                      01092                                 ;(ET_PPDELAY) no delay between pulses
                      01093 
00348E 0000           01094     dw      0x0000              ;(ET_SMART1) No smart programming
                      01095                                 ;(ET_SMART2)
                      01096 
003490 0000           01097     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      01098                                 ;(ET_RESERVED)
                      01099 
                      01100 ;+----+
                      01101 ;+ 1B +
                      01102 ;+----------------+
                      01103 ;+ WSI 4Kx8 EPROM +
                      01104 ;+----------------+
003492                01105 ep_57C43:
003492 FF46           01106     dw      (0xFF<<8)+(es_57c43-estrings)/8                     ;(ET_NAME)
                      01107 
003494 4627           01108     dw      (((es_57c43-estrings)/8)<<8)+(es_wsi-estrings)/8    ;(ET_PARTNO1)
003496 B427           01109     dw      (((es_ws57c43b-estrings)/8)<<8)+(es_wsi-estrings)/8 ;(ET_PARTNO2)
003498 FFFF           01110     dw      0xFFFF                                              ;(ET_PARTNO3) null
00349A FFFF           01111     dw      0xFFFF                                              ;(ET_PARTNO4) null
00349C FFFF           01112     dw      0xFFFF                                              ;(ET_PARTNO5) null
00349E FFFF           01113     dw      0xFFFF                                              ;(ET_PARTNO6) null
0034A0 FFFF           01114     dw      0xFFFF                                              ;(ET_PARTNO7) null
0034A2 FFFF           01115     dw      0xFFFF                                              ;(ET_PARTNO8) null
0034A4 FFFF           01116     dw      0xFFFF                                              ;(ET_PARTNO9) null
                      01117 
0034A6 FFBB           01118     dw      (0xFF<<8)+(es_55v-estrings)/8           ;(ET_VCCMSG)prog. Vcc requires adjustment
                      01119                                                     ;(ET_VPPMSG) null
                      01120 
0034A8 5484           01121     dw      0x5484              ;(ET_BYTES)4K bytes, 8 bits/byte
                      01122                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01123 
0034AA 3920           01124     dw      0x3920              ;(ET_A11A12)A11 on pin 19, no A12
                      01125                                 ;(ET_OECS) -OE on pin 20, active-high CS on pin 18 (CS2)
                      01126 
0034AC 0203           01127     dw      0x0203              ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01128                                 ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01129 
0034AE 0121           01130     dw      (.01<<8)+0x21       ;(ET_VPPSETUP)Vpp = 13.15V, 0V during read, pulsed Vpp, return to +5V
                      01131                                 ;(ET_PROGREPS) write once
                      01132 
0034B0 008A           01133     dw      (0x00<<8)+.10+0x80  ;(ET_PROGPULSE) 10 mS programming pulse width
                      01134                                 ;(ET_PPDELAY) no delay between pulses
                      01135 
0034B2 0000           01136     dw      0x0000              ;(ET_SMART1) No smart programming
                      01137                                 ;(ET_SMART2)
                      01138 
0034B4 0001           01139     dw      0x0001              ;(ET_SPECIAL) Programming Vcc requires adjustment
                      01140                                 ;(ET_RESERVED)
                      01141 
                      01142 ;+----+
                      01143 ;+ 1C +
                      01144 ;+------------------------------------------+
                      01145 ;+ WSI 4Kx8 EPROM                           +
                      01146 ;+ Note: The Smart algorith mere is a guess +
                      01147 ;+------------------------------------------+
0034B6                01148 ep_57C43C:
0034B6 FF47           01149     dw      (0xFF<<8)+(es_57c43c-estrings)/8                    ;(ET_NAME)
                      01150 
0034B8 B627           01151     dw      (((es_ws57c43c-estrings)/8)<<8)+(es_wsi-estrings)/8 ;(ET_PARTNO1)
0034BA FFFF           01152     dw      0xFFFF                                              ;(ET_PARTNO2) null
0034BC FFFF           01153     dw      0xFFFF                                              ;(ET_PARTNO3) null
0034BE FFFF           01154     dw      0xFFFF                                              ;(ET_PARTNO4) null
0034C0 FFFF           01155     dw      0xFFFF                                              ;(ET_PARTNO5) null
0034C2 FFFF           01156     dw      0xFFFF                                              ;(ET_PARTNO6) null
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 124
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0034C4 FFFF           01157     dw      0xFFFF                                              ;(ET_PARTNO7) null
0034C6 FFFF           01158     dw      0xFFFF                                              ;(ET_PARTNO8) null
0034C8 FFFF           01159     dw      0xFFFF                                              ;(ET_PARTNO9) null
0034CA FFFF           01160     dw      0xFFFF                                              ;(ET_PARTNO10) null
                      01161 
0034CC 5484           01162     dw      0x5484              ;(ET_BYTES)4K bytes, 8 bits/byte
                      01163                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01164 
0034CE 3920           01165     dw      0x3920              ;(ET_A11A12)A11 on pin 19, no A12
                      01166                                 ;(ET_OECS) -OE on pin 20, active-high CS on pin 18 (CS2)
                      01167 
0034D0 0203           01168     dw      0x0203              ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01169                                 ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01170 
0034D2 1911           01171     dw      (.25<<8)+0x11       ;(ET_VPPSETUP)Vpp = 12.75V, 0V during read, pulsed Vpp, return to +5V
                      01172                                 ;(ET_PROGREPS) Max p = 25
                      01173 
0034D4 000F           01174     dw      (0x00<<8)+.15       ;(ET_PROGPULSE) 150 uS programming pulse width
                      01175                                 ;(ET_PPDELAY) no delay between pulses
                      01176 
0034D6 0001           01177     dw      0x0001              ;(ET_SMART1) P+1
                      01178                                 ;(ET_SMART2) No second pass
                      01179 
0034D8 0000           01180     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      01181                                 ;(ET_RESERVED)
                      01182 
                      01183 ;+----+
                      01184 ;+ 1D +
                      01185 ;+-----------------------------------+
                      01186 ;+ Motorola 8Kx8 EPROM in 24-pin DIP +
                      01187 ;+ (also serves for the MCM68766)    +
                      01188 ;+-----------------------------------+
0034DA                01189 ep_MCM68764:
0034DA FF48           01190     dw      (0xFF<<8)+(es_68764-estrings)/8                             ;(ET_NAME)
                      01191 
0034DC 8814           01192     dw      (((es_mcm68764-estrings)/8)<<8)+(es_motorola-estrings)/8    ;(ET_PARTNO1)
0034DE 8914           01193     dw      (((es_mcm68766-estrings)/8)<<8)+(es_motorola-estrings)/8    ;(ET_PARTNO2)
0034E0 FFFF           01194     dw      0xFFFF                                                      ;(ET_PARTNO3) null
0034E2 FFFF           01195     dw      0xFFFF                                                      ;(ET_PARTNO4) null
0034E4 FFFF           01196     dw      0xFFFF                                                      ;(ET_PARTNO5) null
0034E6 FFFF           01197     dw      0xFFFF                                                      ;(ET_PARTNO6) null
0034E8 FFFF           01198     dw      0xFFFF                                                      ;(ET_PARTNO7) null
0034EA FFFF           01199     dw      0xFFFF                                                      ;(ET_PARTNO8) null
0034EC FFFF           01200     dw      0xFFFF                                                      ;(ET_PARTNO9) null
0034EE FFFF           01201     dw      0xFFFF                                                      ;(ET_PARTN10) null
                      01202 
0034F0 5285           01203     dw      0x5285              ;(ET_BYTES)8196 bytes, 8 bits/byte
                      01204                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      01205 
0034F2 3014           01206     dw      0x3014              ;(ET_A11A12)A11 on pin 18, A12 on pin 21
                      01207                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      01208 
0034F4 0203           01209     dw      0x0203              ;(ET_PGMVPP)no PGM pin, Vpp on pin 20
                      01210                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 6V
                      01211 
0034F6 1441           01212     dw      (.20<<8)+0x41       ;(ET_VPPSETUP)Vpp = 25V, 0V during read, pulsed Vpp, return to +5V
                      01213                                 ;(ET_PROGREPS) max 20 passes
                      01214 
0034F8 0064           01215     dw      (0x00<<8)+.100      ;(ET_PROGPULSE) 1 mS programming pulse width
                      01216                                 ;(ET_PPDELAY) no delay between pulses
                      01217 
0034FA 0080           01218     dw      0x0080              ;(ET_SMART1) P, no n (bit 7 set to make it a smart algorithm.)
                      01219                                 ;(ET_SMART2)
                      01220 
0034FC 0000           01221     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      01222                                 ;(ET_RESERVED)
                      01223 
                      01224 ;+----+
                      01225 ;+ 1E +
                      01226 ;+----------------------------+
                      01227 ;+ Sharp 8Kx8 in a 24-pin DIP +
                      01228 ;+----------------------------+
0034FE                01229 ep_LH5749:
0034FE FF49           01230     dw      (0xFF<<8)+(es_lh5749-estrings)/8                        ;(ET_NAME)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 125
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01231 
003500 491F           01232     dw      (((es_lh5749-estrings)/8)<<8)+(es_sharp-estrings)/8     ;(ET_PARTNO1)
003502 FFFF           01233     dw      0xFFFF                                                  ;(ET_PARTNO2) null
003504 FFFF           01234     dw      0xFFFF                                                  ;(ET_PARTNO3) null
003506 FFFF           01235     dw      0xFFFF                                                  ;(ET_PARTNO4) null
003508 FFFF           01236     dw      0xFFFF                                                  ;(ET_PARTNO5) null
00350A FFFF           01237     dw      0xFFFF                                                  ;(ET_PARTNO6) null
00350C FFFF           01238     dw      0xFFFF                                                  ;(ET_PARTNO7) null
00350E FFFF           01239     dw      0xFFFF                                                  ;(ET_PARTNO8) null
003510 FFFF           01240     dw      0xFFFF                                                  ;(ET_PARTNO9) null
003512 FFFF           01241     dw      0xFFFF                                                  ;(ET_PARTN10) null
                      01242 
003514 5485           01243     dw      0x5485              ;(ET_BYTES)8K bytes, 8 bits/byte
                      01244                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01245 
003516 3021           01246     dw      0x3021              ;(ET_A11A12)A11 on pin 19, A12 on pin 18
                      01247                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      01248 
003518 0203           01249     dw      0x0203              ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01250                                 ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01251 
00351A 1921           01252     dw      (.25<<8)+0x21       ;(ET_VPPSETUP)Vpp = 13.1V, 0V during read, pulsed Vpp, return to +5V
                      01253                                 ;(ET_PROGREPS) max 25 passes
                      01254 
00351C 0064           01255     dw      (0x00<<8)+.100      ;(ET_PROGPULSE) 1 mS programming pulse width
                      01256                                 ;(ET_PPDELAY) no delay between pulses
                      01257 
00351E 0033           01258     dw      0x0033              ;(ET_SMART1) P+ 3n*ET_PROGPULSE
                      01259                                 ;(ET_SMART2)
                      01260 
003520 0000           01261     dw      0x0000              ;(ET_SPECIAL) Nothing special
                      01262                                 ;(ET_RESERVED)
                      01263 
                      01264 ;+----+
                      01265 ;+ 1F +
                      01266 ;+----------------------------------------------+
                      01267 ;+ "Fast" algorithm                             +
                      01268 ;+ 8Xx8 EPROM in 24-pin DIP                     +
                      01269 ;+ Requires Vcc adjustment for programming      +
                      01270 ;+----------------------------------------------+
003522                01271 ep_27HC641:
003522 FF4A           01272     dw      (0xFF<<8)+(es_27hc641-estrings)/8                           ;(ET_NAME)
                      01273 
003524 5F02           01274     dw      (((es_at27hc641-estrings)/8)<<8)+(es_atmel-estrings)/8      ;(ET_PARTNO1)
003526 6002           01275     dw      (((es_at27hc642-estrings)/8)<<8)+(es_atmel-estrings)/8      ;(ET_PARTNO2)
003528 4A10           01276     dw      (((es_27hc641-estrings)/8)<<8)+(es_microchip-estrings)/8    ;(ET_PARTNO3)
00352A FFFF           01277     dw      0xFFFF                                                      ;(ET_PARTNO4) null
00352C FFFF           01278     dw      0xFFFF                                                      ;(ET_PARTNO5) null
00352E FFFF           01279     dw      0xFFFF                                                      ;(ET_PARTNO6) null
003530 FFFF           01280     dw      0xFFFF                                                      ;(ET_PARTNO7) null
003532 FFFF           01281     dw      0xFFFF                                                      ;(ET_PARTNO8) null
003534 FFFF           01282     dw      0xFFFF                                                      ;(ET_PARTNO9) null
003536 FFFF           01283     dw      0xFFFF                                                      ;(ET_PARTN10) null
                      01284 
003538 5485           01285     dw      0x5485          ;(ET_BYTES)8K bytes, 8 bits/byte
                      01286                             ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01287 
00353A 3021           01288     dw      0x3021          ;(ET_A11A12)A11 on pin 19, A12 on pin 18
                      01289                             ;(ET_OECS)-OE on pin 20, no CS pin
                      01290 
00353C 0203           01291     dw      0x0203          ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01292                             ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01293 
00353E 1911           01294     dw      (.25<<8)+0x11   ;(ET_VPPSETUP)Vpp = 12.75V, 0V during read, pulsed Vpp, return to 5V
                      01295                             ;(ET_PROGREPS) max 25 tries
                      01296 
003540 000A           01297     dw      (0x00<<8)+.10   ;(ET_PROGPULSE) 100 uS programming pulse width
                      01298                             ;(ET_PPDELAY) no delay between pulses
                      01299 
003542 0033           01300     dw      0x0033          ;(ET_SMART1) P+3P*ET_PROGPULSE smart programming
                      01301                             ;(ET_SMART2) no second pass
                      01302 
003544 0000           01303     dw      0x0000          ;(ET_SPECIAL) Nothing special
                      01304                             ;(ET_RESERVED)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 126
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01305 
                      01306 ;+----+
                      01307 ;+ 20 +
                      01308 ;+----------------------------------------------+
                      01309 ;+ 8Xx8 EPROM in 24-pin DIP                     +
                      01310 ;+ Requires Vcc adjustment for programming      +
                      01311 ;+ Note: Cannot blank-check the Signetics part  +
                      01312 ;+       because erased bits are "undefined."   +
                      01313 ;+----------------------------------------------+
003546                01314 ep_27HC641s:
003546 FF4C           01315     dw      (0xFF<<8)+(es_27hc641s-estrings)/8                          ;(ET_NAME)
                      01316 
003548 4A20           01317     dw      (((es_27hc641-estrings)/8)<<8)+(es_signetics-estrings)/8    ;(ET_PARTNO1)
00354A FFFF           01318     dw      0xFFFF                                                      ;(ET_PARTNO2) null
00354C FFFF           01319     dw      0xFFFF                                                      ;(ET_PARTNO3) null
00354E FFFF           01320     dw      0xFFFF                                                      ;(ET_PARTNO4) null
003550 FFFF           01321     dw      0xFFFF                                                      ;(ET_PARTNO5) null
003552 FFFF           01322     dw      0xFFFF                                                      ;(ET_PARTNO6) null
003554 FFFF           01323     dw      0xFFFF                                                      ;(ET_PARTNO7) null
003556 FFFF           01324     dw      0xFFFF                                                      ;(ET_PARTNO8) null
003558 FFFF           01325     dw      0xFFFF                                                      ;(ET_PARTNO9) null
00355A FFFF           01326     dw      0xFFFF                                                      ;(ET_PARTN10) null
                      01327 
00355C 5485           01328     dw      0x5485          ;(ET_BYTES)8K bytes, 8 bits/byte
                      01329                             ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01330 
00355E 3021           01331     dw      0x3021          ;(ET_A11A12)A11 on pin 19, A12 on pin 18
                      01332                             ;(ET_OECS)-OE on pin 20, no CS pin
                      01333 
003560 0203           01334     dw      0x0203          ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01335                             ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01336 
003562 1911           01337     dw      (.25<<8)+0x11   ;(ET_VPPSETUP)Vpp = 12.75V, 0V during read, pulsed Vpp, return to 5V
                      01338                             ;(ET_PROGREPS) max 25 tries
                      01339 
003564 000A           01340     dw      (0x00<<8)+.10   ;(ET_PROGPULSE) 100 uS programming pulse width
                      01341                             ;(ET_PPDELAY) no delay between pulses
                      01342 
003566 0033           01343     dw      0x0033          ;(ET_SMART1) P+3P*ET_PROGPULSE smart programming
                      01344                             ;(ET_SMART2) no second pass
                      01345 
003568 0008           01346     dw      0x0008          ;(ET_SPECIAL) No blank-check (erased bits are undefined.)
                      01347                             ;(ET_RESERVED)
                      01348 
                      01349 ;+----+
                      01350 ;+ 21 +
                      01351 ;+-----------------------------------------+
                      01352 ;+ "Express" Algorithm                     +
                      01353 ;+ Atmel (etc.)8Xx8 EPROM in 24-pin DIP    +
                      01354 ;+ Requires Vcc adjustment for programming +
                      01355 ;+ Serves both the  AT27HC641R and the     +
                      01356 ;+ AT27HC642R                              +
                      01357 ;+-----------------------------------------+
00356A                01358 ep_27HC641r:
00356A FF4D           01359     dw      (0xFF<<8)+(es_27hc641r-estrings)/8                          ;(ET_NAME)
                      01360 
00356C 6202           01361     dw      (((es_at27hc641r-estrings)/8)<<8)+(es_atmel-estrings)/8     ;(ET_PARTNO1)
00356E 6302           01362     dw      (((es_at27hc642r-estrings)/8)<<8)+(es_atmel-estrings)/8     ;(ET_PARTNO2)
003570 4A10           01363     dw      (((es_27hc641-estrings)/8)<<8)+(es_microchip-estrings)/8    ;(ET_PARTNO3)
003572 FFFF           01364     dw      0xFFFF                                                      ;(ET_PARTNO4) null
003574 FFFF           01365     dw      0xFFFF                                                      ;(ET_PARTNO5) null
003576 FFFF           01366     dw      0xFFFF                                                      ;(ET_PARTNO6) null
003578 FFFF           01367     dw      0xFFFF                                                      ;(ET_PARTNO7) null
00357A FFFF           01368     dw      0xFFFF                                                      ;(ET_PARTNO8) null
00357C FFFF           01369     dw      0xFFFF                                                      ;(ET_PARTNO9) null
                      01370 
00357E 00BC           01371     dw      (es_65v-estrings)/8                     ;(ET_VCCMSG)Prog. Vcc requires adjustment
                      01372                                                     ;(ET_VPPMSG) null
                      01373 
003580 5485           01374     dw      0x5485          ;(ET_BYTES)8K bytes, 8 bits/byte
                      01375                             ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01376 
003582 3021           01377     dw      0x3021          ;(ET_A11A12)A11 on pin 19, A12 on pin 18
                      01378                             ;(ET_OECS)-OE on pin 20, no CS pin
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 127
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01379 
003584 0203           01380     dw      0x0203          ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01381                             ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01382 
003586 0A21           01383     dw      (.10<<8)+0x21   ;(ET_VPPSETUP)Vpp = 13.15V, 0V during read, pulsed Vpp, return to 5V
                      01384                             ;(ET_PROGREPS) max 10 tries
                      01385 
003588 000A           01386     dw      (0x00<<8)+.10   ;(ET_PROGPULSE) 100 uS programming pulse width
                      01387                             ;(ET_PPDELAY) no delay between pulses
                      01388 
00358A 8041           01389     dw      0x8041          ;(ET_SMART1) one pass through
                      01390                             ;(ET_SMART2) P+0
                      01391 
00358C 0001           01392     dw      0x0001          ;(ET_SPECIAL) Programming Vcc requires adjustment
                      01393                             ;(ET_RESERVED)
                      01394 
                      01395 ;+----+
                      01396 ;+ 22 +
                      01397 ;+----------------+
                      01398 ;+ WSI 8Kx8 EPROM +
                      01399 ;+----------------+
00358E                01400 ep_57C49b:
00358E FF4E           01401     dw      (0xFF<<8)+(es_57c49b-estrings)/8                    ;(ET_NAME)
                      01402 
003590 B727           01403     dw      (((es_ws57c49b-estrings)/8)<<8)+(es_wsi-estrings)/8 ;(ET_PARTNO1)
003592 FFFF           01404     dw      0xFFFF                                              ;(ET_PARTNO2) null
003594 FFFF           01405     dw      0xFFFF                                              ;(ET_PARTNO3) null
003596 FFFF           01406     dw      0xFFFF                                              ;(ET_PARTNO4) null
003598 FFFF           01407     dw      0xFFFF                                              ;(ET_PARTNO5) null
00359A FFFF           01408     dw      0xFFFF                                              ;(ET_PARTNO6) null
00359C FFFF           01409     dw      0xFFFF                                              ;(ET_PARTNO7) null
00359E FFFF           01410     dw      0xFFFF                                              ;(ET_PARTNO8) null
0035A0 FFFF           01411     dw      0xFFFF                                              ;(ET_PARTNO9) null
                      01412 
0035A2 FFBB           01413     dw      (0xFF<<8)+(es_55v-estrings)/8           ;(ET_VCCMSG)prog. Vcc requires adjustment
                      01414                                                     ;(ET_VPPMSG) null
                      01415 
0035A4 5485           01416     dw      0x5485              ;(ET_BYTES)8K bytes, 8 bits/byte
                      01417                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01418 
0035A6 3021           01419     dw      0x3021              ;(ET_A11A12)A11 on pin 19, A12 on pin 18
                      01420                                 ;(ET_OECS)-OE on pin 20, no CS pin
                      01421 
0035A8 0203           01422     dw      0x0203              ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01423                                 ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01424 
0035AA 0121           01425     dw      (.01<<8)+0x21       ;(ET_VPPSETUP)Vpp = 13.15V, 0V during read, pulsed Vpp, return to +5V
                      01426                                 ;(ET_PROGREPS) write once
                      01427 
0035AC 008A           01428     dw      (0x00<<8)+.10+0x80  ;(ET_PROGPULSE) 10 mS programming pulse width
                      01429                                 ;(ET_PPDELAY) no delay between pulses
                      01430 
0035AE 0000           01431     dw      0x0000              ;(ET_SMART1) No smart programming
                      01432                                 ;(ET_SMART2)
                      01433 
0035B0 0001           01434     dw      0x0001              ;(ET_SPECIAL) Programming Vcc requires adjustment
                      01435                                 ;(ET_RESERVED)
                      01436 
                      01437 ;+----+
                      01438 ;+ 23 +
                      01439 ;+------------------------------------------+
                      01440 ;+ WSI 8Kx8 EPROM                           +
                      01441 ;+ Note: The Smart algorith mere is a guess +
                      01442 ;+------------------------------------------+
0035B2                01443 ep_57C49C:
0035B2 FF4F           01444     dw      (0xFF<<8)+(es_57c49c-estrings)/8                    ;(ET_NAME)
                      01445 
0035B4 B827           01446     dw      (((es_ws57c49c-estrings)/8)<<8)+(es_wsi-estrings)/8 ;(ET_PARTNO1)
0035B6 FFFF           01447     dw      0xFFFF                                              ;(ET_PARTNO2) null
0035B8 FFFF           01448     dw      0xFFFF                                              ;(ET_PARTNO3) null
0035BA FFFF           01449     dw      0xFFFF                                              ;(ET_PARTNO4) null
0035BC FFFF           01450     dw      0xFFFF                                              ;(ET_PARTNO5) null
0035BE FFFF           01451     dw      0xFFFF                                              ;(ET_PARTNO6) null
0035C0 FFFF           01452     dw      0xFFFF                                              ;(ET_PARTNO7) null
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 128
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0035C2 FFFF           01453     dw      0xFFFF                                              ;(ET_PARTNO8) null
0035C4 FFFF           01454     dw      0xFFFF                                              ;(ET_PARTNO9) null
0035C6 FFFF           01455     dw      0xFFFF                                              ;(ET_PARTNO10) null
                      01456 
0035C8 5485           01457     dw      0x5485          ;(ET_BYTES)8K bytes, 8 bits/byte
                      01458                             ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01459 
0035CA 3021           01460     dw      0x3021          ;(ET_A11A12)A11 on pin 19, A12 on pin 18
                      01461                             ;(ET_OECS)-OE on pin 20, no CS pin
                      01462 
0035CC 0203           01463     dw      0x0203          ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01464                             ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01465 
0035CE 1911           01466     dw      (.25<<8)+0x11   ;(ET_VPPSETUP)Vpp = 12.75V, 0V during read, pulsed Vpp, return to +5V
                      01467                             ;(ET_PROGREPS) max p = 25
                      01468 
0035D0 000F           01469     dw      (0x00<<8)+.15   ;(ET_PROGPULSE) 150 uS programming pulse width
                      01470                             ;(ET_PPDELAY) no delay between pulses
                      01471 
0035D2 0001           01472     dw      0x0001              ;(ET_SMART1) P+1
                      01473                                 ;(ET_SMART2) No second pass
                      01474 
0035D4 0000           01475     dw      0x0000          ;(ET_SPECIAL) Nothing special
                      01476                             ;(ET_RESERVED)
                      01477 
                      01478 ;+----+
                      01479 ;+ 24 +
                      01480 ;+------------------------------------+
                      01481 ;+ 2Kx8 EEPROM                        +
                      01482 ;+ Not self-timed, 1.2 mS write pulse +
                      01483 ;+------------------------------------+
0035D6                01484 ep_52b13h:
0035D6 FF50           01485     dw      (0xFF<<8)+(es_52b13h-estrings)/8                    ;(ET_NAME)
                      01486 
0035D8 501D           01487     dw      (((es_52b13h-estrings)/8)<<8)+(es_seeq-estrings)/8  ;(ET_PARTNO1)
0035DA FFFF           01488     dw      0xFFFF              ;(ET_PARTNO2) null
0035DC FFFF           01489     dw      0xFFFF              ;(ET_PARTNO3) null
0035DE FFFF           01490     dw      0xFFFF              ;(ET_PARTNO4) null
0035E0 FFFF           01491     dw      0xFFFF              ;(ET_PARTNO5) null
0035E2 FFFF           01492     dw      0xFFFF              ;(ET_PARTNO6) null
0035E4 FFFF           01493     dw      0xFFFF              ;(ET_PARTNO7) null
0035E6 FFFF           01494     dw      0xFFFF              ;(ET_PARTNO8) null
0035E8 FFFF           01495     dw      0xFFFF              ;(ET_PARTNO9) null
0035EA FFFF           01496     dw      0xFFFF              ;(ET_PARTNO10) null
                      01497 
0035EC 5283           01498     dw      0x5283              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      01499                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 19
                      01500 
0035EE 3100           01501     dw      0x3100              ;(ET_A11A12)no A11 pin, no A12 pin
                      01502                                 ;(ET_OECS)-OE on pin 20, active-low CS on pin 18
                      01503 
0035F0 0140           01504     dw      0x0140              ;(ET_PGMVPP)active-low PGM on pin 21, no Vpp pin
                      01505                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      01506 
0035F2 0106           01507     dw      (.01<<8)+0x06       ;(ET_VPPSETUP)Vpp switcher off, 5V during read, pulsed PGM
                      01508                                 ;(ET_PROGREPS) write once
                      01509 
0035F4 0078           01510     dw      (0x00<<8)+.120      ;(ET_PROGPULSE) 1200 uS programming pulse width
                      01511                                 ;(ET_PPDELAY) no delay between pulses
                      01512 
0035F6 4149           01513     dw      0x4149              ;(ET_SMART1) pass 1 erases the EEPROM
                      01514                                 ;(ET_SMART2) pass 2 writes it
                      01515 
0035F8 0008           01516     dw      0x0008              ;(ET_SPECIAL) no blank check
                      01517                                 ;(ET_RESERVED)
                      01518 
                      01519 ;+----+
                      01520 ;+ 25 +
                      01521 ;+--------------------------------+
                      01522 ;+ Intersil IM6658                +
                      01523 ;+ Requires external negative Vpp +
                      01524 ;+--------------------------------+
0035FA                01525 ep_IM6658:
0035FA FF51           01526     dw      (0xFF<<8)+(es_im6658-estrings)/8                        ;(ET_NAME)
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 129
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01527 
0035FC 510F           01528     dw      (((es_im6658-estrings)/8)<<8)+(es_intersil-estrings)/8  ;(ET_PARTNO1)
0035FE FFFF           01529     dw      0xFFFF              ;(ET_PARTNO2) null
003600 FFFF           01530     dw      0xFFFF              ;(ET_PARTNO3) null
003602 FFFF           01531     dw      0xFFFF              ;(ET_PARTNO4) null
003604 FFFF           01532     dw      0xFFFF              ;(ET_PARTNO5) null
003606 FFFF           01533     dw      0xFFFF              ;(ET_PARTNO6) null
003608 FFFF           01534     dw      0xFFFF              ;(ET_PARTNO7) null
00360A FFFF           01535     dw      0xFFFF              ;(ET_PARTNO8) null
00360C FFFF           01536     dw      0xFFFF              ;(ET_PARTNO9) null
                      01537 
00360E BDFF           01538     dw      (((es_n30v-estrings)/8)<<8)+0xFF    ;(ET_VPPMSG)
                      01539                                                 ;(ET_VCCMSG) null
                      01540 
003610 5082           01541     dw      0x5082                  ;(ET_BYTES)1024 bytes, 8 bits/byte
                      01542                                     ;(ET_A9A10)A9 on pin 22, no A10 pin
                      01543 
003612 400B           01544     dw      0x400B                  ;(ET_A11A12) no A11, -Address Strobe (-AS) on pin 20
                      01545                                     ;(ET_OECS)-OE on pin 21, no CS pin
                      01546 
003614 0101           01547     dw      0x0101                  ;(ET_PGMVPP)No PGM pin, Vpp on pin 18
                      01548                                     ;(ET_VBBVDD)no Vbb or Vdd (Vdd pin 19 is a stuck-high pin)
                      01549 
003616 0255           01550     dw      (.2<<8)+0x55            ;(ET_VPPSETUP)External Vpp, 5V during read, pulsed Vpp, return to +5
                            V
                      01551                                     ;(ET_PROGREPS) max 2 passes for P
                      01552 
003618 8794           01553     dw      ((.7+0x80)<<8)+.20+0x80 ;(ET_PROGPULSE) 20 mS programming pulse width
                      01554                                     ;(ET_PPDELAY) 7 mS delay between pulses
                      01555 
00361A 0024           01556     dw      0x0024                  ;(ET_SMART1) P+4P smart programming
                      01557                                     ;(ET_SMART1) no second pass
                      01558 
00361C 0004           01559     dw      0x0004                  ;(ET_SPECIAL)requires external negative Vpp
                      01560                                     ;(ET_RESERVED)
                      01561 
                      01562 ;+----+
                      01563 ;+ 26 +
                      01564 ;+-----------------------------------------------------+
                      01565 ;+ Sharp 2Kx8 EPROM, with Vcc=6.2V during programming +
                      01566 ;+-----------------------------------------------------+
00361E                01567 ep_lh57191:
00361E FF52           01568     dw      (0xFF<<8)+(es_lh57191-estrings)/8                       ;(ET_NAME)
                      01569 
003620 521F           01570     dw      (((es_lh57191-estrings)/8)<<8)+(es_sharp-estrings)/8    ;(ET_PARTNO1)
003622 FFFF           01571     dw      0xFFFF              ;(ET_PARTNO2) null
003624 FFFF           01572     dw      0xFFFF              ;(ET_PARTNO3) null
003626 FFFF           01573     dw      0xFFFF              ;(ET_PARTNO4) null
003628 FFFF           01574     dw      0xFFFF              ;(ET_PARTNO5) null
00362A FFFF           01575     dw      0xFFFF              ;(ET_PARTNO6) null
00362C FFFF           01576     dw      0xFFFF              ;(ET_PARTNO7) null
00362E FFFF           01577     dw      0xFFFF              ;(ET_PARTNO8) null
003630 FFFF           01578     dw      0xFFFF              ;(ET_PARTNO9) null
003632 FFFF           01579     dw      0xFFFF              ;(ET_PARTN10) null
                      01580 
003634 5483           01581     dw      0x5483              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      01582                                 ;(ET_A9A10)A9 on pin 22, A10 on pin 21
                      01583 
003636 3A90           01584     dw      0x3A90              ;(ET_A11A12)Force pin 18 high (CS3), no A12
                      01585                                 ;(ET_OECS)-OE on pin 20, active-high CS on pin 19 (CS2)
                      01586 
003638 0203           01587     dw      0x0203              ;(ET_PGMVPP)No PGM pin, Vpp on pin 20
                      01588                                 ;(ET_VBBVDD)no Vbb or Vdd, use 6.2V supply for programming Vcc
                      01589 
00363A 1921           01590     dw      (.25<<8)+0x21       ;(ET_VPPSETUP)Vpp = 13.15V, 0V during read, pulsed Vpp, return to +5V
                      01591                                 ;(ET_PROGREPS) max p = 25
                      01592 
00363C 0064           01593     dw      (0x00<<8)+.100      ;(ET_PROGPULSE) 1000 uS programming pulse width
                      01594                                 ;(ET_PPDELAY) no delay between pulses
                      01595 
00363E 0033           01596     dw      0x0033              ;(ET_SMART1) P+ 3*P*1000 uS pulse
                      01597                                 ;(ET_SMART2) No second pass
                      01598 
003640 0000           01599     dw      0x0000              ;(ET_SPECIAL) Nothing special
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 130
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01600                                 ;(ET_RESERVED)
                      01601 
                      01602 ;+----+
                      01603 ;+ 27 +
                      01604 ;+------------------------------------+
                      01605 ;+ 512x8 EEPROM                       +
                      01606 ;+ Not self-timed, 1.2 mS write pulse +
                      01607 ;+------------------------------------+
003642                01608 ep_28c04n:
003642 FF53           01609     dw      (0xFF<<8)+(es_28c04n-estrings)/8                    ;(ET_NAME)
                      01610 
003644 9217           01611     dw      (((es_upd28c04-estrings)/8)<<8)+(es_nec-estrings)/8 ;(ET_PARTNO1)
003646 FFFF           01612     dw      0xFFFF              ;(ET_PARTNO2) null
003648 FFFF           01613     dw      0xFFFF              ;(ET_PARTNO3) null
00364A FFFF           01614     dw      0xFFFF              ;(ET_PARTNO4) null
00364C FFFF           01615     dw      0xFFFF              ;(ET_PARTNO5) null
00364E FFFF           01616     dw      0xFFFF              ;(ET_PARTNO6) null
003650 FFFF           01617     dw      0xFFFF              ;(ET_PARTNO7) null
003652 FFFF           01618     dw      0xFFFF              ;(ET_PARTNO8) null
003654 FFFF           01619     dw      0xFFFF              ;(ET_PARTNO9) null
003656 FFFF           01620     dw      0xFFFF              ;(ET_PARTNO10) null
                      01621 
003658 0083           01622     dw      0x0083              ;(ET_BYTES)2048 bytes, 8 bits/byte
                      01623                                 ;(ET_A9A10)No A9 pin, No A10 pin
                      01624 
00365A 3100           01625     dw      0x3100              ;(ET_A11A12)no A11 pin, no A12 pin
                      01626                                 ;(ET_OECS)-OE on pin 20, active-low CS on pin 18
                      01627 
00365C 0140           01628     dw      0x0140              ;(ET_PGMVPP)active-low PGM on pin 21, no Vpp pin
                      01629                                 ;(ET_VBBVDD)no Vbb or Vdd, Vcc = 5V
                      01630 
00365E 0106           01631     dw      (.01<<8)+0x06       ;(ET_VPPSETUP)Vpp switcher off, 5V during read, pulsed PGM
                      01632                                 ;(ET_PROGREPS) write once
                      01633 
003660 0078           01634     dw      (0x00<<8)+.120      ;(ET_PROGPULSE) 1200 uS programming pulse width
                      01635                                 ;(ET_PPDELAY) no delay between pulses
                      01636 
003662 0000           01637     dw      0x0000              ;(ET_SMART1) No smart programming
                      01638                                 ;(ET_SMART2)
                      01639 
003664 0008           01640     dw      0x0008              ;(ET_SPECIAL) no blank check
                      01641                                 ;(ET_RESERVED)
                      01642 
                      01643 ;How many EPROMs are in this table
  00000028            01644 FEPROM_COUNT    equ     ($-eprom_table)/ET_RLENGTH
                      01645 
003666 0000           01646     dw  0               ;end of table marker
                      01647 
                      06633 
                      06634 ;********************************************************************************
                      06635 ; EPROM name strings
                      06636 ;********************************************************************************
                      06637     #include    EPROMNames.inc
                      00001 ;========================================================================
                      00002 ; Strings used to describe the supported EPROMs
                      00003 ; Each entry is a null-terminated string, where the null termination is
                      00004 ; on an even byte. The odd (high) byte of the termination word is the
                      00005 ; byte count of the message string.
                      00006 ;
                      00007 ; The minimum allowed string length here is 5 ASCII characters, because
                      00008 ; the addresses used to reference these strings are divided by 4, and
                      00009 ; the print routine hunts for the end of the prior string to find the
                      00010 ; exact beginning of the intended string.
                      00011 ;========================================================================
                      00012 
                      00013 ;Force this file to be on a quad-word boundary
  00003668            00014 es_here:    equ $
003668                00015             org     (es_here+7) & 0xFFF8
                      00016 
003668                00017 estrings:
003668 0000 0000 0000 00018                 dw  0,0,0,0                 ;start string so alignment works
       0000 
                      00019 
                      00020 ;-------------
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 131
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00021 ;Manufacturers
                      00022 ;-------------
003670 4D41 2044 0020 00023 es_amd:         dw  "AMD  ",0x05<<8
       0500 
003678 7441 656D 006C 00024 es_atmel:       dw  "Atmel",0x05<<8
       0500 
003680 6143 6174 796C 00025 es_catalyst:    dw  "Catalyst",0x08<<8
       7473 0800 
00368A 6C45 202E 7241 00026 es_elecarrays:  dw  "El. Arrays",0x0A<<8
       6172 7379 0A00 
003696 7545 6F72 6574 00027 es_eurotech:    dw  "Eurotech.",0x09<<8
       6863 002E 0900 
0036A2 7845 6C65 0020 00028 es_exel:        dw  "Exel ",0x05<<8
       0500 
0036AA 6146 7269 6863 00029 es_fairchild:   dw  "Fairchild",0x09<<8
       6C69 0064 0900 
0036B6 7546 696A 7374 00030 es_fujitsu:     dw  "Fujitsu",0x07<<8
       0075 0700 
0036C0 4947 2020 0020 00031 es_gi:          dw  "GI   ",0x05<<8
       0500 
0036C8 6148 7272 7369 00032 es_harris:      dw  "Harris",0x06<<8
       0600 
0036D0 6948 6174 6863 00033 es_hitachi:     dw  "Hitachi",0x07<<8
       0069 0700 
0036DA 6E49 6574 006C 00034 es_intel:       dw  "Intel",0x05<<8
       0500 
0036E2 6E49 6574 7372 00035 es_intersil:    dw  "Intersil",0x08<<8
       6C69 0800 
0036EC 694D 7263 636F 00036 es_microchip:   dw  "Microchip",0x09<<8
       6968 0070 0900 
0036F8 694D 7374 6275 00037 es_mitsubishi:  dw  "Mitsubishi",0x0A<<8
       7369 6968 0A00 
003704 4D4D 2045 0020 00038 es_mme:         dw  "MME  ",0x05<<8
       0500 
00370C 6F4D 6F74 6F72 00039 es_motorola:    dw  "Motorola",0x08<<8
       616C 0800 
003716 614E 6974 6E6F 00040 es_national:    dw  "National",0x08<<8
       6C61 0800 
003720 454E 2043 0020 00041 es_nec:         dw  "NEC  ",0x05<<8
       0500 
003728 544E 2045 0020 00042 es_nte:         dw  "NTE  ",0x05<<8
       0500 
003730 6E4F 5320 6D65 00043 es_onsemi:      dw  "On Semi",0x07<<8
       0069 0700 
00373A 4B4F 2049 0020 00044 es_oki:         dw  "OKI  ",0x05<<8
       0500 
003742 6F52 6B63 6577 00045 es_rockwell:    dw  "Rockwell",0x08<<8
       6C6C 0800 
00374C 6153 736D 6E75 00046 es_samsung:     dw  "Samsung",0x07<<8
       0067 0700 
003756 6553 7165 0020 00047 es_seeq:        dw  "Seeq ",0x05<<8
       0500 
00375E 4753 2053 0020 00048 es_sgs:         dw  "SGS  ",0x05<<8
       0500 
003766 6853 7261 0070 00049 es_sharp:       dw  "Sharp",0x05<<8
       0500 
00376E 6953 6E67 7465 00050 es_signetics:   dw  "Signetics",0x09<<8
       6369 0073 0900 
00377A 6F53 6976 7465 00051 es_soviet:      dw  "Soviet",0x06<<8
       0600 
003782 5453 2020 0020 00052 es_st:          dw  "ST   ",0x05<<8
       0500 
00378A 6554 6C73 0061 00053 es_tesla:       dw  "Tesla",0x05<<8
       0500 
003792 4954 2020 0020 00054 es_ti:          dw  "TI   ",0x05<<8
       0500 
00379A 6F54 6873 6269 00055 es_toshiba:     dw  "Toshiba",0x07<<8
       0061 0700 
0037A4 5357 2049 0020 00056 es_wsi:         dw  "WSI  ",0x05<<8
       0500 
0037AC 6958 6F63 0072 00057 es_xicor:       dw  "Xicor",0x05<<8
       0500 
                      00058 
                      00059 ;-----------
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 132
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00060 ;EPROM Types
                      00061 ;-----------
0037B4 3732 3430 0020 00062 es_2704:        dw  "2704 ",0x05<<8         ;Type 0
       0500 
0037BC 3832 3430 0041 00063 es_2804a:       dw  "2804A",0x05<<8         ;Type 1
       0500 
0037C4 3832 3043 0034 00064 es_28c04:       dw  "28C04",0x05<<8         ;Type 2
       0500 
0037CC 4D49 3636 3435 00065 es_im6654:      dw  "IM6654",0x06<<8        ;Type 3
       0600 
0037D4 3732 3830 0020 00066 es_2708:        dw  "2708 ",0x05<<8         ;Type 4
       0500 
0037DC 3732 3835 0020 00067 es_2758:        dw  "2758 ",0x05<<8         ;Type 5
       0500 
0037E4 3732 3631 0020 00068 es_2716:        dw  "2716 ",0x05<<8         ;Type 6
       0500 
0037EC 3732 3631 0041 00069 es_2716a:       dw  "2716A",0x05<<8         ;Type 7
       0500 
0037F4 3732 3631 2D41 00070 es_2716afast:   dw  "2716A-fast",0x0A<<8    ;Type 8
       6166 7473 0A00 
003800 3732 3631 0042 00071 es_2716b:       dw  "2716B",0x05<<8         ;Type 9
       0500 
003808 3732 3143 4836 00072 es_27c16h:      dw  "27C16H",0x06<<8        ;Type A
       0600 
003810 3732 3163 4236 00073 es_27c16b:      dw  "27c16B",0x06<<8        ;Type B
       0600 
003818 4D54 3253 3137 00074 es_tms2716:     dw  "TMS2716",0x07<<8       ;Type C
       0036 0700 
003822 3735 3143 3139 00075 es_57c191:      dw  "57C191",0x06<<8        ;Type D
       0600 
00382A 3735 3143 3139 00076 es_57c191c:     dw  "57C191C",0x07<<8       ;Type E
       0043 0700 
003834 3832 3631 0041 00077 es_2816a:       dw  "2816A",0x05<<8         ;Type F
       0500 
00383C 3832 3143 0036 00078 es_28c16:       dw  "28C16",0x05<<8         ;Type 10
       0500 
003844 3832 3631 6941 00079 es_2816ai:      dw  "2816Ai",0x06<<8        ;Type 11
       0600 
00384C 3732 3233 0020 00080 es_2732:        dw  "2732 ",0x05<<8         ;Type 12
       0500 
003854 3732 3233 0041 00081 es_2732a:       dw  "2732A",0x05<<8         ;Type 13
       0500 
00385C 3732 3233 2D41 00082 es_2732afast:   dw  "2732A-fast",0x0A<<8    ;Type 14
       6166 7473 0A00 
003868 3732 3233 0042 00083 es_2732b:       dw  "2732B",0x05<<8         ;Type 15
       0500 
003870 3732 3343 4832 00084 es_27c32h:      dw  "27C32H",0x06<<8        ;Type 16
       0600 
003878 3732 3343 4232 00085 es_27c32b:      dw  "27C32B",0x06<<8        ;Type 17
       0600 
003880 4D54 3253 3335 00086 es_tms2532:     dw  "TMS2532",0x07<<8       ;Type 18
       0032 0700 
00388A 4D54 3253 3335 00087 es_tms2532a:    dw  "TMS2532A",0x08<<8      ;Type 19
       4132 0800 
003894 4D54 3253 3337 00088 es_tms2732a:    dw  "TMS2732A",0x08<<8      ;Type 1A
       4132 0800 
00389E 3735 3443 0033 00089 es_57c43:       dw  "57C43",0x05<<8         ;Type 1B
       0500 
0038A6 3735 3443 4333 00090 es_57c43c:      dw  "57C43C",0x06<<8        ;Type 1C
       0600 
0038AE 3836 3637 0034 00091 es_68764:       dw  "68764",0x05<<8         ;Type 1D
       0500 
0038B6 484C 3735 3934 00092 es_lh5749:      dw  "LH5749",0x06<<8        ;Type 1E
       0600 
0038BE 3732 4348 3436 00093 es_27hc641:     dw  "27HC641",0x07<<8       ;Type 1F
       0031 0700 
0038C8 3732 4348 3436 00094 es_27hc641s:    dw  "27HC641s",0x08<<8      ;Type 20
       7331 0800 
0038D2 3732 4348 3436 00095 es_27hc641r:    dw  "27HC641R",0x08<<8      ;Type 21
       5231 0800 
0038DC 3735 3443 4239 00096 es_57c49b:      dw  "57C49B",0X06<<8        ;Type 22
       0600 
0038E4 3735 3443 4339 00097 es_57c49c:      dw  "57C49C",0X06<<8        ;Type 23
       0600 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 133
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0038EC 3235 3142 4833 00098 es_52b13h:      dw  "52B13H",0x06<<8        ;Type 24
       0600 
0038F4 4D49 3636 3835 00099 es_im6658:      dw  "IM6658",0x06<<8        ;Type 25
       0600 
0038FC 484C 3735 3931 00100 es_lh57191:     dw  "LH57191",0x07<<8       ;Type 26
       0031 0700 
003906 3832 3043 6E34 00101 es_28c04n:      dw  "28C04n",0x06<<8        ;Type 27
       0600 
                      00102 
                      00103 ;---------------------------
                      00104 ;Manufacturers' Part Numbers
                      00105 ;---------------------------
                      00106 ;AMD
00390E 4D41 3732 3830 00107 es_am2708:      dw  "AM2708",0x06<<8
       0600 
003916 4D41 3732 3631 00108 es_am2716:      dw  "AM2716",0x06<<8
       0600 
00391E 4D41 3732 3631 00109 es_am2716b:     dw  "AM2716B",0x07<<8
       0042 0700 
003928 4D41 3732 3233 00110 es_am2732:      dw  "AM2732",0x06<<8
       0600 
003930 4D41 3732 3233 00111 es_am2732a:     dw  "AM2732A",0x07<<8
       0041 0700 
00393A 4D41 3732 3233 00112 es_am2732b:     dw  "AM2732B",0x07<<8
       0042 0700 
                      00113 
                      00114 ;Atmel
003944 5441 3832 3043 00115 es_at28c04:     dw  "AT28C04",0x07<<8
       0034 0700 
00394E 5441 3832 3143 00116 es_at28c16:     dw  "AT28C16",0x07<<8
       0036 0700 
003958 5441 3832 3143 00117 es_at28c16e:    dw  "AT28C16E",0x08<<8
       4536 0800 
003962 5441 3732 4348 00118 es_at27hc641:   dw  "AT27HC641",0x09<<8
       3436 0031 0900 
00396E 5441 3732 4348 00119 es_at27hc642:   dw  "AT27HC642",0x09<<8
       3436 0032 0900 
00397A 5441 3732 4348 00120 es_at27hc641r:  dw  "AT27HC641R",0x0A<<8
       3436 5231 0A00 
003986 5441 3732 4348 00121 es_at27hc642r:  dw  "AT27HC642R",0x0A<<8
       3436 5232 0A00 
                      00122 
                      00123 ;Catalyst = On Semiconductor
003992 4143 3254 4338 00124 es_cat28c16a:   dw  "CAT28C16A",0x09<<8
       3631 0041 0900 
                      00125 
                      00126 ;Electronic Arts
00399E 4145 3732 3830 00127 es_ea2708:      dw  "EA2708",0x06<<8
       0600 
                      00128 
                      00129 ;Exel
0039A6 4C58 3832 3430 00130 es_xl2804a:     dw  "XL2804A",0x07<<8
       0041 0700 
0039B0 4C58 3832 3631 00131 es_xl2816a:     dw  "XL2816A",0x07<<8
       0041 0700 
0039BA 4C58 3832 3143 00132 es_xl28c16a:    dw  "XL28C16A",0x08<<8
       4136 0800 
                      00133 
                      00134 ;Eurotech
0039C4 5445 3732 3631 00135 es_et2716q:     dw  "ET2716Q",0x07<<8
       0051 0700 
0039CE 5445 3732 3233 00136 es_et2732q:     dw  "ET2732Q",0x07<<8
       0051 0700 
                      00137 
                      00138 ;Fairchild
0039D8 3246 3037 0038 00139 es_f2708:       dw  "F2708",0x05<<8
       0500 
0039E0 4D4E 3243 4337 00140 es_nmc27c16b:   dw  "NMC27C16B",0x09<<8
       3631 0042 0900 
0039EC 4D4E 3243 4337 00141 es_nmc27c16h:   dw  "NMC27C16H",0x09<<8
       3631 0048 0900 
0039F8 3246 3337 0032 00142 es_f2732:       dw  "F2732",0x05<<8
       0500 
003A00 4D4E 3243 4337 00143 es_nmc27c32b:   dw  "NMC27C32B",0x09<<8
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 134
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       3233 0042 0900 
003A0C 4D4E 3243 4337 00144 es_nmc27c32h:   dw  "NMC27C32H",0x09<<8
       3233 0048 0900 
                      00145 
                      00146 ;Fujutsu
003A18 424D 324D 3137 00147 es_mbm2716:     dw  "MBM2716",0x07<<8
       0036 0700 
003A22 424D 324D 3337 00148 es_mbm2732:     dw  "MBM2732",0x07<<8
       0032 0700 
003A2C 424D 324D 3337 00149 es_mbm2732a:    dw  "MBM2732A",0x08<<8
       4132 0800 
                      00150 
                      00151 ;Harris
003A36 4D48 362D 3537 00152 es_hm6758:      dw  "HM-6758",0x07<<8
       0038 0700 
                      00153 
                      00154 ;Hitachi
003A40 4E48 3634 3532 00155 es_hn462532:    dw  "HN462532",0x08<<8
       3233 0800 
                      00156 
003A4A 4E48 3634 3732 00157 es_hn462716:    dw  "HN462716",0x08<<8
       3631 0800 
003A54 4E48 3634 3732 00158 es_hn462732g:   dw  "HN462732G",0x09<<8
       3233 0047 0900 
003A60 4E48 3834 3732 00159 es_hn482732ag:  dw  "HN482732AG",0x0A<<8
       3233 4741 0A00 
                      00160 
                      00161 ;Microchip
003A6C 3832 3043 4134 00162 es_28c04a:      dw  "28C04A",0x06<<8
       0600 
003A74 3832 3143 4136 00163 es_28c16a:      dw  "28C16A",0x06<<8
       0600 
                      00164 
                      00165 ;Mitsubishi
003A7C 354D 324C 3337 00166 es_m5l2732k:    dw  "M5L2732K",0x08<<8
       4B32 0800 
                      00167 
                      00168 ;MME
003A86 3555 3535 0043 00169 es_u555c:       dw  "U555C",0x05<<8
       0500 
003A8E 3255 3337 0032 00170 es_u2732:       dw  "U2732",0x05<<8
       0500 
                      00171 
                      00172 ;Motorola
003A96 434D 324D 3335 00173 es_mcm2532:     dw  "MCM2532",0x07<<8
       0032 0700 
003AA0 434D 324D 3337 00174 es_mcm2732      dw  "MCM2732",0x07<<8
       0032 0700 
003AAA 434D 364D 3738 00175 es_mcm68764:    dw  "MCM68764",0x08<<8
       3436 0800 
003AB4 434D 364D 3738 00176 es_mcm68766:    dw  "MCM68766",0x08<<8
       3636 0800 
                      00177 
                      00178 ;National Semiconductor
003ABE 4D4D 3732 3430 00179 es_mm2704:      dw  "MM2704",0x06<<8
       0600 
003AC6 4D4D 3732 3830 00180 es_mm2708       dw  "MM2708",0x06<<8
       0600 
003ACE 4D4D 3732 3631 00181 es_mm2716e:     dw  "MM2716E",0x07<<8
       0045 0700 
003AD8 4D4D 3732 3835 00182 es_mm2758A:     dw  "MM2758Q-A",0x09<<8
       2D51 0041 0900 
                      00183 
                      00184 ;NEC
003AE4 5075 3244 3337 00185 es_upd2732      dw  "uPD2732",0x07<<8
       0032 0700 
003AEE 5075 3244 3337 00186 es_upd2732a:    dw  "uPD2732A",0x08<<8
       4132 0800 
003AF8 5075 3244 4338 00187 es_upd28c04:    dw  "uPD28C04",0x08<<8
       3430 0800 
                      00188 ;NTE
003B02 544E 3245 3037 00189 es_nte2708:     dw  "NTE2708",0x07<<8
       0038 0700 
003B0C 544E 3245 3137 00190 es_nte2716:     dw  "NTE2716",0x07<<8
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 135
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       0036 0700 
                      00191 
                      00192 ;Oki
003B16 534D 324D 3137 00193 es_msm2716as:   dw  "MSM2716AS",0x09<<8
       4136 0053 0900 
003B22 534D 324D 3537 00194 es_msm2758:     dw  "MSM2758",0x07<<8
       0038 0700 
                      00195 
                      00196 ;Rockwell
003B2C 3852 4337 3233 00197 es_r87C32:      dw  "R87C32",0x06<<8
       0600 
                      00198 
                      00199 ;Samsung
003B34 4D4B 3832 3631 00200 es_km2816a:     dw  "KM2816A",0x07<<8
       0041 0700 
                      00201 
                      00202 ;Seeq
003B3E 3235 3142 0033 00203 es_52b13:       dw  "52B13",0x05<<8
       0500 
003B46 3535 3631 0041 00204 es_5516a:       dw  "5516A",0x05<<8
       0500 
                      00205 
                      00206 ;Soviet
003B4E 3735 5233 3246 00207 es_573RF2:      dw  "573RF2",0x06<<8
       0600 
                      00208 
                      00209 ;ST
003B56 324D 3335 0032 00210 es_m2532:       dw  "M2532",0x05<<8
       0500 
003B5E 324D 3137 0036 00211 es_m2716:       dw  "M2716",0x05<<8
       0500 
003B66 324D 3137 6136 00212 es_m2716af:     dw  "M2716a-Fast",0x0B<<8
       462D 7361 0074 
       0B00 
003B74 324D 3337 4132 00213 es_m2732a:      dw  "M2732A",0x06<<8
       0600 
003B7C 324D 3337 6132 00214 es_m2732af:     dw  "M2732a-Fast",0x0B<<8
       462D 7361 0074 
       0B00 
                      00215 
                      00216 ;Tesla
003B8A 484D 3842 3037 00217 es_mhb8708c:    dw  "MHB8708C",0x08<<8
       4338 0800 
                      00218 
                      00219 ;Texas Instruments
003B94 4D54 3253 3035 00220 es_tms2508:     dw  "TMS2508",0x07<<8
       0038 0700 
003B9E 4D54 3253 3135 00221 es_tms2516:     dw  "TMS2516",0x07<<8
       0036 0700 
003BA8 4D54 3253 3037 00222 es_tms2708:     dw  "TMS2708",0x07<<8
       0038 0700 
003BB2 4D54 3253 3537 00223 es_tms2758jl0:  dw  "TMS2758-JL0",0x0B<<8
       2D38 4C4A 0030 
       0B00 
                      00224 
                      00225 ;Toshiba
003BC0 4D54 324D 3337 00226 es_tmm2732d:    dw  "TMM2732D",0x08<<8
       4432 0800 
                      00227 
                      00228 ;Waferscale
003BCA 5357 3735 3143 00229 es_ws57c191:    dw  "WS57C191",0x08<<8
       3139 0800 
003BD4 5357 3735 3143 00230 es_ws57c191b:   dw  "WS57C191B",0x09<<8
       3139 0042 0900 
003BE0 5357 3735 3143 00231 es_ws57c191c:   dw  "WS57C191C",0x09<<8
       3139 0043 0900 
003BEC 5357 3735 3243 00232 es_ws57c291:    dw  "WS57C291",0x08<<8
       3139 0800 
003BF6 5357 3735 3243 00233 es_ws57c291b:   dw  "WS57C291B",0x09<<8
       3139 0042 0900 
003C02 5357 3735 3243 00234 es_ws57c291c:   dw  "WS57C291C",0x09<<8
       3139 0043 0900 
003C0E 5357 3735 3443 00235 es_ws57c43b:    dw  "WS57C43B",0x08<<8
       4233 0800 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 136
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

003C18 5357 3735 3443 00236 es_ws57c43c:    dw  "WS57C43C",0x08<<8
       4333 0800 
003C22 5357 3735 3443 00237 es_ws57c49b:    dw  "WS57C49B",0x08<<8
       4239 0800 
003C2C 5357 3735 3443 00238 es_ws57c49c:    dw  "WS57C49C",0x08<<8
       4339 0800 
                      00239 
                      00240 ;Xicor
003C36 3258 3038 4134 00241 es_x2804a:      dw  "X2804A",0x06<<8
       0600 
003C3E 3258 3138 4236 00242 es_x2816b:      dw  "X2816B",0x06<<8
       0600 
                      00243 
                      00244 
                      00245 ;----------------
                      00246 ;Special voltages
                      00247 ;----------------
003C46 2E35 3035 0056 00248 es_55v:         dw  "5.50V",0x05<<8
       0500 
003C4E 2E36 3035 0056 00249 es_65v:         dw  "6.50V",0x05<<8
       0500 
                      00250 
003C56 7865 6574 6E72 00251 es_n30v:        dw  "external -31V supply & Intersil jumper",.38<<8
       6C61 2D20 3133 
       2056 7573 7070 
       796C 2620 4920 
       746E 7265 6973 
       206C 756A 706D 
       7265 2600 
                      00252 
003C7E                00253 estrings_almostend:                                 ;the last string may slop over
                      00254 
003C7E 7865 6574 6E72 00255 es_n40v:        dw  "external -41V supply & Intersil jumper",.38<<8
       6C61 2D20 3134 
       2056 7573 7070 
       796C 2620 4920 
       746E 7265 6973 
       206C 756A 706D 
       7265 2600 
                      00256 
                      00257 ;*==============================================================================*
                      00258 ; Print an error message in the listing if this is section too big or
                      00259 ; if the last string is not properly double-word aligned
                      00260 ;*==============================================================================*
                      00261     if  estrings_almostend-estrings > .2047
                      00262     error   "estrings section is long!"
                      00263     endif
                      06638 
                      06639 ;********************************************************************************
                      06640 ;Long strings (mainly the help messages)
                      06641 ;********************************************************************************
                      06642     #include    HelpMessages.inc
                      00001 ;********************************************************************************
                      00002 ; Long Strings 
                      00003 ; These null-terminated strings are too big for the 4k-byte memory space
                      00004 ; reserved for strings that can be printes using printf. These require a
                      00005 ; 16-bit address, and should be printed using the kernel's K_PRINTF routine.
                      00006 ;********************************************************************************
                      00007 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
003CA6 0D0D           00008 help_msg:   dw  "\r\r"
003CA8 2020 2020 2020 00009             dw  "                                  MAIN COMMANDS\r\r"
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 414D 
       4E49 4320 4D4F 
       414D 444E 0D53 
       000D 
003CDA 5045 4F52 204D 00010             dw  "EPROM COMMANDS (?E for help)              FILE TRANSFER COMMANDS (?F for help)\r"
       4F43 4D4D 4E41 
       5344 2820 453F 
       6620 726F 6820 
       6C65 2970 2020 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 137
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       2020 2020 2020 
       2020 2020 2020 
       4946 454C 5420 
       4152 534E 4546 
       2052 4F43 4D4D 
       4E41 5344 2820 
       463F 6620 726F 
       6820 6C65 2970 
       000D 
003D2A 2020 4142 204F 00011             dw  "  BAO <offset>   Buffer Address Offset      FAO <offset>   File Address Offset\r"
       6F3C 6666 6573 
       3E74 2020 4220 
       6675 6566 2072 
       6441 7264 7365 
       2073 664F 7366 
       7465 2020 2020 
       2020 4146 204F 
       6F3C 6666 6573 
       3E74 2020 4620 
       6C69 2065 6441 
       7264 7365 2073 
       664F 7366 7465 
       000D 
003D7A 2020 4944 7B20 00012             dw  "  DI {0/1}       Data Invert mode {off/on}  FAO            Automatic FAO mode\r"
       2F30 7D31 2020 
       2020 2020 4420 
       7461 2061 6E49 
       6576 7472 6D20 
       646F 2065 6F7B 
       6666 6F2F 7D6E 
       2020 4146 204F 
       2020 2020 2020 
       2020 2020 4120 
       7475 6D6F 7461 
       6369 4620 4F41 
       6D20 646F 0D65 
003DC8 2020 4245 3C20 00013             dw  "  EB <adr> <cnt> EPROM Blank check          UI <adr> <cnt> Upload as Intel hex\r"
       6461 3E72 3C20 
       6E63 3E74 4520 
       5250 4D4F 4220 
       616C 6B6E 6320 
       6568 6B63 2020 
       2020 2020 2020 
       2020 4955 3C20 
       6461 3E72 3C20 
       6E63 3E74 5520 
       6C70 616F 2064 
       7361 4920 746E 
       6C65 6820 7865 
       000D 
003E18 2020 4345 3C20 00014             dw  "  EC <adr> <cnt> Compare EPROM to buffer    US <adr> <cnt> Upload as S-records\r"
       6461 3E72 3C20 
       6E63 3E74 4320 
       6D6F 6170 6572 
       4520 5250 4D4F 
       7420 206F 7562 
       6666 7265 2020 
       2020 5355 3C20 
       6461 3E72 3C20 
       6E63 3E74 5520 
       6C70 616F 2064 
       7361 5320 722D 
       6365 726F 7364 
       000D 
003E68 2020 4445 3C20 00015             dw  "  ED <type>      Display EPROM specs        :...           Intel hex record\r"      
       7974 6570 203E 
       2020 2020 4420 
       7369 6C70 7961 
       4520 5250 4D4F 
       7320 6570 7363 
       2020 2020 2020 
       2020 2E3A 2E2E 
       2020 2020 2020 
       2020 2020 4920 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 138
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       746E 6C65 6820 
       7865 7220 6365 
       726F 0D64 
003EB4 2020 4545 3C20 00016             dw  "  EE <type>      Custom EPROM Editor        S...           Motorola S-record\r"
       7974 6570 203E 
       2020 2020 4320 
       7375 6F74 206D 
       5045 4F52 204D 
       6445 7469 726F 
       2020 2020 2020 
       2020 2E53 2E2E 
       2020 2020 2020 
       2020 2020 4D20 
       746F 726F 6C6F 
       2061 2D53 6572 
       6F63 6472 000D 
003F02 2020 4C45 2020 00017             dw  "  EL             List EPROM Device Types\r"
       2020 2020 2020 
       2020 2020 4C20 
       7369 2074 5045 
       4F52 204D 6544 
       6976 6563 5420 
       7079 7365 000D 
003F2C 2020 5045 3C20 00018             dw  "  EP <adr> <cnt> Program EPROM            MISCELLANEOUS COMMANDS\r"
       6461 3E72 3C20 
       6E63 3E74 5020 
       6F72 7267 6D61 
       4520 5250 4D4F 
       2020 2020 2020 
       2020 2020 2020 
       494D 4353 4C45 
       414C 454E 554F 
       2053 4F43 4D4D 
       4E41 5344 000D 
003F6E 2020 5245 3C20 00019             dw  "  ER <adr> <cnt> Read EPROM into buffer     DS         Display all Settings\r"
       6461 3E72 3C20 
       6E63 3E74 5220 
       6165 2064 5045 
       4F52 204D 6E69 
       6F74 6220 6675 
       6566 2072 2020 
       2020 5344 2020 
       2020 2020 2020 
       4420 7369 6C70 
       7961 6120 6C6C 
       5320 7465 6974 
       676E 0D73 
003FBA 2020 5345 3C20 00020             dw  "  ES <adr> <cnt> EPROM checkSum             ECHO {0/1} Terminal Echo {off/on}\r"
       6461 3E72 3C20 
       6E63 3E74 4520 
       5250 4D4F 6320 
       6568 6B63 7553 
       206D 2020 2020 
       2020 2020 2020 
       2020 4345 4F48 
       7B20 2F30 7D31 
       5420 7265 696D 
       616E 206C 6345 
       6F68 7B20 666F 
       2F66 6E6F 0D7D 
004008 2020 5445 3C20 00021             dw  "  ET <type>      Select EPROM Device Type   RESET      Reset programmer\r"
       7974 6570 203E 
       2020 2020 5320 
       6C65 6365 2074 
       5045 4F52 204D 
       6544 6976 6563 
       5420 7079 2065 
       2020 4552 4553 
       2054 2020 2020 
       5220 7365 7465 
       7020 6F72 7267 
       6D61 656D 0D72 
004050 2020 2020 2020 00022             dw  "                                            ?D         Diagnostic commands\r"
       2020 2020 2020 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 139
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 443F 2020 
       2020 2020 2020 
       4420 6169 6E67 
       736F 6974 2063 
       6F63 6D6D 6E61 
       7364 000D 
00409C 5542 4646 5245 00023             dw  "BUFFER COMMANDS (?B for help)               ?L         Firmware loader notes\r"      
       4320 4D4F 414D 
       444E 2053 3F28 
       2042 6F66 2072 
       6568 706C 2029 
       2020 2020 2020 
       2020 2020 2020 
       2020 4C3F 2020 
       2020 2020 2020 
       4620 7269 776D 
       7261 2065 6F6C 
       6461 7265 6E20 
       746F 7365 000D 
0040EA 2020 4442 3C20 00024             dw  "  BD <adr> <cnt> Buffer Display             ?N         General ME2700 notes\r"
       6461 3E72 3C20 
       6E63 3E74 4220 
       6675 6566 2072 
       6944 7073 616C 
       2079 2020 2020 
       2020 2020 2020 
       2020 4E3F 2020 
       2020 2020 2020 
       4720 6E65 7265 
       6C61 4D20 3245 
       3037 2030 6F6E 
       6574 0D73 
004136 2020 2020 2020 00025             dw  "                   (space to pause)         ^C or ESC  Abort any command\r"
       2020 2020 2020 
       2020 2020 2020 
       2820 7073 6361 
       2065 6F74 7020 
       7561 6573 2029 
       2020 2020 2020 
       2020 435E 6F20 
       2072 5345 2043 
       4120 6F62 7472 
       6120 796E 6320 
       6D6F 616D 646E 
       000D 
004180 2020 4542 3C20 00026             dw  "  BE <adr>       Buffer Edit (ESC to quit)  ^S, ^Q     Pause, restart Transmit\r"
       6461 3E72 2020 
       2020 2020 4220 
       6675 6566 2072 
       6445 7469 2820 
       5345 2043 6F74 
       7120 6975 2974 
       2020 535E 202C 
       515E 2020 2020 
       5020 7561 6573 
       202C 6572 7473 
       7261 2074 7254 
       6E61 6D73 7469 
       000D 
0041D0 2020 4642 3C20 00027             dw  "  BF <data>      Buffer Fill\r"
       6164 6174 203E 
       2020 2020 4220 
       6675 6566 2072 
       6946 6C6C 000D 
0041EE 6C41 206C 6176 00028             dw  "All values are in hexidecimal. Offsets, data, and types are 2 digits. Addresses\r"
       756C 7365 6120 
       6572 6920 206E 
       6568 6978 6564 
       6963 616D 2E6C 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 140
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       4F20 6666 6573 
       7374 202C 6164 
       6174 202C 6E61 
       2064 7974 6570 
       2073 7261 2065 
       2032 6964 6967 
       7374 202E 6441 
       7264 7365 6573 
       0D73 
00423E 7261 2065 6562 00029             dw  "are between 0 and 1FFF. Counts are between 1 and 2000.\r" 
       7774 6565 206E 
       2030 6E61 2064 
       4631 4646 202E 
       6F43 6E75 7374 
       6120 6572 6220 
       7465 6577 6E65 
       3120 6120 646E 
       3220 3030 2E30 
       000D 
004276 0000           00030             dw  0
                      00031 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
                      00032 
004278 0D0D           00033 dhelp_msg:  dw  "\r\r"
00427A 4944 4741 4F4E 00034             dw  "DIAGNOSTIC COMMANDS (Intended for testing the ME2700 only)\r\r"
       5453 4349 4320 
       4D4F 414D 444E 
       2053 4928 746E 
       6E65 6564 2064 
       6F66 2072 6574 
       7473 6E69 2067 
       6874 2065 454D 
       3732 3030 6F20 
       6C6E 2979 0D0D 
0042B6 2020 5641 5050 00035             dw  "  AVPP {1-4} Adjust Vpp voltage at TP3 {1=12.7V, 2=13.1V, 3=21V, 4=25V}\r"
       7B20 2D31 7D34 
       4120 6A64 7375 
       2074 7056 2070 
       6F76 746C 6761 
       2065 7461 5420 
       3350 7B20 3D31 
       3231 372E 2C56 
       3220 313D 2E33 
       5631 202C 3D33 
       3132 2C56 3420 
       323D 5635 0D7D 
0042FE 2020 2020 2020 00036             dw  "             Note that Vpp will be about 0.7V higher if it is on pin 18.\r"            
       2020 2020 2020 
       4E20 746F 2065 
       6874 7461 5620 
       7070 7720 6C69 
       206C 6562 6120 
       6F62 7475 3020 
       372E 2056 6968 
       6867 7265 6920 
       2066 7469 6920 
       2073 6E6F 7020 
       6E69 3120 2E38 
       000D 
004348 2020 4452 2020 00037             dw  "  RD         Read from EPROM Data pins\r"
       2020 2020 2020 
       5220 6165 2064 
       7266 6D6F 4520 
       5250 4D4F 4420 
       7461 2061 6970 
       736E 000D 
004370 2020 4154 2053 00038             dw  "  TAS {0/1}  Test -AS pin {inactive/active}\r"
       307B 312F 207D 
       5420 7365 2074 
       412D 2053 6970 
       206E 697B 616E 
       7463 7669 2F65 
       6361 6974 6576 
       0D7D 
00439C 2020 4354 2053 00039             dw  "  TCS {0/1}  Test CS pin {inactive/active}\r"
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 141
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       307B 312F 207D 
       5420 7365 2074 
       5343 7020 6E69 
       7B20 6E69 6361 
       6974 6576 612F 
       7463 7669 7D65 
       000D 
0043C8 2020 4854 2049 00040             dw  "  THI {0/1}  Test Stuck-High pin {low/high}\r"
       307B 312F 207D 
       5420 7365 2074 
       7453 6375 2D6B 
       6948 6867 7020 
       6E69 7B20 6F6C 
       2F77 6968 6867 
       0D7D 
0043F4 2020 4F54 2045 00041             dw  "  TOE {0-2}  Test -OE pin {0=inactive, 1=active, 2=programming state}\r"
       307B 322D 207D 
       5420 7365 2074 
       4F2D 2045 6970 
       206E 307B 693D 
       616E 7463 7669 
       2C65 3120 613D 
       7463 7669 2C65 
       3220 703D 6F72 
       7267 6D61 696D 
       676E 7320 6174 
       6574 0D7D 
00443A 2020 5054 4D47 00042             dw  "  TPGM {0/1} Test PGM pin {inactive/active}\r"
       7B20 2F30 7D31 
       5420 7365 2074 
       4750 204D 6970 
       206E 697B 616E 
       7463 7669 2F65 
       6361 6974 6576 
       0D7D 
004466 2020 5054 4F52 00043             dw  "  TPROG      Test EPROM programming (scope loop) until ^C or ESC\r"
       2047 2020 2020 
       5420 7365 2074 
       5045 4F52 204D 
       7270 676F 6172 
       6D6D 6E69 2067 
       7328 6F63 6570 
       6C20 6F6F 2970 
       7520 746E 6C69 
       5E20 2043 726F 
       4520 4353 000D 
0044A8 2020 5254 4145 00044             dw  "  TREAD      Test EPROM reading (scope loop) until ^C or ESC\r"
       2044 2020 2020 
       5420 7365 2074 
       5045 4F52 204D 
       6572 6461 6E69 
       2067 7328 6F63 
       6570 6C20 6F6F 
       2970 7520 746E 
       6C69 5E20 2043 
       726F 4520 4353 
       000D 
0044E6 2020 5654 4442 00045             dw  "  TVBD {0/1} Test Vbb & Vdd pins {off/on}\r"
       7B20 2F30 7D31 
       5420 7365 2074 
       6256 2062 2026 
       6456 2064 6970 
       736E 7B20 666F 
       2F66 6E6F 0D7D 
004510 2020 5654 4343 00046             dw  "  TVCC {0-2} Test Vcc pin {0=inactive, 1=active, 2=programming state}\r"
       7B20 2D30 7D32 
       5420 7365 2074 
       6356 2063 6970 
       206E 307B 693D 
       616E 7463 7669 
       2C65 3120 613D 
       7463 7669 2C65 
       3220 703D 6F72 
       7267 6D61 696D 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 142
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       676E 7320 6174 
       6574 0D7D 
004556 2020 5654 5050 00047             dw  "  TVPP {0-3} Test Vpp pin {0=off, 1=read, 2=programming inactive, 3=Vpp}\r"
       7B20 2D30 7D33 
       5420 7365 2074 
       7056 2070 6970 
       206E 307B 6F3D 
       6666 202C 3D31 
       6572 6461 202C 
       3D32 7270 676F 
       6172 6D6D 6E69 
       2067 6E69 6361 
       6974 6576 202C 
       3D33 7056 7D70 
       000D 
0045A0 2020 4157 3C20 00048             dw  "  WA <adr>   Write <adr> to EPROM Address pins\r"
       6461 3E72 2020 
       5720 6972 6574 
       3C20 6461 3E72 
       7420 206F 5045 
       4F52 204D 6441 
       7264 7365 2073 
       6970 736E 000D 
0045D0 2020 4457 3C20 00049             dw  "  WD <data>  Write <data> to EPROM Data pins\r\r"
       6164 6174 203E 
       5720 6972 6574 
       3C20 6164 6174 
       203E 6F74 4520 
       5250 4D4F 4420 
       7461 2061 6970 
       736E 0D0D 
0045FE 6F46 2072 6361 00050             dw  "For active-high signals, 'active' means +5V and 'inactive' means 0V. For\r"
       6974 6576 682D 
       6769 2068 6973 
       6E67 6C61 2C73 
       2720 6361 6974 
       6576 2027 656D 
       6E61 2073 352B 
       2056 6E61 2064 
       6927 616E 7463 
       7669 2765 6D20 
       6165 736E 3020 
       2E56 4620 726F 
       000D 
004648 6361 6974 6576 00051             dw  "active-low signals, 'active' means 0V and 'inactive' means 5V. Use the ED\r"
       6C2D 776F 7320 
       6769 616E 736C 
       202C 6127 7463 
       7669 2765 6D20 
       6165 736E 3020 
       2056 6E61 2064 
       6927 616E 7463 
       7669 2765 6D20 
       6165 736E 3520 
       2E56 5520 6573 
       7420 6568 4520 
       0D44 
004692 6F63 6D6D 6E61 00052             dw  "command to see which signals are active-high and which are active-low.\r"
       2064 6F74 7320 
       6565 7720 6968 
       6863 7320 6769 
       616E 736C 6120 
       6572 6120 7463 
       7669 2D65 6968 
       6867 6120 646E 
       7720 6968 6863 
       6120 6572 6120 
       7463 7669 2D65 
       6F6C 2E77 000D 
0046DA 0000           00053             dw  0
                      00054 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
                      00055 
0046DC 0D0D           00056 bhelp_msg:  dw  "\r\r"
0046DE 2020 2020 2020 00057             dw  "                             BUFFER COMMANDS HELP\r\r"
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 143
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 4220 
       4655 4546 2052 
       4F43 4D4D 4E41 
       5344 4820 4C45 
       0D50 000D 
004712 4442 6420 7369 00058             dw  "BD displays the buffer contents in both hexidecimal and ASCII. Non-printing\r"
       6C70 7961 2073 
       6874 2065 7562 
       6666 7265 6320 
       6E6F 6574 746E 
       2073 6E69 6220 
       746F 2068 6568 
       6978 6564 6963 
       616D 206C 6E61 
       2064 5341 4943 
       2E49 4E20 6E6F 
       702D 6972 746E 
       6E69 0D67 
00475E 5341 4943 2049 00059             dw  "ASCII cuaracters are represented by a period. Pause and restart the display\r"
       7563 7261 6361 
       6574 7372 6120 
       6572 7220 7065 
       6572 6573 746E 
       6465 6220 2079 
       2061 6570 6972 
       646F 202E 6150 
       7375 2065 6E61 
       2064 6572 7473 
       7261 2074 6874 
       2065 6964 7073 
       616C 0D79 
0047AA 6977 6874 7420 00060             dw  "with the space bar. Use ESC or ^C to quit.\r\r"
       6568 7320 6170 
       6563 6220 7261 
       202E 7355 2065 
       5345 2043 726F 
       5E20 2043 6F74 
       7120 6975 2E74 
       0D0D 
0047D6 4542 6120 6C6C 00061             dw  "BE allows you to edit the buffer contents, one byte at a time. The address and\r"
       776F 2073 6F79 
       2075 6F74 6520 
       6964 2074 6874 
       2065 7562 6666 
       7265 6320 6E6F 
       6574 746E 2C73 
       6F20 656E 6220 
       7479 2065 7461 
       6120 7420 6D69 
       2E65 5420 6568 
       6120 6464 6572 
       7373 6120 646E 
       000D 
004826 6164 6174 6620 00062             dw  "data for the specified address are displayed. If you type a hex value followed\r"
       726F 7420 6568 
       7320 6570 6963 
       6966 6465 6120 
       6464 6572 7373 
       6120 6572 6420 
       7369 6C70 7961 
       6465 202E 6649 
       7920 756F 7420 
       7079 2065 2061 
       6568 2078 6176 
       756C 2065 6F66 
       6C6C 776F 6465 
       000D 
004876 7962 3C20 6572 00063             dw  "by <return>, then that value will replace the buffer data. If you just type\r"
       7574 6E72 2C3E 
       7420 6568 206E 
       6874 7461 7620 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 144
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6C61 6575 7720 
       6C69 206C 6572 
       6C70 6361 2065 
       6874 2065 7562 
       6666 7265 6420 
       7461 2E61 4920 
       2066 6F79 2075 
       756A 7473 7420 
       7079 0D65 
0048C2 723C 7465 7275 00064             dw  "<return>, then the buffer data will remain unchanged. After you type <return>,\r"
       3E6E 202C 6874 
       6E65 7420 6568 
       6220 6675 6566 
       2072 6164 6174 
       7720 6C69 206C 
       6572 616D 6E69 
       7520 636E 6168 
       676E 6465 202E 
       6641 6574 2072 
       6F79 2075 7974 
       6570 3C20 6572 
       7574 6E72 2C3E 
       000D 
004912 6874 2065 6164 00065             dw  "the data from the next address will be displayed, allowing you to modify it\r"
       6174 6620 6F72 
       206D 6874 2065 
       656E 7478 6120 
       6464 6572 7373 
       7720 6C69 206C 
       6562 6420 7369 
       6C70 7961 6465 
       202C 6C61 6F6C 
       6977 676E 7920 
       756F 7420 206F 
       6F6D 6964 7966 
       6920 0D74 
00495E 656E 7478 202E 00066             dw  "next. You can continue to view and edit sequential buffer data until you type\r"
       6F59 2075 6163 
       206E 6F63 746E 
       6E69 6575 7420 
       206F 6976 7765 
       6120 646E 6520 
       6964 2074 6573 
       7571 6E65 6974 
       6C61 6220 6675 
       6566 2072 6164 
       6174 7520 746E 
       6C69 7920 756F 
       7420 7079 0D65 
0049AC 5345 2043 726F 00067             dw  "ESC or ^C. If you continue past address 1FFF, then the address will wrap to 0.\r\r"
       5E20 2E43 4920 
       2066 6F79 2075 
       6F63 746E 6E69 
       6575 7020 7361 
       2074 6461 7264 
       7365 2073 4631 
       4646 202C 6874 
       6E65 7420 6568 
       6120 6464 6572 
       7373 7720 6C69 
       206C 7277 7061 
       7420 206F 2E30 
       0D0D 
0049FC 4642 6620 6C69 00068             dw  "BF fills the entire buffer with the specified data byte.\r\r"
       736C 7420 6568 
       6520 746E 7269 
       2065 7562 6666 
       7265 7720 7469 
       2068 6874 2065 
       7073 6365 6669 
       6569 2064 6164 
       6174 6220 7479 
       2E65 0D0D 
004A36 613C 7264 203E 00069             dw  "<adr> are hex, from 0 to 1FFF, defaulting to 0. <cnt> are hex, from 1 to 2000,\r"
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 145
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       7261 2065 6568 
       2C78 6620 6F72 
       206D 2030 6F74 
       3120 4646 2C46 
       6420 6665 7561 
       746C 6E69 2067 
       6F74 3020 202E 
       633C 746E 203E 
       7261 2065 6568 
       2C78 6620 6F72 
       206D 2031 6F74 
       3220 3030 2C30 
       000D 
004A86 6564 6166 6C75 00070             dw  "defaulting to 2000. <data> are hex, from 0 to FF, defaulting to 0.\r"
       6974 676E 7420 
       206F 3032 3030 
       202E 643C 7461 
       3E61 6120 6572 
       6820 7865 202C 
       7266 6D6F 3020 
       7420 206F 4646 
       202C 6564 6166 
       6C75 6974 676E 
       7420 206F 2E30 
       000D 
004ACA 0000           00071             dw  0
                      00072 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
                      00073 
004ACC 0D0D           00074 notes2700:  dw  "\r\r"
004ACE 2020 2020 2020 00075             dw  "                                Orphan EPROMs\r"
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 724F 6870 
       6E61 4520 5250 
       4D4F 0D73 
004AFC 2020 5420 6568 00076             dw  "   There was a lot of wrangling about pinouts among the EPROM manufacturers\r"
       6572 7720 7361 
       6120 6C20 746F 
       6F20 2066 7277 
       6E61 6C67 6E69 
       2067 6261 756F 
       2074 6970 6F6E 
       7475 2073 6D61 
       6E6F 2067 6874 
       2065 5045 4F52 
       204D 616D 756E 
       6166 7463 7275 
       7265 0D73 
004B48 6E75 6974 206C 00077             dw  "until the JEDEC standard was adopted, leading to incompatible variants of the\r"
       6874 2065 454A 
       4544 2043 7473 
       6E61 6164 6472 
       7720 7361 6120 
       6F64 7470 6465 
       202C 656C 6461 
       6E69 2067 6F74 
       6920 636E 6D6F 
       6170 6974 6C62 
       2065 6176 6972 
       6E61 7374 6F20 
       2066 6874 0D65 
004B96 3432 702D 6E69 00078             dw  "24-pin EPROMs. These EPROMs had not only incompatible pinouts, but some were\r"
       4520 5250 4D4F 
       2E73 5420 6568 
       6573 4520 5250 
       4D4F 2073 6168 
       2064 6F6E 2074 
       6E6F 796C 6920 
       636E 6D6F 6170 
       6974 6C62 2065 
       6970 6F6E 7475 
       2C73 6220 7475 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 146
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       7320 6D6F 2065 
       6577 6572 000D 
004BE4 6F70 6577 6572 00079             dw  "powered by just +5 volts, while other also required -5 volts and +12 volts. On\r"
       2064 7962 6A20 
       7375 2074 352B 
       7620 6C6F 7374 
       202C 6877 6C69 
       2065 746F 6568 
       2072 6C61 6F73 
       7220 7165 6975 
       6572 2064 352D 
       7620 6C6F 7374 
       6120 646E 2B20 
       3231 7620 6C6F 
       7374 202E 6E4F 
       000D 
004C34 6F73 656D 202C 00080             dw  "some, the write pulse was a digital pulse on either a dedicated PGM pin or on\r"
       6874 2065 7277 
       7469 2065 7570 
       736C 2065 6177 
       2073 2061 6964 
       6967 6174 206C 
       7570 736C 2065 
       6E6F 6520 7469 
       6568 2072 2061 
       6564 6964 6163 
       6574 2064 4750 
       204D 6970 206E 
       726F 6F20 0D6E 
004C82 6874 2065 6843 00081             dw  "the Chip Enable pin, while others required the high-voltage Vpp signal to be\r"
       7069 4520 616E 
       6C62 2065 6970 
       2C6E 7720 6968 
       656C 6F20 6874 
       7265 2073 6572 
       7571 7269 6465 
       7420 6568 6820 
       6769 2D68 6F76 
       746C 6761 2065 
       7056 2070 6973 
       6E67 6C61 7420 
       206F 6562 000D 
004CD0 7570 736C 6465 00082             dw  "pulsed to write each byte. The programming algorithms also varied wildly, from\r"
       7420 206F 7277 
       7469 2065 6165 
       6863 6220 7479 
       2E65 5420 6568 
       7020 6F72 7267 
       6D61 696D 676E 
       6120 676C 726F 
       7469 6D68 2073 
       6C61 6F73 7620 
       7261 6569 2064 
       6977 646C 796C 
       202C 7266 6D6F 
       000D 
004D20 2061 6973 676E 00083             dw  "a single pulse (of various lengths) per byte to many passes through the entire\r"
       656C 7020 6C75 
       6573 2820 666F 
       7620 7261 6F69 
       7375 6C20 6E65 
       7467 7368 2029 
       6570 2072 7962 
       6574 7420 206F 
       616D 796E 7020 
       7361 6573 2073 
       6874 6F72 6775 
       2068 6874 2065 
       6E65 6974 6572 
       000D 
004D70 5045 4F52 2E4D 00084             dw  "EPROM. While the JEDEC standard did solve the pinout problem (mostly), the\r"
       5720 6968 656C 
       7420 6568 4A20 
       4445 4345 7320 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 147
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6174 646E 7261 
       2064 6964 2064 
       6F73 766C 2065 
       6874 2065 6970 
       6F6E 7475 7020 
       6F72 6C62 6D65 
       2820 6F6D 7473 
       796C 2C29 7420 
       6568 000D 
004DBC 7270 676F 6172 00085             dw  "programming algorithms continued to proliferate, with each manufacturer\r"
       6D6D 6E69 2067 
       6C61 6F67 6972 
       6874 736D 6320 
       6E6F 6974 756E 
       6465 7420 206F 
       7270 6C6F 6669 
       7265 7461 2C65 
       7720 7469 2068 
       6165 6863 6D20 
       6E61 6675 6361 
       7574 6572 0D72 
004E04 6E69 6576 746E 00086             dw  "inventing it own 'Smart', 'Fast, 'Quick','Rapid', or whatever algorithm.\r"
       6E69 2067 7469 
       6F20 6E77 2720 
       6D53 7261 2774 
       202C 4627 7361 
       2C74 2720 7551 
       6369 276B 272C 
       6152 6970 2764 
       202C 726F 7720 
       6168 6574 6576 
       2072 6C61 6F67 
       6972 6874 2E6D 
       000D 
004E4E 2020 5420 6568 00087             dw  "   The ME2700 was designed in particular to program most non-JEDEC EPROMs,\r"
       4D20 3245 3037 
       2030 6177 2073 
       6564 6973 6E67 
       6465 6920 206E 
       6170 7472 6369 
       6C75 7261 7420 
       206F 7270 676F 
       6172 206D 6F6D 
       7473 6E20 6E6F 
       4A2D 4445 4345 
       4520 5250 4D4F 
       2C73 000D 
004E9A 6877 6369 2068 00088             dw  "which are seldom supported by 'universal' EPROM programmers. It can handle\r"
       7261 2065 6573 
       646C 6D6F 7320 
       7075 6F70 7472 
       6465 6220 2079 
       7527 696E 6576 
       7372 6C61 2027 
       5045 4F52 204D 
       7270 676F 6172 
       6D6D 7265 2E73 
       4920 2074 6163 
       206E 6168 646E 
       656C 000D 
004EE6 6973 676E 656C 00089             dw  "single, dual, or 3-voltage EPROMs, and a wide variety of pinouts, programming\r"
       202C 7564 6C61 
       202C 726F 3320 
       762D 6C6F 6174 
       6567 4520 5250 
       4D4F 2C73 6120 
       646E 6120 7720 
       6469 2065 6176 
       6972 7465 2079 
       666F 7020 6E69 
       756F 7374 202C 
       7270 676F 6172 
       6D6D 6E69 0D67 
004F34 6F76 746C 6761 00090             dw  "voltages, and special voltage requirements on other pins. Of course, it can\r"
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 148
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       7365 202C 6E61 
       2064 7073 6365 
       6169 206C 6F76 
       746C 6761 2065 
       6572 7571 7269 
       6D65 6E65 7374 
       6F20 206E 746F 
       6568 2072 6970 
       736E 202E 664F 
       6320 756F 7372 
       2C65 6920 2074 
       6163 0D6E 
004F80 6C61 6F73 7020 00091             dw  "also program the 24-pin JEDEC-standard EPROMs (and several EEPROMS) too. And\r"
       6F72 7267 6D61 
       7420 6568 3220 
       2D34 6970 206E 
       454A 4544 2D43 
       7473 6E61 6164 
       6472 4520 5250 
       4D4F 2073 6128 
       646E 7320 7665 
       7265 6C61 4520 
       5045 4F52 534D 
       2029 6F74 2E6F 
       4120 646E 000D 
004FCE 6977 6874 6E69 00092             dw  "within the limitations of the hardware, you can define four custom EPROM types\r"
       7420 6568 6C20 
       6D69 7469 7461 
       6F69 736E 6F20 
       2066 6874 2065 
       6168 6472 6177 
       6572 202C 6F79 
       2075 6163 206E 
       6564 6966 656E 
       6620 756F 2072 
       7563 7473 6D6F 
       4520 5250 4D4F 
       7420 7079 7365 
       000D 
00501E 6F74 7020 6F72 00093             dw  "to program EPROMs that were not considered when this firmware was written.\r"
       7267 6D61 4520 
       5250 4D4F 2073 
       6874 7461 7720 
       7265 2065 6F6E 
       2074 6F63 736E 
       6469 7265 6465 
       7720 6568 206E 
       6874 7369 6620 
       7269 776D 7261 
       2065 6177 2073 
       7277 7469 6574 
       2E6E 000D 
00506A 2020 2020 2020 00094             dw  "                                                      -Martin Eberhard\r\r"
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       4D2D 7261 6974 
       206E 6245 7265 
       6168 6472 0D0D 
0050B2 6854 7369 6420 00095             dw  "This design Copyright (c) 2016 Martin Eberhard - like anyone would steal it."
       7365 6769 206E 
       6F43 7970 6972 
       6867 2074 6328 
       2029 3032 3631 
       4D20 7261 6974 
       206E 6245 7265 
       6168 6472 2D20 
       6C20 6B69 2065 
       6E61 6F79 656E 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 149
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       7720 756F 646C 
       7320 6574 6C61 
       6920 2E74 
0050FE 0000           00096             dw  0
                      00097 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
                      00098 
                      00099 
005100 0D0D           00100 ehelp_msg:  dw  "\r\r"
005102 2020 2020 2020 00101             dw  "                             EPROM COMMANDS HELP\r\r"
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 4520 
       5250 4D4F 4320 
       4D4F 414D 444E 
       2053 4548 504C 
       0D0D 
005134 7355 2065 4C45 00102             dw  "Use EL for a list of the supported EPROM Device Types. Choose a Device Type\r"
       6620 726F 6120 
       6C20 7369 2074 
       666F 7420 6568 
       7320 7075 6F70 
       7472 6465 4520 
       5250 4D4F 4420 
       7665 6369 2065 
       7954 6570 2E73 
       4320 6F68 736F 
       2065 2061 6544 
       6976 6563 5420 
       7079 0D65 
005180 6977 6874 7420 00103             dw  "with the ET command. ED will display details about an EPROM Device Type, and\r"
       6568 4520 2054 
       6F63 6D6D 6E61 
       2E64 4520 2044 
       6977 6C6C 6420 
       7369 6C70 7961 
       6420 7465 6961 
       736C 6120 6F62 
       7475 6120 206E 
       5045 4F52 204D 
       6544 6976 6563 
       5420 7079 2C65 
       6120 646E 000D 
0051CE 6C61 6F73 6120 00104             dw  "also a list of manufacturer's part numbers for EPROMs of that Device Type.\r"
       6C20 7369 2074 
       666F 6D20 6E61 
       6675 6361 7574 
       6572 2772 2073 
       6170 7472 6E20 
       6D75 6562 7372 
       6620 726F 4520 
       5250 4D4F 2073 
       666F 7420 6168 
       2074 6544 6976 
       6563 5420 7079 
       2E65 000D 
00521A 6854 7365 2065 00105             dw  "These lists of part numbers are not complete (particulary for the common EPROMs\r"
       696C 7473 2073 
       666F 7020 7261 
       2074 756E 626D 
       7265 2073 7261 
       2065 6F6E 2074 
       6F63 706D 656C 
       6574 2820 6170 
       7472 6369 6C75 
       7261 2079 6F66 
       2072 6874 2065 
       6F63 6D6D 6E6F 
       4520 5250 4D4F 
       0D73 
00526A 7573 6863 6120 00106             dw  "such as the 2708 and the 2716). Look at your EPROM's datasheet and find the\r"
       2073 6874 2065 
       3732 3830 6120 
       646E 7420 6568 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 150
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       3220 3137 2936 
       202E 6F4C 6B6F 
       6120 2074 6F79 
       7275 4520 5250 
       4D4F 7327 6420 
       7461 7361 6568 
       7465 6120 646E 
       6620 6E69 2064 
       6874 0D65 
0052B6 6F63 7272 6365 00107             dw  "correct Device Type, if it is not listed. Use the Custom EPROM Editor to create\r"
       2074 6544 6976 
       6563 5420 7079 
       2C65 6920 2066 
       7469 6920 2073 
       6F6E 2074 696C 
       7473 6465 202E 
       7355 2065 6874 
       2065 7543 7473 
       6D6F 4520 5250 
       4D4F 4520 6964 
       6F74 2072 6F74 
       6320 6572 7461 
       0D65 
005306 2061 656E 2077 00108             dw  "a new EPROM Type if none match your EPROM.\r\r"
       5045 4F52 204D 
       7954 6570 6920 
       2066 6F6E 656E 
       6D20 7461 6863 
       7920 756F 2072 
       5045 4F52 2E4D 
       0D0D 
005332 6F46 2072 6874 00109             dw  "For these commands, <adr> is the (4-digit hex) beginning address and <cnt> is\r"
       7365 2065 6F63 
       6D6D 6E61 7364 
       202C 613C 7264 
       203E 7369 7420 
       6568 2820 2D34 
       6964 6967 2074 
       6568 2978 6220 
       6765 6E69 696E 
       676E 6120 6464 
       6572 7373 6120 
       646E 3C20 6E63 
       3E74 6920 0D73 
005380 6874 2065 3428 00110             dw  "the (4-digit hex) byte count for the for the operation. <adr> defaults to 0000.\r"
       642D 6769 7469 
       6820 7865 2029 
       7962 6574 6320 
       756F 746E 6620 
       726F 7420 6568 
       6620 726F 7420 
       6568 6F20 6570 
       6172 6974 6E6F 
       202E 613C 7264 
       203E 6564 6166 
       6C75 7374 7420 
       206F 3030 3030 
       0D2E 
0053D0 633C 746E 203E 00111             dw  "<cnt> defaults to the entire EPROM size, which depends on the selected type.\r\r"
       6564 6166 6C75 
       7374 7420 206F 
       6874 2065 6E65 
       6974 6572 4520 
       5250 4D4F 7320 
       7A69 2C65 7720 
       6968 6863 6420 
       7065 6E65 7364 
       6F20 206E 6874 
       2065 6573 656C 
       7463 6465 7420 
       7079 2E65 0D0D 
00541E 6854 2065 7542 00112             dw  "The Buffer Address Offset (set with the BAO command) is added to the high byte\r"
       6666 7265 4120 
       6464 6572 7373 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 151
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       4F20 6666 6573 
       2074 7328 7465 
       7720 7469 2068 
       6874 2065 4142 
       204F 6F63 6D6D 
       6E61 2964 6920 
       2073 6461 6564 
       2064 6F74 7420 
       6568 6820 6769 
       2068 7962 6574 
       000D 
00546E 666F 7420 6568 00113             dw  "of the EPROM's address to compute the buffer address for read, compare, and\r"
       4520 5250 4D4F 
       7327 6120 6464 
       6572 7373 7420 
       206F 6F63 706D 
       7475 2065 6874 
       2065 7562 6666 
       7265 6120 6464 
       6572 7373 6620 
       726F 7220 6165 
       2C64 6320 6D6F 
       6170 6572 202C 
       6E61 0D64 
0054BA 7270 676F 6172 00114             dw  "program operations. This allows you to choose where in the buffer to put EPROM\r"
       206D 706F 7265 
       7461 6F69 736E 
       202E 6854 7369 
       6120 6C6C 776F 
       2073 6F79 2075 
       6F74 6320 6F68 
       736F 2065 6877 
       7265 2065 6E69 
       7420 6568 6220 
       6675 6566 2072 
       6F74 7020 7475 
       4520 5250 4D4F 
       000D 
00550A 6572 6461 6420 00115             dw  "read data, and from where in the buffer to get EPROM programming data.\r\r"
       7461 2C61 6120 
       646E 6620 6F72 
       206D 6877 7265 
       2065 6E69 7420 
       6568 6220 6675 
       6566 2072 6F74 
       6720 7465 4520 
       5250 4D4F 7020 
       6F72 7267 6D61 
       696D 676E 6420 
       7461 2E61 0D0D 
005552 6854 2065 4944 00116             dw  "The DI command is useful when your EPROM is used in a system with inverted\r"
       6320 6D6F 616D 
       646E 6920 2073 
       7375 6665 6C75 
       7720 6568 206E 
       6F79 7275 4520 
       5250 4D4F 6920 
       2073 7375 6465 
       6920 206E 2061 
       7973 7473 6D65 
       7720 7469 2068 
       6E69 6576 7472 
       6465 000D 
00559E 6164 6174 202E 00117             dw  "data. When DI is enabled, data are inverted when written to the EPROM and when\r"
       6857 6E65 4420 
       2049 7369 6520 
       616E 6C62 6465 
       202C 6164 6174 
       6120 6572 6920 
       766E 7265 6574 
       2064 6877 6E65 
       7720 6972 7474 
       6E65 7420 206F 
       6874 2065 5045 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 152
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       4F52 204D 6E61 
       2064 6877 6E65 
       000D 
0055EE 6572 6461 6220 00118             dw  "read back from the EPROM.\r"
       6361 206B 7266 
       6D6F 7420 6568 
       4520 5250 4D4F 
       0D2E 
005608 0000           00119             dw  0
                      00120 
                      00121 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
00560A 0D0D           00122 fhelp_msg:  dw  "\r\r"
00560C 2020 2020 2020 00123             dw  "                         FILE TRANSFER COMMANDS HELP\r"
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       4620 4C49 2045 
       5254 4E41 4653 
       5245 4320 4D4F 
       414D 444E 2053 
       4548 504C 000D 
005642 7254 6E61 6673 00124             dw  "Transfer files to and from the buffer in Intel Hex or Motorola S-record format.\r"
       7265 6620 6C69 
       7365 7420 206F 
       6E61 2064 7266 
       6D6F 7420 6568 
       6220 6675 6566 
       2072 6E69 4920 
       746E 6C65 4820 
       7865 6F20 2072 
       6F4D 6F74 6F72 
       616C 5320 722D 
       6365 726F 2064 
       6F66 6D72 7461 
       0D2E 
005692 4955 6120 646E 00125             dw  "UI and US upload buffer data in Intel Hex and Motorola S-record formats. If no\r"
       5520 2053 7075 
       6F6C 6461 6220 
       6675 6566 2072 
       6164 6174 6920 
       206E 6E49 6574 
       206C 6548 2078 
       6E61 2064 6F4D 
       6F74 6F72 616C 
       5320 722D 6365 
       726F 2064 6F66 
       6D72 7461 2E73 
       4920 2066 6F6E 
       000D 
0056E2 633C 746E 203E 00126             dw  "<cnt> value is provided, then the byte count will be the size of the currently\r"
       6176 756C 2065 
       7369 7020 6F72 
       6976 6564 2C64 
       7420 6568 206E 
       6874 2065 7962 
       6574 6320 756F 
       746E 7720 6C69 
       206C 6562 7420 
       6568 7320 7A69 
       2065 666F 7420 
       6568 6320 7275 
       6572 746E 796C 
       000D 
005732 6573 656C 7463 00127             dw  "selected EPROM Type. No special command is needed to download to the buffer:\r"
       6465 4520 5250 
       4D4F 5420 7079 
       2E65 4E20 206F 
       7073 6365 6169 
       206C 6F63 6D6D 
       6E61 2064 7369 
       6E20 6565 6564 
       2064 6F74 6420 
       776F 6C6E 616F 
       2064 6F74 7420 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 153
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6568 6220 6675 
       6566 3A72 000D 
005780 6874 2065 6568 00128             dw  "the hex records themselves are recognized. Downloaded records will generate an\r"
       2078 6572 6F63 
       6472 2073 6874 
       6D65 6573 766C 
       7365 6120 6572 
       7220 6365 676F 
       696E 657A 2E64 
       4420 776F 6C6E 
       616F 6564 2064 
       6572 6F63 6472 
       2073 6977 6C6C 
       6720 6E65 7265 
       7461 2065 6E61 
       000D 
0057D0 7265 6F72 2072 00129             dw  "error for the following reasons:\r"
       6F66 2072 6874 
       2065 6F66 6C6C 
       776F 6E69 2067 
       6572 7361 6E6F 
       3A73 000D 
0057F2 4520 5252 524F 00130             dw  " ERROR CODE        ERROR\r"
       4320 444F 2045 
       2020 2020 2020 
       4520 5252 524F 
       000D 
00580C 2020 3F20 4320 00131             dw  "   ? Cnt      S5 record-count mismatch (Motorola S-records only)\r"
       746E 2020 2020 
       2020 3553 7220 
       6365 726F 2D64 
       6F63 6E75 2074 
       696D 6D73 7461 
       6863 2820 6F4D 
       6F74 6F72 616C 
       5320 722D 6365 
       726F 7364 6F20 
       6C6E 2979 000D 
00584E 2020 3F20 4320 00132             dw  "   ? Csm      Checksum error\r"
       6D73 2020 2020 
       2020 6843 6365 
       736B 6D75 6520 
       7272 726F 000D 
00586C 2020 3F20 4820 00133             dw  "   ? Hex      Illegal hexadecimal character\r"
       7865 2020 2020 
       2020 6C49 656C 
       6167 206C 6568 
       6178 6564 6963 
       616D 206C 6863 
       7261 6361 6574 
       0D72 
005898 2020 3F20 5220 00134             dw  "   ? Rec      Unsupported record type\r\r"
       6365 2020 2020 
       2020 6E55 7573 
       7070 726F 6574 
       2064 6572 6F63 
       6472 7420 7079 
       0D65 000D 
0058C0 6854 2065 6946 00135             dw  "The File Address Offset (set with the FAO command) affects the upper byte of\r"
       656C 4120 6464 
       6572 7373 4F20 
       6666 6573 2074 
       7328 7465 7720 
       7469 2068 6874 
       2065 4146 204F 
       6F63 6D6D 6E61 
       2964 6120 6666 
       6365 7374 7420 
       6568 7520 7070 
       7265 6220 7479 
       2065 666F 000D 
00590E 6165 6863 7220 00136             dw  "each record's 2-byte address. For downloads, the File Address Offset is\r"
       6365 726F 2764 
       2073 2D32 7962 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 154
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6574 6120 6464 
       6572 7373 202E 
       6F46 2072 6F64 
       6E77 6F6C 6461 
       2C73 7420 6568 
       4620 6C69 2065 
       6441 7264 7365 
       2073 664F 7366 
       7465 6920 0D73 
005956 7573 7462 6172 00137             dw  "subtracted from the upper address byte of each received record. For uploads,\r"
       7463 6465 6620 
       6F72 206D 6874 
       2065 7075 6570 
       2072 6461 7264 
       7365 2073 7962 
       6574 6F20 2066 
       6165 6863 7220 
       6365 6965 6576 
       2064 6572 6F63 
       6472 202E 6F46 
       2072 7075 6F6C 
       6461 2C73 000D 
0059A4 6874 2065 6946 00138             dw  "the File Address Offset is added to the upper address byte in each record.\r\r"
       656C 4120 6464 
       6572 7373 4F20 
       6666 6573 2074 
       7369 6120 6464 
       6465 7420 206F 
       6874 2065 7075 
       6570 2072 6461 
       7264 7365 2073 
       7962 6574 6920 
       206E 6165 6863 
       7220 6365 726F 
       2E64 0D0D 
0059F0 4146 204F 6977 00139             dw  "FAO with no parameter resets the File Address Offset to its default. For\r"
       6874 6E20 206F 
       6170 6172 656D 
       6574 2072 6572 
       6573 7374 7420 
       6568 4620 6C69 
       2065 6441 7264 
       7365 2073 664F 
       7366 7465 7420 
       206F 7469 2073 
       6564 6166 6C75 
       2E74 4620 726F 
       000D 
005A3A 7075 6F6C 6461 00140             dw  "uploads, the default is 00. For downloads, the default is the high address byte\r"
       2C73 7420 6568 
       6420 6665 7561 
       746C 6920 2073 
       3030 202E 6F46 
       2072 6F64 6E77 
       6F6C 6461 2C73 
       7420 6568 6420 
       6665 7561 746C 
       6920 2073 6874 
       2065 6968 6867 
       6120 6464 6572 
       7373 6220 7479 
       0D65 
005A8A 7266 6D6F 7420 00141             dw  "from the first received record. Received data will not be written to the buffer\r"
       6568 6620 7269 
       7473 7220 6365 
       6965 6576 2064 
       6572 6F63 6472 
       202E 6552 6563 
       7669 6465 6420 
       7461 2061 6977 
       6C6C 6E20 746F 
       6220 2065 7277 
       7469 6574 206E 
       6F74 7420 6568 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 155
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6220 6675 6566 
       0D72 
005ADA 6669 7420 6568 00142             dw  "if the resulting address high byte is greater than 1F.\r"
       7220 7365 6C75 
       6974 676E 6120 
       6464 6572 7373 
       6820 6769 2068 
       7962 6574 6920 
       2073 7267 6165 
       6574 2072 6874 
       6E61 3120 2E46 
       000D 
005B12 0000           00143             dw  0
                      00144 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
                      00145 
005B14 0D0D           00146 lhelp_msg:  dw  "\r\r"
005B16 2020 2020 2020 00147             dw  "                             THE FIRMWARE LOADER\r\r"
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 5420 
       4548 4620 5249 
       574D 5241 2045 
       4F4C 4441 5245 
       0D0D 
005B48 6854 7369 6620 00148             dw  "This firware can be loaded via the ME2700 serial port. To invoke the Loader,\r"
       7269 6177 6572 
       6320 6E61 6220 
       2065 6F6C 6461 
       6465 7620 6169 
       7420 6568 4D20 
       3245 3037 2030 
       6573 6972 6C61 
       7020 726F 2E74 
       5420 206F 6E69 
       6F76 656B 7420 
       6568 4C20 616F 
       6564 2C72 000D 
005B96 7974 6570 6320 00149             dw  "type capital 'L' a few times immediately after power on, or immediately after\r"
       7061 7469 6C61 
       2720 274C 6120 
       6620 7765 7420 
       6D69 7365 6920 
       6D6D 6465 6169 
       6574 796C 6120 
       7466 7265 7020 
       776F 7265 6F20 
       2C6E 6F20 2072 
       6D69 656D 6964 
       7461 6C65 2079 
       6661 6574 0D72 
005BE4 7369 7573 6E69 00150             dw  "issuing a RESET command. You should see the ME Loader prompt instead of the\r"
       2067 2061 4552 
       4553 2054 6F63 
       6D6D 6E61 2E64 
       5920 756F 7320 
       6F68 6C75 2064 
       6573 2065 6874 
       2065 454D 4C20 
       616F 6564 2072 
       7270 6D6F 7470 
       6920 736E 6574 
       6461 6F20 2066 
       6874 0D65 
005C30 454D 3732 3030 00151             dw  "ME2700 banner.\r\r"
       6220 6E61 656E 
       2E72 0D0D 
005C40 4D49 4F50 5452 00152             dw  "IMPORTANT: The Loader requires your terminal program to accept XON/XOFF\r"
       4E41 3A54 5420 
       6568 4C20 616F 
       6564 2072 6572 
       7571 7269 7365 
       7920 756F 2072 
       6574 6D72 6E69 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 156
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6C61 7020 6F72 
       7267 6D61 7420 
       206F 6361 6563 
       7470 5820 4E4F 
       582F 464F 0D46 
005C88 6168 646E 6873 00153             dw  "handshaking. The loader expects an Intel hex file exactly as produced by the\r"
       6B61 6E69 2E67 
       5420 6568 6C20 
       616F 6564 2072 
       7865 6570 7463 
       2073 6E61 4920 
       746E 6C65 6820 
       7865 6620 6C69 
       2065 7865 6361 
       6C74 2079 7361 
       7020 6F72 7564 
       6563 2064 7962 
       7420 6568 000D 
005CD6 694D 7263 636F 00154             dw  "Microchip MPASM assembler. (The firmware must be written to be compatible with\r"
       6968 2070 504D 
       5341 204D 7361 
       6573 626D 656C 
       2E72 2820 6854 
       2065 6966 6D72 
       6177 6572 6D20 
       7375 2074 6562 
       7720 6972 7474 
       6E65 7420 206F 
       6562 6320 6D6F 
       6170 6974 6C62 
       2065 6977 6874 
       000D 
005D26 6874 2065 454D 00155             dw  "the ME Loader Kernel version 1.x, not documented here.)  Once you see the\r"
       4C20 616F 6564 
       2072 654B 6E72 
       6C65 7620 7265 
       6973 6E6F 3120 
       782E 202C 6F6E 
       2074 6F64 7563 
       656D 746E 6465 
       6820 7265 2E65 
       2029 4F20 636E 
       2065 6F79 2075 
       6573 2065 6874 
       0D65 
005D70 454D 4C20 616F 00156             dw  "ME Loader prompt, send the Intel hex firmware file to the ME2700. It will take\r"
       6564 2072 7270 
       6D6F 7470 202C 
       6573 646E 7420 
       6568 4920 746E 
       6C65 6820 7865 
       6620 7269 776D 
       7261 2065 6966 
       656C 7420 206F 
       6874 2065 454D 
       3732 3030 202E 
       7449 7720 6C69 
       206C 6174 656B 
       000D 
005DC0 2061 6877 6C69 00157             dw  "a while to load. When it is done, the error count must be 0000 - otherwise, the\r"
       2065 6F74 6C20 
       616F 2E64 5720 
       6568 206E 7469 
       6920 2073 6F64 
       656E 202C 6874 
       2065 7265 6F72 
       2072 6F63 6E75 
       2074 756D 7473 
       6220 2065 3030 
       3030 2D20 6F20 
       6874 7265 6977 
       6573 202C 6874 
       0D65 
005E10 6966 6D72 6177 00158             dw  "firmware is probably corrupted.\r\r"
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 157
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6572 6920 2073 
       7270 626F 6261 
       796C 6320 726F 
       7572 7470 6465 
       0D2E 000D 
005E32 6F4E 6574 7420 00159             dw  "Note that a bad firmware load will corrupt the ME2700 firmware, but it will not\r"
       6168 2074 2061 
       6162 2064 6966 
       6D72 6177 6572 
       6C20 616F 2064 
       6977 6C6C 6320 
       726F 7572 7470 
       7420 6568 4D20 
       3245 3037 2030 
       6966 6D72 6177 
       6572 202C 7562 
       2074 7469 7720 
       6C69 206C 6F6E 
       0D74 
005E82 6F63 7272 7075 00160             dw  "corrupt the Loader. Even with corrupted firmware, you can type a few 'L's\r"
       2074 6874 2065 
       6F4C 6461 7265 
       202E 7645 6E65 
       7720 7469 2068 
       6F63 7272 7075 
       6574 2064 6966 
       6D72 6177 6572 
       202C 6F79 2075 
       6163 206E 7974 
       6570 6120 6620 
       7765 2720 274C 
       0D73 
005ECC 6D69 656D 6964 00161             dw  "immediately after powering on, to invoke the Loader and try again.\r\r"
       7461 6C65 2079 
       6661 6574 2072 
       6F70 6577 6972 
       676E 6F20 2C6E 
       7420 206F 6E69 
       6F76 656B 7420 
       6568 4C20 616F 
       6564 2072 6E61 
       2064 7274 2079 
       6761 6961 2E6E 
       0D0D 
005F10 6F59 2075 6163 00162             dw  "You can exit the Loader and run the loaded firmware either by power-cycling the\r"
       206E 7865 7469 
       7420 6568 4C20 
       616F 6564 2072 
       6E61 2064 7572 
       206E 6874 2065 
       6F6C 6461 6465 
       6620 7269 776D 
       7261 2065 6965 
       6874 7265 6220 
       2079 6F70 6577 
       2D72 7963 6C63 
       6E69 2067 6874 
       0D65 
005F60 454D 3732 3030 00163             dw  "ME2700 or by typing the ESC key three times in succession.\r" 
       6F20 2072 7962 
       7420 7079 6E69 
       2067 6874 2065 
       5345 2043 656B 
       2079 6874 6572 
       2065 6974 656D 
       2073 6E69 7320 
       6375 6563 7373 
       6F69 2E6E 000D 
005F9C 0000           00164             dw  0
                      00165 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
                      00166 
005F9E 0D0D           00167 eemenu_msg: dw  "\r\r"
005FA0 5543 5453 4D4F 00168             dw  "CUSTOM EPROM EDITOR GENERAL COMMANDS\r\r"
       4520 5250 4D4F 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 158
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       4520 4944 4F54 
       2052 4547 454E 
       4152 204C 4F43 
       4D4D 4E41 5344 
       0D0D 
005FC6 2020 203F 2020 00169             dw  "  ?           Reprint this menu\r"
       2020 2020 2020 
       2020 6552 7270 
       6E69 2074 6874 
       7369 6D20 6E65 
       0D75 
005FE6 2020 413F 2020 00170             dw  "  ?A          Pin Assignment command menu\r"
       2020 2020 2020 
       2020 6950 206E 
       7341 6973 6E67 
       656D 746E 6320 
       6D6F 616D 646E 
       6D20 6E65 0D75 
006010 2020 503F 2020 00171             dw  "  ?P          Programming Parameter command menu\r"
       2020 2020 2020 
       2020 7250 676F 
       6172 6D6D 6E69 
       2067 6150 6172 
       656D 6574 2072 
       6F63 6D6D 6E61 
       2064 656D 756E 
       000D 
006042 2020 4F43 5950 00172             dw  "  COPY <type> Copy EPROM Device Type\r"
       3C20 7974 6570 
       203E 6F43 7970 
       4520 5250 4D4F 
       4420 7665 6369 
       2065 7954 6570 
       000D 
006068 2020 4544 454C 00173             dw  "  DELETE      Delete EPROM Device Type\r"
       4554 2020 2020 
       2020 6544 656C 
       6574 4520 5250 
       4D4F 4420 7665 
       6369 2065 7954 
       6570 000D 
006090 2020 4445 2020 00174             dw  "  ED          Display EPROM Details\r"
       2020 2020 2020 
       2020 6944 7073 
       616C 2079 5045 
       4F52 204D 6544 
       6174 6C69 0D73 
0060B4 2020 4E45 3C20 00175             dw  "  EN <name>   Name EPROM Device Type\r"
       616E 656D 203E 
       2020 614E 656D 
       4520 5250 4D4F 
       4420 7665 6369 
       2065 7954 6570 
       000D 
0060DA 2020 5054 4F52 00176             dw  "  TPROG       Test EPROM programming (scope loop) until ^C or ESC\r"
       2047 2020 2020 
       2020 6554 7473 
       4520 5250 4D4F 
       7020 6F72 7267 
       6D61 696D 676E 
       2820 6373 706F 
       2065 6F6C 706F 
       2029 6E75 6974 
       206C 435E 6F20 
       2072 5345 0D43 
00611C 2020 5254 4145 00177             dw  "  TREAD       Test EPROM reading (scope loop) until ^C or ESC\r"
       2044 2020 2020 
       2020 6554 7473 
       4520 5250 4D4F 
       7220 6165 6964 
       676E 2820 6373 
       706F 2065 6F6C 
       706F 2029 6E75 
       6974 206C 435E 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 159
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6F20 2072 5345 
       0D43 
00615A 2020 2051 2020 00178             dw  "  Q           Quit to main menu\r"
       2020 2020 2020 
       2020 7551 7469 
       7420 206F 616D 
       6E69 6D20 6E65 
       0D75 
00617A 0000           00179             dw  0
                      00180 
                      00181 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
00617C 0D0D           00182 eamenu_msg: dw  "\r\r"
00617E 5543 5453 4D4F 00183             dw  "CUSTOM EPROM EDITOR PIN ASSIGNMENT COMMANDS\r\r"
       4520 5250 4D4F 
       4520 4944 4F54 
       2052 4950 204E 
       5341 4953 4E47 
       454D 544E 4320 
       4D4F 414D 444E 
       0D53 000D 
0061AC 2020 3941 7B20 00184             dw  "  A9 {0,18-22}     A9 Pin\r"
       2C30 3831 322D 
       7D32 2020 2020 
       4120 2039 6950 
       0D6E 
0061C6 2020 3141 2030 00185             dw  "  A10 {0,18-22}    A10 Pin\r"
       307B 312C 2D38 
       3232 207D 2020 
       4120 3031 5020 
       6E69 000D 
0061E2 2020 3141 2031 00186             dw  "  A11 {0,18-22}    All Pin (overrides Stuck-High signal)\r"
       307B 312C 2D38 
       3232 207D 2020 
       4120 6C6C 5020 
       6E69 2820 766F 
       7265 6972 6564 
       2073 7453 6375 
       2D6B 6948 6867 
       7320 6769 616E 
       296C 000D 
00621C 2020 3141 2032 00187             dw  "  A12 {0,18-22}    A12 Pin (overrides -AS)\r"
       307B 312C 2D38 
       3232 207D 2020 
       4120 3231 5020 
       6E69 2820 766F 
       7265 6972 6564 
       2073 412D 2953 
       000D 
006248 2020 5341 204E 00188             dw  "  ASN {0,18-22}    -AS Pin (overrides A12)\r"  
       307B 312C 2D38 
       3232 207D 2020 
       2D20 5341 5020 
       6E69 2820 766F 
       7265 6972 6564 
       2073 3141 2932 
       000D 
006274 2020 5343 7B20 00189             dw  "  CS {0,18-22}     CS Pin\r" 
       2C30 3831 322D 
       7D32 2020 2020 
       4320 2053 6950 
       0D6E 
00628E 2020 5343 2050 00190             dw  "  CSP {0/1}        CS Polarity {-/+}\r"
       307B 312F 207D 
       2020 2020 2020 
       4320 2053 6F50 
       616C 6972 7974 
       7B20 2F2D 7D2B 
       000D 
0062B4 2020 4948 7B20 00191             dw  "  HI {0,18-22}     Stuck-High pin (overrides A11)\r" 
       2C30 3831 322D 
       7D32 2020 2020 
       5320 7574 6B63 
       482D 6769 2068 
       6970 206E 6F28 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 160
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       6576 7272 6469 
       7365 4120 3131 
       0D29 
0062E6 2020 454F 204E 00192             dw  "  OEN {0,18-22}    -OE Pin\r"
       307B 312C 2D38 
       3232 207D 2020 
       2D20 454F 5020 
       6E69 000D 
006302 2020 4750 204D 00193             dw  "  PGM {0,18-22}    PGM Pin (WE pin for EEPROMs)\r"
       307B 312C 2D38 
       3232 207D 2020 
       5020 4D47 5020 
       6E69 2820 4557 
       7020 6E69 6620 
       726F 4520 5045 
       4F52 734D 0D29 
006332 2020 4750 2050 00194             dw  "  PGP {0/1}        PGM Polarity {-/+}\r"
       307B 312F 207D 
       2020 2020 2020 
       5020 4D47 5020 
       6C6F 7261 7469 
       2079 2D7B 2B2F 
       0D7D 
006358 2020 5050 2050 00195             dw  "  PPP {0,18,20,21} Vpp Pin\r"
       307B 312C 2C38 
       3032 322C 7D31 
       5620 7070 5020 
       6E69 000D 
006374 2020 4256 2042 00196             dw  "  VBB {0/1}        Assign -5V Vbb to pin 21 {no/yes}\r"
       307B 312F 207D 
       2020 2020 2020 
       4120 7373 6769 
       206E 352D 2056 
       6256 2062 6F74 
       7020 6E69 3220 
       2031 6E7B 2F6F 
       6579 7D73 000D 
0063AA 2020 4456 2044 00197             dw  "  VDD {0/1}        Assign +12V Vdd to pin 19 {no/yes}\r\r"
       307B 312F 207D 
       2020 2020 2020 
       4120 7373 6769 
       206E 312B 5632 
       5620 6464 7420 
       206F 6970 206E 
       3931 7B20 6F6E 
       792F 7365 0D7D 
       000D 
0063E2 6649 6D20 726F 00198             dw  "If more than one signal is assigned to the same pin, then the last assignment\r"
       2065 6874 6E61 
       6F20 656E 7320 
       6769 616E 206C 
       7369 6120 7373 
       6769 656E 2064 
       6F74 7420 6568 
       7320 6D61 2065 
       6970 2C6E 7420 
       6568 206E 6874 
       2065 616C 7473 
       6120 7373 6769 
       6D6E 6E65 0D74 
006430 6977 6C6C 7320 00199             dw  "will supersede prior assignments. Exceptions: Vpp may share the same pin as -OE\r"
       7075 7265 6573 
       6564 7020 6972 
       726F 6120 7373 
       6769 6D6E 6E65 
       7374 202E 7845 
       6563 7470 6F69 
       736E 203A 7056 
       2070 616D 2079 
       6873 7261 2065 
       6874 2065 6173 
       656D 7020 6E69 
       6120 2073 4F2D 
       0D45 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 161
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

006480 726F 4320 2E53 00200             dw  "or CS. PGM may share the same pin as -OE or CS. Unassigned pins are stuck-low.\r"
       5020 4D47 6D20 
       7961 7320 6168 
       6572 7420 6568 
       7320 6D61 2065 
       6970 206E 7361 
       2D20 454F 6F20 
       2072 5343 202E 
       6E55 7361 6973 
       6E67 6465 7020 
       6E69 2073 7261 
       2065 7473 6375 
       2D6B 6F6C 2E77 
       000D 
0064D0 0000           00201             dw  0
                      00202 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
                      00203 
0064D2 0D0D           00204 epmenu_msg: dw  "\r\r"
0064D4 5543 5453 4D4F 00205             dw  "CUSTOM EPROM EDITOR PROGRAMMING PARAMETER COMMANDS\r\r"
       4520 5250 4D4F 
       4520 4944 4F54 
       2052 5250 474F 
       4152 4D4D 4E49 
       2047 4150 4152 
       454D 4554 2052 
       4F43 4D4D 4E41 
       5344 0D0D 
006508 2020 4342 204B 00206             dw  "  BCK {0/1} Blank check {disabled/enabled} (disable for e.g. EEPROMs)\r"
       307B 312F 207D 
       6C42 6E61 206B 
       6863 6365 206B 
       647B 7369 6261 
       656C 2F64 6E65 
       6261 656C 7D64 
       2820 6964 6173 
       6C62 2065 6F66 
       2072 2E65 2E67 
       4520 5045 4F52 
       734D 0D29 
00654E 2020 4646 2031 00207             dw  "  FF1 {0/1} Fast pass 1 data=FFh {no/yes} (for EEPROM erase)\r"
       307B 312F 207D 
       6146 7473 7020 
       7361 2073 2031 
       6164 6174 463D 
       6846 7B20 6F6E 
       792F 7365 207D 
       6628 726F 4520 
       5045 4F52 204D 
       7265 7361 2965 
       000D 
00658C 2020 4E46 2031 00208             dw  "  FN1 <n>   'n' value for Fast Pass 1 (0<n<7)\r" 
       6E3C 203E 2020 
       6E27 2027 6176 
       756C 2065 6F66 
       2072 6146 7473 
       5020 7361 2073 
       2031 3028 6E3C 
       373C 0D29 
0065BA 2020 4E46 2032 00209             dw  "  FN2 <n>   'n' value for Fast Pass 2 (0<n<7)\r"
       6E3C 203E 2020 
       6E27 2027 6176 
       756C 2065 6F66 
       2072 6146 7473 
       5020 7361 2073 
       2032 3028 6E3C 
       373C 0D29 
0065E8 2020 5046 2031 00210             dw  "  FP1 {0-5} Define Fast Pass 1-{  0: P+n        1: P, then one n*PPW pulse\r"
       307B 352D 207D 
       6544 6966 656E 
       4620 7361 2074 
       6150 7373 3120 
       7B2D 2020 3A30 
       5020 6E2B 2020 
       2020 2020 2020 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 162
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       3A31 5020 202C 
       6874 6E65 6F20 
       656E 6E20 502A 
       5750 7020 6C75 
       6573 000D 
006634 2020 5046 2032 00211             dw  "  FP2 {0-5} Define Fast Pass 2-{  2: P+nP       3: P, then one n*P*PPW pulse\r"
       307B 352D 207D 
       6544 6966 656E 
       4620 7361 2074 
       6150 7373 3220 
       7B2D 2020 3A32 
       5020 6E2B 2050 
       2020 2020 2020 
       3A33 5020 202C 
       6874 6E65 6F20 
       656E 6E20 502A 
       502A 5750 7020 
       6C75 6573 000D 
006682 2020 2020 2020 00212             dw  "                               {  4: n pulses   5: one n*PPW pulse\r"
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       2020 2020 2020 
       7B20 2020 3A34 
       6E20 7020 6C75 
       6573 2073 2020 
       3A35 6F20 656E 
       6E20 502A 5750 
       7020 6C75 6573 
       000D 
0066C6 2020 454F 2056 00213             dw  "  OEV {0/1} Set -OE to +12V during programming {no/yes}\r"
       307B 312F 207D 
       6553 2074 4F2D 
       2045 6F74 2B20 
       3231 2056 7564 
       6972 676E 7020 
       6F72 7267 6D61 
       696D 676E 7B20 
       6F6E 792F 7365 
       0D7D 
0066FE 2020 4D50 2058 00214             dw  "  PMX <max> Fast algorithm maximum P, or SPA pass count (0 to 255)\r"
       6D3C 7861 203E 
       6146 7473 6120 
       676C 726F 7469 
       6D68 6D20 7861 
       6D69 6D75 5020 
       202C 726F 5320 
       4150 7020 7361 
       2073 6F63 6E75 
       2074 3028 7420 
       206F 3532 2935 
       000D 
006742 2020 4F50 204C 00215             dw  "  POL {0/1} EEPROM-style write-completion polling {no/yes}\r" 
       307B 312F 207D 
       4545 5250 4D4F 
       732D 7974 656C 
       7720 6972 6574 
       632D 6D6F 6C70 
       7465 6F69 206E 
       6F70 6C6C 6E69 
       2067 6E7B 2F6F 
       6579 7D73 000D 
00677E 2020 5050 2053 00216             dw  "  PPS <t>   Pulse separation (<t> = 0 to 127, 0 means minimum)\r"  
       743C 203E 2020 
       7550 736C 2065 
       6573 6170 6172 
       6974 6E6F 2820 
       743C 203E 203D 
       2030 6F74 3120 
       3732 202C 2030 
       656D 6E61 2073 
       696D 696E 756D 
       296D 000D 
0067BE 2020 5050 2057 00217             dw  "  PPW <t>   Pulse width (<t> = 0 to 127, 0 means ~350 nS)\r"
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 163
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       743C 203E 2020 
       7550 736C 2065 
       6977 7464 2068 
       3C28 3E74 3D20 
       3020 7420 206F 
       3231 2C37 3020 
       6D20 6165 736E 
       7E20 3533 2030 
       536E 0D29 
0067F8 2020 5450 2055 00218             dw  "  PTU {0/1} PPS and PPW time units: {10 uS/1 mS}\r"
       307B 312F 207D 
       5050 2053 6E61 
       2064 5050 2057 
       6974 656D 7520 
       696E 7374 203A 
       317B 2030 5375 
       312F 6D20 7D53 
       000D 
00682A 2020 5550 204C 00219             dw  "  PUL {0-2} Program Pulse signal: {0=Vpp/0V, 1=Vpp/5V, 2=PGM}\r"
       307B 322D 207D 
       7250 676F 6172 
       206D 7550 736C 
       2065 6973 6E67 
       6C61 203A 307B 
       563D 7070 302F 
       2C56 3120 563D 
       7070 352F 2C56 
       3220 503D 4D47 
       0D7D 
006868 2020 5053 2041 00220             dw  "  SPA       Use Simple Program Algorithm (not a Fast algorithm)\r"
       2020 2020 2020 
       7355 2065 6953 
       706D 656C 5020 
       6F72 7267 6D61 
       4120 676C 726F 
       7469 6D68 2820 
       6F6E 2074 2061 
       6146 7473 6120 
       676C 726F 7469 
       6D68 0D29 
0068A8 2020 4356 2050 00221             dw  "  VCP {0-3} Vcc during prog: {0=0V, 1=5V, 2=6.2V, 3=12V}\r"
       307B 332D 207D 
       6356 2063 7564 
       6972 676E 7020 
       6F72 3A67 7B20 
       3D30 5630 202C 
       3D31 5635 202C 
       3D32 2E36 5632 
       202C 3D33 3231 
       7D56 000D 
0068E2 2020 5056 2050 00222             dw  "  VPP {0-5} Vpp Programming voltage\r"
       307B 352D 207D 
       7056 2070 7250 
       676F 6172 6D6D 
       6E69 2067 6F76 
       746C 6761 0D65 
006906 2020 2020 2020 00223             dw  "            Vpp pin 18: {0V, 13.4V, 13.8V, 21.7V, 25.9V, Ext. negative supply}\r"
       2020 2020 2020 
       7056 2070 6970 
       206E 3831 203A 
       307B 2C56 3120 
       2E33 5634 202C 
       3331 382E 2C56 
       3220 2E31 5637 
       202C 3532 392E 
       2C56 4520 7478 
       202E 656E 6167 
       6974 6576 7320 
       7075 6C70 7D79 
       000D 
006956 2020 2020 2020 00224             dw  "            Vpp pins 19-21: {0V, 12.7V, 13.1V, 21V, 25.2V, not allowed}\r"
       2020 2020 2020 
       7056 2070 6970 
       736E 3120 2D39 
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 164
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       3132 203A 307B 
       2C56 3120 2E32 
       5637 202C 3331 
       312E 2C56 3220 
       5631 202C 3532 
       322E 2C56 6E20 
       746F 6120 6C6C 
       776F 6465 0D7D 
00699E 2020 5056 2052 00225             dw  "  VPR {0/1} Vpp when reading the EPROM: {0V/5V}\r"
       307B 312F 207D 
       7056 2070 6877 
       6E65 7220 6165 
       6964 676E 7420 
       6568 4520 5250 
       4D4F 203A 307B 
       2F56 5635 0D7D 
0069CE 0000           00226             dw  0
                      00227 ;                12345678901234567890123456789012345678901234567890123456789012345678901234567890
                      00228 
                      00229 
                      06643 
                      06644     if  DEBUG
                      06645 ;******-------------------------------------------------------------------------*
                      06646 ;* PW * Adjust pulse width DEBUG command
                      06647 ;******
                      06648 ; On Entry:
                      06649 ;   R4 = second command character
                      06650 ;   DFLT_FLAG = 1 if the user did not provide an address offset value.
                      06651 ;   ADDRESSL = address offset
                      06652 ;*------------------------------------------------------------------------------*
                      06653 cmd_pw:     movf    R4,W,0              ;second character an W?
                      06654             xorlw   'W'                 ;anything else is an error
                      06655             btfss   STATUS,Z,0
                      06656             goto    cmd_error
                      06657 
                      06658 ;If no PW value from the user, then report the current setting, Otherwise
                      06659 ; set it according to the user input, then report
                      06660             movf    ADDRESSL,W,0        ;user input, if any
                      06661 
                      06662             btfss   FLAGS1,DFLT_FLAG,0
                      06663             movwf   CCPR1L,0            ;Set pulse width according to user input
                      06664 
                      06665             movlw   low(pw_msg)
                      06666             movwf   TBLPTRL,0
                      06667             movlw   high(pw_msg)
                      06668             movwf   TBLPTRH,0
                      06669             call    K_PRINTF            ;print the message
                      06670 
                      06671             movf    CCPR1L,W,0          ;print the current pulse width
                      06672             call    K_PRINTHEX2
                      06673             goto    main
                      06674 
                      06675 pw_msg:     dw  "Pulse width: ",0
                      06676 
                      06677     endif
                      06678 
                      06679 
                      06680     end
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 165
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

A                                 00000000
A10_msg                           00002C6A
A11_msg                           00002C70
A12_msg                           00002C76
A9_msg                            00002C66
ABDEN                             00000000
ABDOVF                            00000007
ACCESS                            00000000
ACKDT                             00000005
ACKEN                             00000004
ACKSTAT                           00000006
ACQT0                             00000003
ACQT1                             00000004
ACQT2                             00000005
ADCON0                            00000FC2
ADCON1                            00000FC1
ADCON2                            00000FC0
ADCS0                             00000000
ADCS1                             00000001
ADCS2                             00000002
ADDEN                             00000003
ADDRESSH                          00000006
ADDRESSH_SAVE                     0000001B
ADDRESSL                          00000005
ADDRESSL_SAVE                     0000001A
ADEN                              00000003
ADFM                              00000007
ADIE                              00000006
ADIF                              00000006
ADIP                              00000006
ADJ_VCC                           00000004
ADJ_VPP                           00000005
ADON                              00000000
ADRCLK                            00000002
ADRES                             00000FC3
ADRESH                            00000FC4
ADRESL                            00000FC3
ADR_OFFSET                        00000022
AN0                               00000000
AN1                               00000001
AN10                              00000001
AN11                              00000004
AN12                              00000000
AN2                               00000002
AN3                               00000003
AN4                               00000005
AN5                               00000000
AN6                               00000001
AN7                               00000002
AN8                               00000002
AN9                               00000003
ANS0                              00000000
ANS1                              00000001
ANS10                             00000002
ANS11                             00000003
ANS12                             00000004
ANS2                              00000002
ANS3                              00000003
ANS4                              00000004
ANS5                              00000005
ANS6                              00000006
ANS7                              00000007
ANS8                              00000000
ANS9                              00000001
ANSEL                             00000F7E
ANSELH                            00000F7F
ANSELH_INIT                       0000000A
ANSEL_INIT                        00000003
AO_INIT                           00000006
AO_MANUAL                         00000005
A_STATE                           00000001
BANKED                            00000001
BAUDCON                           00000FB8
BAUDCTL                           00000FB8
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 166
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

BCLIE                             00000003
BCLIF                             00000003
BCLIP                             00000003
BF                                00000000
BGST                              00000005
BOR                               00000000
BRG16                             00000003
BRGH                              00000002
BS                                00000008
BSR                               00000FE0
BUF_OFFSET                        00000017
B_STATE                           00000002
C                                 00000000
C12IN0M                           00000000
C12IN0N                           00000000
C12IN1M                           00000001
C12IN1N                           00000001
C12IN2M                           00000003
C12IN2N                           00000003
C12IN3M                           00000001
C12IN3N                           00000001
C1CH0                             00000000
C1CH1                             00000001
C1IE                              00000006
C1IF                              00000006
C1INP                             00000003
C1IP                              00000006
C1OE                              00000005
C1ON                              00000007
C1OUT_CM1CON0                     00000006
C1OUT_PORTA                       00000004
C1POL                             00000004
C1R                               00000002
C1RSEL                            00000005
C1SP                              00000003
C2CH0                             00000000
C2CH1                             00000001
C2IE                              00000005
C2IF                              00000005
C2INP                             00000002
C2IP                              00000005
C2OE                              00000005
C2ON                              00000007
C2OUT_CM2CON0                     00000006
C2OUT_PORTA                       00000005
C2POL                             00000004
C2R                               00000002
C2RSEL                            00000004
C2SP                              00000003
CCP1                              00000002
CCP1CON                           00000FBD
CCP1IE                            00000002
CCP1IF                            00000002
CCP1IP                            00000002
CCP1M0                            00000000
CCP1M1                            00000001
CCP1M2                            00000002
CCP1M3                            00000003
CCP2CON                           00000FBA
CCP2IE                            00000000
CCP2IF                            00000000
CCP2IP                            00000000
CCP2M0                            00000000
CCP2M1                            00000001
CCP2M2                            00000002
CCP2M3                            00000003
CCP2_PORTB                        00000003
CCP2_PORTC                        00000001
CCPR1                             00000FBE
CCPR1H                            00000FBF
CCPR1L                            00000FBE
CCPR2                             00000FBB
CCPR2H                            00000FBC
CCPR2L                            00000FBB
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 167
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

CEPROM_COUNT                      00000004
CE_TABLE                          00000022
CE_TABLEN                         00000090
CFGS                              00000006
CHECKSUM                          00000004
CHS0                              00000002
CHS1                              00000003
CHS2                              00000004
CHS3                              00000005
CK                                00000006
CKE                               00000006
CKP                               00000004
CKTXP                             00000004
CM1CON0                           00000F7B
CM2CON0                           00000F7A
CM2CON1                           00000F79
COUNTH                            00000019
COUNTH_SAVE                       0000001D
COUNTL                            00000018
COUNTL_SAVE                       0000001C
CR                                0000000D
CREN                              00000004
CR_FLAG                           00000003
CS                                00000002
CSPGM                             00000003
CSRC                              00000007
CSVPP                             00000001
CTRLC                             00000003
CUST_EPROM                        00000007
CVR0                              00000000
CVR1                              00000001
CVR2                              00000002
CVR3                              00000003
CVRCON                            00000FB5
CVRCON2                           00000FB4
CVREF                             00000002
CVREN                             00000007
CVROE                             00000006
CVRR                              00000005
CVRSS                             00000004
D                                 00000005
DBUFDIR                           00000006
DBUFOEn                           00000007
DC                                00000001
DC1B0                             00000004
DC1B1                             00000005
DC2B0                             00000004
DC2B1                             00000005
DDRA                              TRISA
DDRB                              TRISB
DDRC                              TRISC
DDRD                              TRISD
DDRE                              TRISE
DEBUG                             00000000
DEL                               0000007F
DFLT_FLAG                         00000003
DINV_STATE                        00000021
DONE                              00000001
DTRXP                             00000005
D_A                               00000005
D_NOT_A                           00000005
ECCP1AS                           00000FB6
ECCPAS0                           00000004
ECCPAS1                           00000005
ECCPAS2                           00000006
ECCPASE                           00000007
ECHO_FLAG                         00000002
EEADR                             00000FA9
EEADR0                            00000000
EEADR1                            00000001
EEADR2                            00000002
EEADR3                            00000003
EEADR4                            00000004
EEADR5                            00000005
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 168
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

EEADR6                            00000006
EEADR7                            00000007
EECON1                            00000FA6
EECON2                            00000FA7
EEDATA                            00000FA8
EEIE                              00000004
EEIF                              00000004
EEIP                              00000004
EEPGD                             00000007
EE_INIT                           00000000
EE_INITLEN                        00000014
EE_SN                             00000014
EE_SNLEN                          00000008
EE_VARBEG                         0000001C
EE_VARLEN                         000000E4
ERRCNTH                           0000000A
ERRCNTL                           00000009
ERR_FLAG                          00000000
ESC                               0000001B
ETYPE                             0000001C
ETYPE_SAVE                        0000001E
ET_A11A12                         00000018
ET_A9A10                          00000017
ET_BYTES                          00000016
ET_NAME                           00000000
ET_OECS                           00000019
ET_PARTNO1                        00000002
ET_PARTNO10                       00000014
ET_PARTNO2                        00000004
ET_PARTNO3                        00000006
ET_PARTNO4                        00000008
ET_PARTNO5                        0000000A
ET_PARTNO6                        0000000C
ET_PARTNO7                        0000000E
ET_PARTNO8                        00000010
ET_PARTNO9                        00000012
ET_PGMVPP                         0000001A
ET_PPDELAY                        0000001F
ET_PROGPULSE                      0000001E
ET_PROGREPS                       0000001D
ET_RESERVED                       00000023
ET_RLENGTH                        00000024
ET_SMART1                         00000020
ET_SMART2                         00000021
ET_SPECIAL                        00000022
ET_VBBVDD                         0000001B
ET_VCCMSG                         00000014
ET_VPPMSG                         00000015
ET_VPPSETUP                       0000001C
EXT_VPP                           00000006
FAILCNT                           0000001F
FALSE                             00000000
FAST                              00000001
FAST_PULSE                        00000003
FEPROM_COUNT                      00000028
FERR                              00000002
FLAGS1                            00000020
FLAGS2                            00000021
FLASH_MEM                         00000001
FLT0                              00000000
FREE                              00000004
FSR0                              00000000
FSR0H                             00000FEA
FSR0L                             00000FE9
FSR1                              00000001
FSR1H                             00000FE2
FSR1L                             00000FE1
FSR2                              00000002
FSR2H                             00000FDA
FSR2L                             00000FD9
FULL_FLAG                         00000004
FVREN                             00000007
FVRST                             00000006
GCEN                              00000007
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 169
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

GIE                               00000007
GIEH                              00000007
GIEL                              00000006
GIE_GIEH                          00000007
GO                                00000001
GO_DONE                           00000001
GO_NOT_DONE                       00000001
HLVDCON                           00000FD2
HLVDEN                            00000004
HLVDIE                            00000002
HLVDIF                            00000002
HLVDIN                            00000005
HLVDIP                            00000002
HLVDL0                            00000000
HLVDL1                            00000001
HLVDL2                            00000002
HLVDL3                            00000003
IBF                               00000007
IBOV                              00000005
IDLEN                             00000007
INDF0                             00000FEF
INDF1                             00000FE7
INDF2                             00000FDF
INP_FLAG                          00000001
INT0                              00000000
INT0E                             00000004
INT0F                             00000001
INT0IE                            00000004
INT0IF                            00000001
INT1                              00000001
INT1E                             00000003
INT1F                             00000000
INT1IE                            00000003
INT1IF                            00000000
INT1IP                            00000006
INT1P                             00000006
INT2                              00000002
INT2E                             00000004
INT2F                             00000001
INT2IE                            00000004
INT2IF                            00000001
INT2IP                            00000007
INT2P                             00000007
INTCON                            00000FF2
INTCON2                           00000FF1
INTCON3                           00000FF0
INTEDG0                           00000006
INTEDG1                           00000005
INTEDG2                           00000004
INTEL_STATE                       00000000
INTSRC                            00000007
INT_FLAGS                         0000000B
IOCB                              00000F7D
IOCB4                             00000004
IOCB5                             00000005
IOCB6                             00000006
IOCB7                             00000007
IOFS                              00000002
IPEN                              00000007
IPR1                              00000F9F
IPR2                              00000FA2
IRCF0                             00000004
IRCF1                             00000005
IRCF2                             00000006
IRVST                             00000005
IVRST                             00000005
KBI0                              00000004
KBI1                              00000005
KBI2                              00000006
KBI3                              00000007
KERN_FLAGS                        0000000C
K_ASKYN                           0000002A
K_CHKABORT                        0000002C
K_CONIN                           0000000A
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 170
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

K_CONOUT                          0000000C
K_EEPRINT                         00000010
K_GETCHR                          00000020
K_GETDEC                          00000024
K_GETHEX2                         00000026
K_GETHEX4                         00000028
K_GETLIN                          0000001C
K_GETUCHR                         00000022
K_HEX2BIN                         0000001A
K_KERN_REV                        00000002
K_PARSE                           0000001E
K_PRINTDEC                        00000016
K_PRINTF                          0000000E
K_PRINTHEX1                       00000012
K_PRINTHEX2                       00000014
K_PRINTSN                         00000018
K_PROG_ID                         00000004
K_RDEEPROM                        00000032
K_RDSRAM                          0000002E
K_STALL1U                         0000003E
K_STALL250U                       0000003C
K_STALL25M                        0000003A
K_WREEPROM                        00000034
K_WRSRAM                          00000030
LATA                              00000F89
LATA0                             00000000
LATA1                             00000001
LATA2                             00000002
LATA3                             00000003
LATA4                             00000004
LATA5                             00000005
LATA6                             00000006
LATA7                             00000007
LATB                              00000F8A
LATB0                             00000000
LATB1                             00000001
LATB2                             00000002
LATB3                             00000003
LATB4                             00000004
LATB5                             00000005
LATB6                             00000006
LATB7                             00000007
LATC                              00000F8B
LATC0                             00000000
LATC1                             00000001
LATC2                             00000002
LATC3                             00000003
LATC4                             00000004
LATC5                             00000005
LATC6                             00000006
LATC7                             00000007
LATD                              00000F8C
LATD0                             00000000
LATD1                             00000001
LATD2                             00000002
LATD3                             00000003
LATD4                             00000004
LATD5                             00000005
LATD6                             00000006
LATD7                             00000007
LATE                              00000F8D
LATE0                             00000000
LATE1                             00000001
LATE2                             00000002
LF                                0000000A
LIMTABLE                          00002286
LINBUF                            00000060
LISTROWS                          00000010
LOADED_CODE                       00000800
LVDCON                            00000FD2
LVDEN                             00000004
LVDIE                             00000002
LVDIF                             00000002
LVDIN                             00000005
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 171
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

LVDIP                             00000002
LVDL0                             00000000
LVDL1                             00000001
LVDL2                             00000002
LVDL3                             00000003
LVV0                              00000000
LVV1                              00000001
LVV2                              00000002
LVV3                              00000003
M12_75V                           00000003
M13_1V                            00000001
M21V                              00000001
M25V                              00000000
MAXLIN                            00000050
MAXNAME                           0000000E
MC1OUT                            00000007
MC2OUT                            00000006
MCLR                              00000003
ME2700ID                          00000000
MSK0                              00000000
MSK1                              00000001
MSK2                              00000002
MSK3                              00000003
MSK4                              00000004
MSK5                              00000005
MSK6                              00000006
MSK7                              00000007
N                                 00000004
NOT_A                             00000005
NOT_ADDRESS                       00000005
NOT_BOR                           00000000
NOT_CS                            00000002
NOT_DONE                          00000001
NOT_MCLR                          00000003
NOT_PD                            00000002
NOT_POR                           00000001
NOT_RBPU                          00000007
NOT_RD                            00000000
NOT_RI                            00000004
NOT_SS                            00000005
NOT_T1SYNC                        00000002
NOT_T3SYNC                        00000002
NOT_TO                            00000003
NOT_W                             00000002
NOT_WR                            00000001
NOT_WRITE                         00000002
OBF                               00000006
OEPGM                             00000002
OERR                              00000001
OEVPP                             00000000
OSCCON                            00000FD3
OSCFIE                            00000007
OSCFIF                            00000007
OSCFIP                            00000007
OSCTUNE                           00000F9B
OSTS                              00000003
OV                                00000003
P                                 00000004
P18_0                             00000002
P18_1                             00000003
P19_0                             00000004
P19_1                             00000005
P1A                               00000002
P1B                               00000005
P1C                               00000006
P1D                               00000007
P1M0                              00000006
P1M1                              00000007
P20_0                             00000006
P20_1                             00000007
P21_0                             00000000
P21_1                             00000001
P22n                              00000005
P23n                              00000000
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 172
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

P24_12Vn                          00000002
P24_5Vn                           00000000
P24_6Vn                           00000004
PACCOUNT                          00000080
PACINDEX                          0000002A
PC                                00000FF9
PCL                               00000FF9
PCLATH                            00000FFA
PCLATU                            00000FFB
PD                                00000002
PDC0                              00000000
PDC1                              00000001
PDC2                              00000002
PDC3                              00000003
PDC4                              00000004
PDC5                              00000005
PDC6                              00000006
PEIE                              00000006
PEIE_GIEL                         00000006
PEN                               00000002
PGC                               00000006
PGD                               00000007
PGM                               00000005
PIE1                              00000F9D
PIE2                              00000FA0
PIR1                              00000F9E
PIR2                              00000FA1
PLLEN                             00000006
PLUSW0                            00000FEB
PLUSW1                            00000FE3
PLUSW2                            00000FDB
PMODE0                            00000000
PMODE1                            00000001
POR                               00000001
PORTA                             00000F80
PORTB                             00000F81
PORTC                             00000F82
PORTD                             00000F83
PORTE                             00000F84
POSTDEC0                          00000FED
POSTDEC1                          00000FE5
POSTDEC2                          00000FDD
POSTINC0                          00000FEE
POSTINC1                          00000FE6
POSTINC2                          00000FDE
PPDELH                            00000026
PPDELL                            00000025
PPULSEH                           00000024
PPULSEL                           00000023
PR2                               00000FCB
PREINC0                           00000FEC
PREINC1                           00000FE4
PREINC2                           00000FDC
PREV_CR                           00000002
PREV_LF                           00000003
PROD                              00000FF3
PRODH                             00000FF4
PRODL                             00000FF3
PROGCNT                           0000001D
PROGREPS                          00000027
PROMPTCHR                         0000003E
PRSEN                             00000007
PSA                               00000003
PSP0                              00000000
PSP1                              00000001
PSP2                              00000002
PSP3                              00000003
PSP4                              00000004
PSP5                              00000005
PSP6                              00000006
PSP7                              00000007
PSPIE                             00000007
PSPIF                             00000007
PSPIP                             00000007
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 173
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

PSPMODE                           00000004
PSSAC0                            00000002
PSSAC1                            00000003
PSSBD0                            00000000
PSSBD1                            00000001
PSTRCON                           00000FB9
PWM1CON                           00000FB7
R                                 00000002
R0                                0000000D
R1                                0000000E
R2                                0000000F
R3                                00000010
R4                                00000011
R5                                00000012
R6                                00000013
R7                                00000014
R8                                00000015
R9                                00000016
RA0                               00000000
RA1                               00000001
RA2                               00000002
RA3                               00000003
RA4                               00000004
RA5                               00000005
RA6                               00000006
RA7                               00000007
RAMBUF_SIZ                        00000100
RAM_BUF                           00000200
RB0                               00000000
RB1                               00000001
RB2                               00000002
RB3                               00000003
RB4                               00000004
RB5                               00000005
RB6                               00000006
RB7                               00000007
RBIE                              00000003
RBIF                              00000000
RBIP                              00000000
RBPU                              00000007
RC0                               00000000
RC1                               00000001
RC2                               00000002
RC3                               00000003
RC4                               00000004
RC5                               00000005
RC6                               00000006
RC7                               00000007
RCEN                              00000003
RCIDL                             00000006
RCIE                              00000005
RCIF                              00000005
RCIP                              00000005
RCON                              00000FD0
RCREG                             00000FAE
RCSTA                             00000FAB
RD                                00000000
RD0                               00000000
RD1                               00000001
RD16                              00000007
RD2                               00000002
RD3                               00000003
RD4                               00000004
RD5                               00000005
RD6                               00000006
RD7                               00000007
RDVPP                             00000002
RE0                               00000000
RE1                               00000001
RE2                               00000002
RE3                               00000003
RECOUNTH                          00000008
RECOUNTL                          00000007
REQUIRED_KERN_REV                 00000010
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 174
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

REV_MAJOR                         00000001
REV_MINOR                         00000003
RI                                00000004
RQ_FULL                           00000004
RQ_IPTR                           00000000
RQ_OPTR                           00000001
RQ_SIZE                           00000100
RSEN                              00000001
RX                                00000007
RX9                               00000006
RX9D                              00000000
RX_QUEUE                          00000100
R_NOT_W                           00000002
R_W                               00000002
S                                 00000003
SBOREN                            00000006
SCK                               00000003
SCKP                              00000004
SCL                               00000003
SCS0                              00000000
SCS1                              00000001
SDA                               00000004
SDI                               00000004
SDO                               00000005
SEN                               00000000
SENDB                             00000003
SETUP                             00000003
SHARED                            0000001F
SLRA                              00000000
SLRB                              00000001
SLRC                              00000002
SLRCON                            00000F78
SLRD                              00000003
SLRE                              00000004
SMART1                            00000028
SMART2                            00000029
SMP                               00000007
SP0                               00000000
SP1                               00000001
SP2                               00000002
SP3                               00000003
SP4                               00000004
SPBRG                             00000FAF
SPBRGH                            00000FB0
SPEN                              00000007
SRAM_CEn                          00000001
SRAM_SIZE                         00002000
SREN                              00000005
SS                                00000005
SSPADD                            00000FC8
SSPBUF                            00000FC9
SSPCON1                           00000FC6
SSPCON2                           00000FC5
SSPEN                             00000005
SSPIE                             00000003
SSPIF                             00000003
SSPIP                             00000003
SSPM0                             00000000
SSPM1                             00000001
SSPM2                             00000002
SSPM3                             00000003
SSPMSK                            00000F77
SSPOV                             00000006
SSPSTAT                           00000FC7
START                             00000003
STATUS                            00000FD8
STKFUL                            00000007
STKOVF                            00000007
STKPTR                            00000FFC
STKUNF                            00000006
STOP                              00000004
STRA                              00000000
STRB                              00000001
STRC                              00000002
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 175
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

STRD                              00000003
STRSYNC                           00000004
SWDTE                             00000000
SWDTEN                            00000000
SYNC                              00000004
T08BIT                            00000006
T0CKI                             00000004
T0CON                             00000FD5
T0CS                              00000005
T0IE                              00000005
T0IF                              00000002
T0PS0                             00000000
T0PS1                             00000001
T0PS2                             00000002
T0SE                              00000004
T13CKI                            00000000
T1CKI                             00000000
T1CKPS0                           00000004
T1CKPS1                           00000005
T1CON                             00000FCD
T1OSCEN                           00000003
T1OSI                             00000001
T1OSO                             00000000
T1RUN                             00000006
T1SYNC                            00000002
T2CKPS0                           00000000
T2CKPS1                           00000001
T2CON                             00000FCA
T2OUTPS0                          00000003
T2OUTPS1                          00000004
T2OUTPS2                          00000005
T2OUTPS3                          00000006
T3CCP1                            00000003
T3CCP2                            00000006
T3CKI                             00000000
T3CKPS0                           00000004
T3CKPS1                           00000005
T3CON                             00000FB1
T3SYNC                            00000002
TABLAT                            00000FF5
TBLPTR                            00000FF6
TBLPTRH                           00000FF7
TBLPTRL                           00000FF6
TBLPTRU                           00000FF8
TEST                              00000007
TMR0                              00000FD6
TMR0H                             00000FD7
TMR0IE                            00000005
TMR0IF                            00000002
TMR0IP                            00000002
TMR0L                             00000FD6
TMR0ON                            00000007
TMR1                              00000FCE
TMR1CS                            00000001
TMR1H                             00000FCF
TMR1IE                            00000000
TMR1IF                            00000000
TMR1IP                            00000000
TMR1L                             00000FCE
TMR1ON                            00000000
TMR2                              00000FCC
TMR2IE                            00000001
TMR2IF                            00000001
TMR2IP                            00000001
TMR2ON                            00000002
TMR3                              00000FB2
TMR3CS                            00000001
TMR3H                             00000FB3
TMR3IE                            00000001
TMR3IF                            00000001
TMR3IP                            00000001
TMR3L                             00000FB2
TMR3ON                            00000000
TO                                00000003
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 176
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

TOS                               00000FFD
TOSH                              00000FFE
TOSL                              00000FFD
TOSU                              00000FFF
TQ_EMPTY                          00000001
TQ_IPTR                           00000002
TQ_OPTR                           00000003
TQ_SIZE                           00000010
TRISA                             00000F92
TRISA0                            00000000
TRISA1                            00000001
TRISA2                            00000002
TRISA3                            00000003
TRISA4                            00000004
TRISA5                            00000005
TRISA6                            00000006
TRISA7                            00000007
TRISA_INIT                        00000003
TRISB                             00000F93
TRISB0                            00000000
TRISB1                            00000001
TRISB2                            00000002
TRISB3                            00000003
TRISB4                            00000004
TRISB5                            00000005
TRISB6                            00000006
TRISB7                            00000007
TRISB_INIT                        0000000A
TRISC                             00000F94
TRISC0                            00000000
TRISC1                            00000001
TRISC2                            00000002
TRISC3                            00000003
TRISC4                            00000004
TRISC5                            00000005
TRISC6                            00000006
TRISC7                            00000007
TRISC_INIT                        00000090
TRISD                             00000F95
TRISD0                            00000000
TRISD1                            00000001
TRISD2                            00000002
TRISD3                            00000003
TRISD4                            00000004
TRISD5                            00000005
TRISD6                            00000006
TRISD7                            00000007
TRISD_INIT                        000000FF
TRISE                             00000F96
TRISE0                            00000000
TRISE1                            00000001
TRISE2                            00000002
TRISE_INIT                        00000008
TRMT                              00000001
TRUE                              000000FF
TUN0                              00000000
TUN1                              00000001
TUN2                              00000002
TUN3                              00000003
TUN4                              00000004
TUN5                              00000005
TX                                00000006
TX9                               00000006
TX9D                              00000000
TXEN                              00000005
TXIE                              00000004
TXIF                              00000004
TXIP                              00000004
TXREG                             00000FAD
TXSTA                             00000FAC
TX_QUEUE                          000000E0
UA                                00000001
VCFG0                             00000004
VCFG1                             00000005
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 177
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

VDIRMAG                           00000007
VPP                               00000003
VPP_PW                            00000012
VPULSE                            00000002
VREFM                             00000002
VREFN                             00000002
VREFP                             00000003
VSENSE_HIGH                       0000002C
VSENSE_LOW                        0000002B
W                                 00000000
WCOL                              00000007
WDTCON                            00000FD1
WPUB                              00000F7C
WPUB0                             00000000
WPUB1                             00000001
WPUB2                             00000002
WPUB3                             00000003
WPUB4                             00000004
WPUB5                             00000005
WPUB6                             00000006
WPUB7                             00000007
WR                                00000001
WREG                              00000FE8
WREN                              00000002
WRERR                             00000003
WUE                               00000001
XOFF                              00000013
XOFF_STATE                        00000000
XON                               00000011
Z                                 00000002
_BOREN_NOSLP_2L                   000000FD
_BOREN_OFF_2L                     000000F9
_BOREN_ON_2L                      000000FB
_BOREN_SBORDIS_2L                 000000FF
_BORV_18_2L                       000000FF
_BORV_22_2L                       000000F7
_BORV_27_2L                       000000EF
_BORV_30_2L                       000000E7
_CCP2MX_PORTBE_3H                 000000FE
_CCP2MX_PORTC_3H                  000000FF
_CONFIG1H                         00300001
_CONFIG2H                         00300003
_CONFIG2L                         00300002
_CONFIG3H                         00300005
_CONFIG4L                         00300006
_CONFIG5H                         00300009
_CONFIG5L                         00300008
_CONFIG6H                         0030000B
_CONFIG6L                         0030000A
_CONFIG7H                         0030000D
_CONFIG7L                         0030000C
_CP0_OFF_5L                       000000FF
_CP0_ON_5L                        000000FE
_CP1_OFF_5L                       000000FF
_CP1_ON_5L                        000000FD
_CP2_OFF_5L                       000000FF
_CP2_ON_5L                        000000FB
_CP3_OFF_5L                       000000FF
_CP3_ON_5L                        000000F7
_CPB_OFF_5H                       000000FF
_CPB_ON_5H                        000000BF
_CPD_OFF_5H                       000000FF
_CPD_ON_5H                        0000007F
_DEBUG_OFF_4L                     000000FF
_DEBUG_ON_4L                      0000007F
_DEVID1                           003FFFFE
_DEVID2                           003FFFFF
_EBTR0_OFF_7L                     000000FF
_EBTR0_ON_7L                      000000FE
_EBTR1_OFF_7L                     000000FF
_EBTR1_ON_7L                      000000FD
_EBTR2_OFF_7L                     000000FF
_EBTR2_ON_7L                      000000FB
_EBTR3_OFF_7L                     000000FF
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 178
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

_EBTR3_ON_7L                      000000F7
_EBTRB_OFF_7H                     000000FF
_EBTRB_ON_7H                      000000BF
_FCMEN_OFF_1H                     000000BF
_FCMEN_ON_1H                      000000FF
_FOSC_ECIO6_1H                    000000F5
_FOSC_EC_1H                       000000F4
_FOSC_HSPLL_1H                    000000F6
_FOSC_HS_1H                       000000F2
_FOSC_INTIO67_1H                  000000F8
_FOSC_INTIO7_1H                   000000F9
_FOSC_LP_1H                       000000F0
_FOSC_RCIO6_1H                    000000F7
_FOSC_RC_1H                       000000F3
_FOSC_XT_1H                       000000F1
_HFOFST_OFF_3H                    000000F7
_HFOFST_ON_3H                     000000FF
_IDLOC0                           00200000
_IDLOC1                           00200001
_IDLOC2                           00200002
_IDLOC3                           00200003
_IDLOC4                           00200004
_IDLOC5                           00200005
_IDLOC6                           00200006
_IDLOC7                           00200007
_IESO_OFF_1H                      0000007F
_IESO_ON_1H                       000000FF
_LPT1OSC_OFF_3H                   000000FB
_LPT1OSC_ON_3H                    000000FF
_LVP_OFF_4L                       000000FB
_LVP_ON_4L                        000000FF
_MCLRE_OFF_3H                     0000007F
_MCLRE_ON_3H                      000000FF
_PBADEN_OFF_3H                    000000FD
_PBADEN_ON_3H                     000000FF
_PWRT_OFF_2L                      000000FF
_PWRT_ON_2L                       000000FE
_STVREN_OFF_4L                    000000FE
_STVREN_ON_4L                     000000FF
_WDTEN_OFF_2H                     000000FE
_WDTEN_ON_2H                      000000FF
_WDTPS_1024_2H                    000000F5
_WDTPS_128_2H                     000000EF
_WDTPS_16384_2H                   000000FD
_WDTPS_16_2H                      000000E9
_WDTPS_1_2H                       000000E1
_WDTPS_2048_2H                    000000F7
_WDTPS_256_2H                     000000F1
_WDTPS_2_2H                       000000E3
_WDTPS_32768_2H                   000000FF
_WDTPS_32_2H                      000000EB
_WDTPS_4096_2H                    000000F9
_WDTPS_4_2H                       000000E5
_WDTPS_512_2H                     000000F3
_WDTPS_64_2H                      000000ED
_WDTPS_8192_2H                    000000FB
_WDTPS_8_2H                       000000E7
_WRT0_OFF_6L                      000000FF
_WRT0_ON_6L                       000000FE
_WRT1_OFF_6L                      000000FF
_WRT1_ON_6L                       000000FD
_WRT2_OFF_6L                      000000FF
_WRT2_ON_6L                       000000FB
_WRT3_OFF_6L                      000000FF
_WRT3_ON_6L                       000000F7
_WRTB_OFF_6H                      000000FF
_WRTB_ON_6H                       000000BF
_WRTC_OFF_6H                      000000FF
_WRTC_ON_6H                       000000DF
_WRTD_OFF_6H                      000000FF
_WRTD_ON_6H                       0000007F
_XINST_OFF_4L                     000000BF
_XINST_ON_4L                      000000FF
__18F45K20                        00000001
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 179
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

__DEBUG                           1
abort                             00001434
abort_msg                         00002616
address2pins                      0000188C
adj_msg                           00002910
adjvcc_msg                        00002926
andthen_msg                       000026D6
another_msg                       000026EE
anyway_msg                        000029FA
apl_msg                           00002886
as_msg                            00002C88
ask_yn                            00001440
asn2pin                           000017F6
assignp                           00001B50
assignp_hi                        00001B46
assignp_hl                        00001B4C
assignp_lo                        00001B4A
auto_msg                          000025B6
avpp_done                         00000F7C
bad_input_msg                     00002462
bd_aloop                          00000B42
bd_ascii                          00000B34
bd_loop                           00000B16
bd_newline                        00000B06
bd_sploop                         00000B34
bd_sum                            00000B64
bhelp_msg                         000046DC
binstall_r3                       00001DE6
boffset_msg                       0000248C
buffer_msg                        00002566
buffill_msg                       000025A0
by_msg                            00002ABA
cantedit_msg                      00002B5C
check_pause                       00001414
cksum_error                       000009CE
cksumerror_msg                    0000247C
clr_sram                          00000808
cmd_avpp                          00000F5C
cmd_bdisplay                      00000B04
cmd_bedit                         00000B7A
cmd_bhelp                         0000096E
cmd_blankchk                      00000D5A
cmd_boffset                       00000ACA
cmd_ceedit                        00000962
cmd_cksum                         00000E88
cmd_compare                       00000D42
cmd_dhelp                         0000097E
cmd_dinvert                       00000CA0
cmd_dispeprom                     00000C7C
cmd_dstate                        00000BEC
cmd_echo                          00000D7A
cmd_ehelp                         00000986
cmd_eplist                        00000D96
cmd_error                         00000CDA
cmd_etype                         00000CE0
cmd_fhelp                         0000098E
cmd_fill                          00000BC8
cmd_foffset                       00000ADE
cmd_help                          00000966
cmd_intel                         000009F4
cmd_lhelp                         00000996
cmd_motorola                      000009A2
cmd_nhelp                         00000976
cmd_program                       00000DF8
cmd_rdata                         00000F84
cmd_read                          00000E8A
cmd_tas                           00001054
cmd_tcs                           00000FD6
cmd_thi                           00000FE6
cmd_toe                           00001046
cmd_tpgm                          00000FC6
cmd_tprog                         000010B8
cmd_tread                         000010E2
cmd_tvcc                          00000FB4
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 180
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

cmd_tvpp                          00000FF6
cmd_uploadi                       00000ECA
cmd_uploads                       00000EC6
cmd_vbbvdd                        00000F98
cmd_waddress                      000010B6
cmd_wdata                         000010A8
cmdlst_msg                        00002444
cmpgood_msg                       000025DE
colonspace_msg                    00002780
cp_done                           00001428
cr_hprintf                        0000220C
cr_printf                         00001404
cr_printf2                        00000CDE
cs2pin                            00001880
cs_msg                            00002C96
csn_msg                           00002C94
csum_msg                          00002570
cust_lookup                       00001904
d_rec1                            00000A0C
dataread_msg                      00002784
dd_loop                           00001E1E
dd_not19                          00001E5E
dd_not21                          00001E70
de_bloop                          00001EB2
de_dumb                           00002016
de_noVpp                          00001F96
de_nodelay                        00001FE8
de_nopgm                          00001FAC
de_nopoll                         00001FDE
de_novccadj                       00001F0C
de_pwdone                         0000207A
de_reps                           0000201C
de_smart                          0000207C
de_vadone                         00001F0E
decode_pulse                      000016CC
delce_msg                         00002E68
des1                              000020B4
dhelp_msg                         00004278
dinvert_msg                       0000258C
dispeprom                         00001E92
do_ceedit                         000019C2
do_main                           0000087A
do_printf                         000013F8
download_rec                      000009FA
dp_done                           000016EC
dr_ckcum                          00000A52
dr_data_loop                      00000A30
dr_eof_rec                        00000A76
dr_get_data                       00000A28
dr_next_record                    00000A64
dr_noload                         00000A52
dup_delete                        00001E12
eachbyte_msg                      000026AA
eamenu_msg                        0000617C
eb_compare                        00000D48
ec_bogus                          00001CD4
echostate_msg                     00002584
ecmd_a10                          00001B0C
ecmd_a11                          00001B18
ecmd_a12                          00001B24
ecmd_a9                           00001B06
ecmd_ahelp                        0000196C
ecmd_asn                          00001B30
ecmd_bck                          00001CBA
ecmd_copy                         00001CCC
ecmd_cs                           00001B90
ecmd_csp                          00001BBA
ecmd_deleprom                     00001AAC
ecmd_dispeprom                    00001E92
ecmd_eehelp                       00001978
ecmd_epname                       0000199E
ecmd_error                        00001E0C
ecmd_ff1                          00001D40
ecmd_fn1                          00001DD6
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 181
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

ecmd_fn12                         00001DDC
ecmd_fn2                          00001DDA
ecmd_fp1                          00001DC0
ecmd_fp12                         00001DC6
ecmd_fp2                          00001DC4
ecmd_hi                           00001B3C
ecmd_oen                          00001B64
ecmd_oev                          00001C5A
ecmd_pgm                          00001BCC
ecmd_pgp                          00001BF6
ecmd_phelp                        00001AA0
ecmd_pmx                          00001DEE
ecmd_pol                          00001DAC
ecmd_ppp                          00001C08
ecmd_pps                          00001D90
ecmd_ppw                          00001D82
ecmd_ptu                          00001D60
ecmd_pul                          00001D52
ecmd_quit                         00001996
ecmd_spa                          00001DB6
ecmd_vbb                          00001ACE
ecmd_vcp                          00001C4C
ecmd_vdd                          00001AEA
ecmd_vpp                          00001C98
ecmd_vpr                          00001CA8
ecmp_loop                         0000148C
ecopy_error                       00001D2E
ecopy_loop                        00001CF8
ecs_same                          00001BB2
edel_done                         00001ACC
edel_loop                         00001AC0
eds_print                         0000155E
ee_cmds                           00002358
ee_getdec                         00001DFA
ee_main                           000019E4
eemenu_msg                        00005F9E
eepoll                            00001272
eeprom_msg                        00002AC0
eeprompt_msg                      00002468
egv_cust                          000018D0
ehelp_msg                         00005100
elist_msg                         0000273C
eoen_same                         00001B86
ep10_msg                          00002E00
ep11_msg                          00002E1A
ep12_msg                          00002E34
ep1_msg                           00002CDA
ep2_msg                           00002D20
ep3_msg                           00002D52
ep4_msg                           00002D6A
ep5_msg                           00002D82
ep6_msg                           00002D9A
ep7_msg                           00002DB2
ep8_msg                           00002DCC
ep9_msg                           00002DE6
ep_2704                           000030C6
ep_2708                           00003156
ep_2716                           0000319E
ep_2716A                          000031C2
ep_2716Afast                      000031E6
ep_2716B                          0000320A
ep_2732                           0000334E
ep_2732A                          00003372
ep_2732B                          000033BA
ep_2732H                          000033DE
ep_2732af                         00003396
ep_2758                           0000317A
ep_27C16B                         00003252
ep_27C32B                         00003402
ep_27HC641                        00003522
ep_27HC641r                       0000356A
ep_27HC641s                       00003546
ep_27c16h                         0000322E
ep_2804a                          000030EA
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 182
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

ep_2816a                          000032E2
ep_2816ai                         0000332A
ep_28C04                          0000310E
ep_28C16                          00003306
ep_28c04n                         00003642
ep_52b13h                         000035D6
ep_57C191                         0000329A
ep_57C191C                        000032BE
ep_57C43                          00003492
ep_57C43C                         000034B6
ep_57C49C                         000035B2
ep_57C49b                         0000358E
ep_IM6654                         00003132
ep_IM6658                         000035FA
ep_LH5749                         000034FE
ep_MCM68764                       000034DA
ep_TMS2532                        00003426
ep_TMS2532A                       0000344A
ep_TMS2716                        00003276
ep_TMS2732A                       0000346E
ep_adcwait                        00001374
ep_bumpdone                       00000E86
ep_compare                        0000148C
ep_lh57191                        0000361E
ep_msg                            00002B36
epbc_blank                        00000E2E
epbc_loop                         00000E1C
epbc_notblank                     00000E28
epf_msg                           00002B4C
epgm_same                         00001BEE
epin18                            0000185C
epin19                            0000184E
epin20                            00001840
epin21                            00001832
epin22                            00001826
epin22_low                        0000182E
epin23                            0000181A
epin23_low                        00001822
epin_none                         0000186A
epintab                           00001808
epmenu_msg                        000064D2
epn_loop                          000019A6
epower_off                        000013BA
epower_prog                       00001346
epower_read                       0000139A
eprange                           000014AE
eprom_msg                         000025C2
eprom_table                       000030C6
eps_msg                           00002B4E
eptend                            0000181A
eread_byte                        00001318
error_01                          00001104
errorcount_msg                    000024A6
es_2704                           000037B4
es_2708                           000037D4
es_2716                           000037E4
es_2716a                          000037EC
es_2716afast                      000037F4
es_2716b                          00003800
es_2732                           0000384C
es_2732a                          00003854
es_2732afast                      0000385C
es_2732b                          00003868
es_2758                           000037DC
es_27c16b                         00003810
es_27c16h                         00003808
es_27c32b                         00003878
es_27c32h                         00003870
es_27hc641                        000038BE
es_27hc641r                       000038D2
es_27hc641s                       000038C8
es_2804a                          000037BC
es_2816a                          00003834
es_2816ai                         00003844
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 183
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

es_28c04                          000037C4
es_28c04a                         00003A6C
es_28c04n                         00003906
es_28c16                          0000383C
es_28c16a                         00003A74
es_52b13                          00003B3E
es_52b13h                         000038EC
es_5516a                          00003B46
es_55v                            00003C46
es_573RF2                         00003B4E
es_57c191                         00003822
es_57c191c                        0000382A
es_57c43                          0000389E
es_57c43c                         000038A6
es_57c49b                         000038DC
es_57c49c                         000038E4
es_65v                            00003C4E
es_68764                          000038AE
es_am2708                         0000390E
es_am2716                         00003916
es_am2716b                        0000391E
es_am2732                         00003928
es_am2732a                        00003930
es_am2732b                        0000393A
es_amd                            00003670
es_at27hc641                      00003962
es_at27hc641r                     0000397A
es_at27hc642                      0000396E
es_at27hc642r                     00003986
es_at28c04                        00003944
es_at28c16                        0000394E
es_at28c16e                       00003958
es_atmel                          00003678
es_cat28c16a                      00003992
es_catalyst                       00003680
es_ea2708                         0000399E
es_elecarrays                     0000368A
es_et2716q                        000039C4
es_et2732q                        000039CE
es_eurotech                       00003696
es_exel                           000036A2
es_f2708                          000039D8
es_f2732                          000039F8
es_fairchild                      000036AA
es_fastpp                         00001648
es_fujitsu                        000036B6
es_gi                             000036C0
es_harris                         000036C8
es_here                           00003668
es_hitachi                        000036D0
es_hm6758                         00003A36
es_hn462532                       00003A40
es_hn462716                       00003A4A
es_hn462732g                      00003A54
es_hn482732ag                     00003A60
es_im6654                         000037CC
es_im6658                         000038F4
es_intel                          000036DA
es_intersil                       000036E2
es_km2816a                        00003B34
es_lh57191                        000038FC
es_lh5749                         000038B6
es_m2532                          00003B56
es_m2716                          00003B5E
es_m2716af                        00003B66
es_m2732a                         00003B74
es_m2732af                        00003B7C
es_m5l2732k                       00003A7C
es_mbm2716                        00003A18
es_mbm2732                        00003A22
es_mbm2732a                       00003A2C
es_mcm2532                        00003A96
es_mcm2732                        00003AA0
es_mcm68764                       00003AAA
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 184
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

es_mcm68766                       00003AB4
es_mhb8708c                       00003B8A
es_microchip                      000036EC
es_mitsubishi                     000036F8
es_mm2704                         00003ABE
es_mm2708                         00003AC6
es_mm2716e                        00003ACE
es_mm2758A                        00003AD8
es_mme                            00003704
es_motorola                       0000370C
es_msm2716as                      00003B16
es_msm2758                        00003B22
es_n30v                           00003C56
es_n40v                           00003C7E
es_national                       00003716
es_nec                            00003720
es_nmc27c16b                      000039E0
es_nmc27c16h                      000039EC
es_nmc27c32b                      00003A00
es_nmc27c32h                      00003A0C
es_nolimit                        0000169A
es_nte                            00003728
es_nte2708                        00003B02
es_nte2716                        00003B0C
es_oki                            0000373A
es_onsemi                         00003730
es_r87C32                         00003B2C
es_rockwell                       00003742
es_samsung                        0000374C
es_seeq                           00003756
es_sgs                            0000375E
es_sharp                          00003766
es_signetics                      0000376E
es_soviet                         0000377A
es_st                             00003782
es_tesla                          0000378A
es_ti                             00003792
es_tmm2732d                       00003BC0
es_tms2508                        00003B94
es_tms2516                        00003B9E
es_tms2532                        00003880
es_tms2532a                       0000388A
es_tms2708                        00003BA8
es_tms2716                        00003818
es_tms2732a                       00003894
es_tms2758jl0                     00003BB2
es_toshiba                        0000379A
es_u2732                          00003A8E
es_u555c                          00003A86
es_upd2732                        00003AE4
es_upd2732a                       00003AEE
es_upd28c04                       00003AF8
es_ws57c191                       00003BCA
es_ws57c191b                      00003BD4
es_ws57c191c                      00003BE0
es_ws57c291                       00003BEC
es_ws57c291b                      00003BF6
es_ws57c291c                      00003C02
es_ws57c43b                       00003C0E
es_ws57c43c                       00003C18
es_ws57c49b                       00003C22
es_ws57c49c                       00003C2C
es_wsi                            000037A4
es_x2804a                         00003C36
es_x2816b                         00003C3E
es_xicor                          000037AC
es_xl2804a                        000039A6
es_xl2816a                        000039B0
es_xl28c16a                       000039BA
eset_vpp                          0000169E
esize_msg                         00002AB0
estrings                          00003668
estrings_almostend                00003C7E
esum_rd_loop                      00000E96
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 185
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

etype_getval                      000018C2
etype_invalid                     00000D3A
etype_lookup                      000018D8
etype_msg                         00002792
etype_setup                       000015D2
evbb_none                         00001AE4
evdd_none                         00001B00
evpp_same                         00001C3E
evppoe_sam                        00001C34
ewrite_byte                       00001146
ewrite_loop                       00001108
ewrite_range                      00001106
extneg_msg                        000029C0
fail_msg                          00002606
fast18                            00001310
fast19                            00001308
fast20                            00001300
fast21                            000012F8
fast22                            000012F0
fast23                            000012E8
fast_pgmpulse                     000012CC
ff_msg                            000026A0
fhelp_msg                         0000560A
fill_buf_loop                     00000BDA
fjtab                             000012D6
fjtend                            000012E8
flookup                           000018E8
flush_abort                       0000142A
foffset_msg                       000024F0
full_record                       00000F0C
fwrev_msg                         00002548
get_byte_cksum                    000009E4
get_pin                           00001E72
gname_msg                         00002E7C
go_ee_main                        000019E8
gp_done                           00001E8E
gp_error                          00001E8A
ha_error                          000009D2
help_msg                          00003CA6
hexerror_msg                      00002474
hi2pin                            0000186E
hprintf                           00002208
hunt_12                           0000212C
hunt_cs                           0000215E
hunt_not12                        00002140
hunt_notVpp                       000021CA
hunt_notcs                        00002172
hunt_notvbb                       000021E2
hunt_notvdd                       000021FA
hunt_pin                          000020EC
hunt_ppin                         00002206
hunt_pvpp                         000021C2
hunt_sppin                        00002202
hunt_vpp                          0000218C
hvpanic_msg                       0000263E
init                              00000802
install_r3                        00001DE8
int_end_rec                       0000250C
int_start_rec                     00002508
isblank_msg                       000025EE
jmpend1                           00000960
jmpend2                           00001AA0
jmptab1                           00000908
jmptab2                           00001A44
lbc_default                       0000146E
lbc_loop                          0000145E
le_eprom                          00000DC2
le_loop                           00000DA4
lhelp_msg                         00005B14
limit_count                       00001450
loadcount_msg                     000024D0
loaderrev_msg                     0000252C
lvpanic_msg                       00002658
main                              00000874
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 186
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

main_cmds                         0000228E
matchp_msg                        000026C0
maxp_msg                          00002722
mb_loop                           00000B7C
mb_nxtbyte                        00000BBE
mismatcha_msg                     00002756
mismatchb_msg                     0000276A
mismatche_msg                     00002778
mot_end_rec                       0000251E
mot_nodatarec                     000009BA
mot_s1                            000009DC
mot_s5                            000009B8
mot_s9                            00000A6C
mot_start_rec                     0000251A
ms_msg                            00002A4C
msg_abort                         00001438
mult_msg                          00002704
next_a_count                      00001478
no_adjvcc                         00002230
no_adjvpp                         00002266
no_prompt                         0000088E
no_stall                          00001270
nonexist_msg                      0000289E
notblank_msg                      000029D2
notes2700                         00004ACC
novbbvdd_msg                      000028AE
novpp_msg                         00002B8E
ns500_msg                         00002A42
oe_msg                            00002C8E
oen2pin                           000017AE
oen2pin_20                        000017DE
oev_ok                            00001C80
oev_pnerr                         00001C88
oev_vpperr                        00001C90
oeverr_msg                        00002BBC
oevperr_msg                       00002BF2
off_msg                           00002880
on_msg                            0000287A
op_fatpulse                       000011FA
opf_novflow                       00001220
opf_ovflow                        0000121C
overprog                          000011DA
p12v_msg                          00002A6E
p_estring                         00001566
pacify                            00001118
pactive_msg                       0000285A
pal_loop                          0000157E
panic_vpp                         0000138A
param2_ok                         00000908
pass2_msg                         0000268C
pause_loop                        00001420
pdecode_time                      0000205E
pes_blanks                        00001596
pes_exit                          000015A0
pgm2pin                           000017E8
pgm_msg                           00002CA2
pgmn_msg                          00002C9A
pin_msg                           0000286C
pinactive_msg                     00002858
pmode_msg                         00002844
poll_loop                         00001278
poll_msg                          00002AFC
poll_timeout                      00001296
pop_cmderr                        000014E2
ppd_msg                           00002A28
ppp_err                           00001C46
ppr_msg                           00002A58
pps_save                          00001DAA
ppw_msg                           00002A0C
prange                            000014B2
print_1name                       0000204A
print_2names                      00002026
print_addr                        000013DA
print_help                        0000099C
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 187
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

print_hex_csum                    0000144A
print_onoff                       0000109C
print_pin                         00001060
printf                            000013F0
prog_abort                        000012C2
prog_loop1                        00000E44
programing_msg                    00002712
prompt_msg                        0000245E
propulse_msg                      00002AE4
pto_msg                           0000261E
pulse_byte                        0000122C
pulse_msg                         0000270A
pulsing_msg                       000028E6
pvpp_msg                          00002A9C
pvpp_notpin18                     00001944
pvpp_printv                       0000195C
pvpp_voltage                      00001912
pwroff_msg                        00002828
quiet_abort                       0000143A
range_msg                         0000257C
rcnterror_msg                     00002484
read_msg                          000025CA
reading_msg                       000028F2
readjvcc_msg                      0000295A
readjvp_msg                       0000297E
ready2prog_msg                    00002F18
rec_error                         000009C2
reccount_msg                      000024C4
recerror_msg                      0000246C
removej_msg                       000029A2
rep_ba_offset                     00000AD2
rep_di                            00000CB6
rep_di1                           00000CCC
rep_dinvert                       00000CB0
rep_dion                          00000CB4
rep_echo                          00000D84
rep_etype                         00001544
rep_etype2                        00001548
rep_fa_offset                     00000AEE
rep_mismatch                      00001512
rep_mm_skipb                      0000152E
rep_so                            000015CC
rep_vpp                           000015A2
req_msg                           0000294A
restore_etype                     00001508
restore_params                    000014D0
retry_pulse                       00001186
rmode_msg                         00002836
rvppat_msg                        00002A88
s5_error                          000009C8
save_etype                        000014FE
save_params                       000014BE
set_epin                          00001804
set_vpp                           000016A6
setvpp_msg                        000027EA
sfail_msg                         00002B1C
signon_msg                        00002FAC
size_done                         00001A22
smart_n                           000011EE
smart_n0                          000011F8
smart_nloop                       000011F2
smartrapid_msg                    00002672
space2_msg                        00002CD6
space7_msg                        00002CD0
spec_eprint                       0000226E
special_v                         00002210
spp_adcwait                       000012B6
ss_almostend                      00002FAC
sstrings                          00002444
stall_between                     00001244
stall_ppulse                      000012AA
stall_r1r0                        0000125E
stuckhi_msg                       00002C7C
success_msg                       0000260C
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 188
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

supdev_msg                        00002E4E
swoff_msg                         000028FE
tcmd_setup                        000014E8
test_01                           000010F8
testvpp_msg                       000027D6
times_msg                         000026B6
to_msg                            00002AAA
tp_loop                           000010C4
tread_loop                        000010EA
tvcc_msg                          00002874
tvpp_msg                          00002868
tvpp_print                        00001036
type_msg                          000025F8
ul_countok                        00000EFA
unassgn_msg                       000027CA
unassign_msg                      00002CC4
undef_msg                         000027AC
up_byte_loop                      00000F34
upload_buf                        00000ECC
upload_loop                       00000EFA
us_msg                            00002A52
v0_msg                            00002C14
v1270_msg                         00002C28
v12_msg                           00002C22
v1315_msg                         00002C30
v1340_msg                         00002C46
v1385_msg                         00002C4E
v2170_msg                         00002C56
v21_msg                           00002C38
v2510_msg                         00002C3E
v2590_msg                         00002C5E
v2p_poff                          00001756
v2p_prog                          0000174C
v2pins                            0000175C
v2ptab                            00001764
v2ptend                           00001772
v5_msg                            00002C18
v6_msg                            00002C1C
vbb5v_msg                         00002CB0
vbb_msg                           000028C8
vbbvdd2pins                       00001718
vcc2p_5V                          000016FC
vcc2p_not6                        00001714
vcc2p_off                         00001716
vcc2p_onprog                      00001700
vcc2pin                           000016EE
vdd12v_msg                        00002CBA
verifying_msg                     00002730
vp18_msg                          000027F8
vpp20q                            0000178E
vpp2pin                           0000173C
vpp_msg                           00002CA8
vpp_pin18                         000017A0
vpp_pin20                         0000177C
vpp_pin21                         00001772
vpp_pulse                         0000129C
vppto_msg                         00002938
wait_txempty                      0000153A
withone_msg                       000026F8
write_msg                         00002696
writefail_msg                     00002600
wrong_programmer                  00002278
wrongkern_msg                     00002EBE
wrongprog_msg                     00002EF2
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 189
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


0800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
08C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0900 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0940 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0980 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
09C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0A00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0A40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0A80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0AC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0B00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0B40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0B80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0BC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0C00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0C40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0C80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0CC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0D00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0D40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0D80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0DC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0E00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0E40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0E80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0EC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0F00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0F40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0F80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0FC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
10C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
11C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1280 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
12C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1300 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1340 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1380 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
13C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1400 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1440 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1480 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
14C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1500 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1540 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1580 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
15C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1600 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1640 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1680 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
16C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1700 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1740 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1780 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
17C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 190
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


18C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1900 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1940 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1980 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
19C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1A00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1A40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1A80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1AC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1B00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1B40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1B80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1BC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1C00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1C40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1C80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1CC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1D00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1D40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1D80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1DC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1E00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1E40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1E80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1EC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1F00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1F40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1F80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1FC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
20C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
21C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2280 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
22C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2300 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2340 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2380 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
23C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2400 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2440 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2480 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
24C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2500 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2540 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2580 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
25C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2600 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2640 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2680 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
26C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2700 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2740 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2780 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
27C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
28C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2900 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2940 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 191
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


2980 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
29C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2A00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2A40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2A80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2AC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2B00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2B40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2B80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2BC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2C00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2C40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2C80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2CC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2D00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2D40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2D80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2DC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2E00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2E40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2E80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2EC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2F00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2F40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2F80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
2FC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
30C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
31C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3280 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
32C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3300 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3340 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3380 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
33C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3400 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3440 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3480 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
34C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3500 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3540 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3580 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
35C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3600 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3640 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3680 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
36C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3700 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3740 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3780 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
37C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
38C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3900 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3940 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3980 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
39C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3A00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 192
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


3A40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3A80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3AC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3B00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3B40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3B80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3BC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3C00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3C40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3C80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3CC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3D00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3D40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3D80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3DC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3E00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3E40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3E80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3EC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3F00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3F40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3F80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
3FC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
40C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
41C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4280 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
42C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4300 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4340 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4380 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
43C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4400 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4440 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4480 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
44C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4500 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4540 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4580 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
45C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4600 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4640 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4680 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
46C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4700 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4740 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4780 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
47C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
48C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4900 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4940 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4980 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
49C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4A00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4A40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4A80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4AC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 193
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


4B00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4B40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4B80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4BC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4C00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4C40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4C80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4CC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4D00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4D40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4D80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4DC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4E00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4E40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4E80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4EC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4F00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4F40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4F80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
4FC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
50C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
51C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5280 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
52C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5300 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5340 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5380 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
53C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5400 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5440 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5480 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
54C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5500 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5540 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5580 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
55C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5600 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5640 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5680 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
56C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5700 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5740 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5780 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
57C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
58C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5900 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5940 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5980 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
59C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5A00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5A40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5A80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5AC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5B00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5B40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5B80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
MPASM  5.43                        ME2700.ASM   10-4-2016  14:52:52         PAGE 194
ME2700 Programmer Firmware Rev 1.03
Copyright (C) 2016 Martin Eberhard
MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


5BC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5C00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5C40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5C80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5CC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5D00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5D40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5D80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5DC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5E00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5E40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5E80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5EC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5F00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5F40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5F80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
5FC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
60C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
61C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6280 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
62C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6300 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6340 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6380 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
63C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6400 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6440 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6480 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
64C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6500 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6540 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6580 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
65C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6600 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6640 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6680 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
66C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6700 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6740 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6780 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
67C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
68C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6900 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6940 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
6980 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
69C0 : XXXXXXXXXXXXXXXX ---------------- ---------------- ----------------

All other memory blocks unused.

Program Memory Bytes Used: 25040
Program Memory Bytes Free:  7728


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

