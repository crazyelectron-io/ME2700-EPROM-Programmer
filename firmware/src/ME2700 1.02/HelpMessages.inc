;********************************************************************************
; Long Strings 
; These null-terminated strings are too big for the 4k-byte memory space
; reserved for strings that can be printes using printf. These require a
; 16-bit address, and should be printed using the kernel's K_PRINTF routine.
;********************************************************************************
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890
help_msg:	dw	"\r\r"
			dw	"                                  MAIN COMMANDS\r\r"
			dw	"EPROM COMMANDS (?E for help)              FILE TRANSFER COMMANDS (?F for help)\r"
			dw	"  BAO <offset>   Buffer Address Offset      FAO <offset>   File Address Offset\r"
			dw	"  DI {0/1}       Data Invert mode {off/on}  FAO            Automatic FAO mode\r"
			dw	"  EB <adr> <cnt> EPROM Blank check          UI <adr> <cnt> Upload as Intel hex\r"
			dw	"  EC <adr> <cnt> Compare EPROM to buffer    US <adr> <cnt> Upload as S-records\r"
			dw	"  ED <type>      Display EPROM specs        :...           Intel hex record\r"      
			dw	"  EE <type>      Custom EPROM Editor        S...           Motorola S-record\r"
			dw	"  EL             List EPROM Device Types\r"
			dw	"  EP <adr> <cnt> Program EPROM            MISCELLANEOUS COMMANDS\r"
			dw	"  ER <adr> <cnt> Read EPROM into buffer     DS         Display all Settings\r"
			dw	"  ES <adr> <cnt> EPROM checkSum             ECHO {0/1} Terminal Echo {off/on}\r"
            dw  "  ET <type>      Select EPROM Device Type   RESET      Reset programmer\r"
			dw	"                                            ?D         Diagnostic commands\r"
			dw	"BUFFER COMMANDS (?B for help)               ?L         Firmware loader notes\r"      
			dw  "  BD <adr> <cnt> Buffer Display             ?N         General ME2700 notes\r"
			dw	"                   (space to pause)         ^C or ESC  Abort any command\r"
			dw	"  BE <adr>       Buffer Edit (ESC to quit)  ^S, ^Q     Pause, restart Transmit\r"
			dw	"  BF <data>      Buffer Fill\r"
			dw	"All values are in hexidecimal. Offsets, data, and types are 2 digits. Addresses\r"
			dw	"are between 0 and 1FFF. Counts are between 1 and 2000.\r" 
			dw	0
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890

dhelp_msg:	dw	"\r\r"
			dw	"DIAGNOSTIC COMMANDS (Intended for testing the ME2700 only)\r\r"
			dw	"  AVPP {1-4} Adjust Vpp voltage at TP3 {1=12.7V, 2=13.1V, 3=21V, 4=25V}\r"
 			dw	"             Note that Vpp will be about 0.7V higher if it is on pin 18.\r"            
			dw	"  RD         Read from EPROM Data pins\r"
			dw	"  TAS {0/1}  Test -AS pin {inactive/active}\r"
			dw  "  TCS {0/1}  Test CS pin {inactive/active}\r"
			dw	"  THI {0/1}  Test Stuck-High pin {low/high}\r"
			dw	"  TOE {0-2}  Test -OE pin {0=inactive, 1=active, 2=programming state}\r"
			dw	"  TPGM {0/1} Test PGM pin {inactive/active}\r"
 			dw	"  TPROG      Test EPROM programming (scope loop) until ^C or ESC\r"
			dw	"  TREAD      Test EPROM reading (scope loop) until ^C or ESC\r"
			dw	"  TVBD {0/1} Test Vbb & Vdd pins {off/on}\r"
			dw	"  TVCC {0-2} Test Vcc pin {0=inactive, 1=active, 2=programming state}\r"
			dw  "  TVPP {0-3} Test Vpp pin {0=off, 1=read, 2=programming inactive, 3=Vpp}\r"
			dw	"  WA <adr>   Write <adr> to EPROM Address pins\r"
			dw	"  WD <data>  Write <data> to EPROM Data pins\r\r"
			dw	"For active-high signals, 'active' means +5V and 'inactive' means 0V. For\r"
			dw	"active-low signals, 'active' means 0V and 'inactive' means 5V. Use the ED\r"
			dw	"command to see which signals are active-high and which are active-low.\r"
			dw	0
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890

bhelp_msg:	dw	"\r\r"
			dw	"                             BUFFER COMMANDS HELP\r\r"
			dw	"BD displays the buffer contents in both hexidecimal and ASCII. Non-printing\r"
			dw	"ASCII cuaracters are represented by a period. Pause and restart the display\r"
			dw	"with the space bar. Use ESC or ^C to quit.\r\r"
			dw	"BE allows you to edit the buffer contents, one byte at a time. The address and\r"
			dw	"data for the specified address are displayed. If you type a hex value followed\r"
			dw	"by <return>, then that value will replace the buffer data. If you just type\r"
			dw	"<return>, then the buffer data will remain unchanged. After you type <return>,\r"
			dw	"the data from the next address will be displayed, allowing you to modify it\r"
			dw	"next. You can continue to view and edit sequential buffer data until you type\r"
			dw	"ESC or ^C. If you continue past address 1FFF, then the address will wrap to 0.\r\r"
			dw	"BF fills the entire buffer with the specified data byte.\r\r"
			dw	"<adr> are hex, from 0 to 1FFF, defaulting to 0. <cnt> are hex, from 1 to 2000,\r"
			dw	"defaulting to 2000. <data> are hex, from 0 to FF, defaulting to 0.\r"
			dw	0
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890

notes2700:	dw  "\r\r"
			dw	"                                Orphan EPROMs\r"
			dw	"   There was a lot of wrangling about pinouts among the EPROM manufacturers\r"
			dw	"until the JEDEC standard was adopted, leading to incompatible variants of the\r"
			dw	"24-pin EPROMs. These EPROMs had not only incompatible pinouts, but some were\r"
			dw	"powered by just +5 volts, while other also required -5 volts and +12 volts. On\r"
			dw	"some, the write pulse was a digital pulse on either a dedicated PGM pin or on\r"
			dw	"the Chip Enable pin, while others required the high-voltage Vpp signal to be\r"
			dw	"pulsed to write each byte. The programming algorithms also varied wildly, from\r"
			dw	"a single pulse (of various lengths) per byte to many passes through the entire\r"
			dw	"EPROM. While the JEDEC standard did solve the pinout problem (mostly), the\r"
			dw	"programming algorithms continued to proliferate, with each manufacturer\r"
			dw	"inventing it own 'Smart', 'Fast, 'Quick','Rapid', or whatever algorithm.\r"
			dw	"   The ME2700 was designed in particular to program most non-JEDEC EPROMs,\r"
			dw	"which are seldom supported by 'universal' EPROM programmers. It can handle\r"
			dw	"single, dual, or 3-voltage EPROMs, and a wide variety of pinouts, programming\r"
			dw	"voltages, and special voltage requirements on other pins. Of course, it can\r"
			dw	"also program the 24-pin JEDEC-standard EPROMs (and several EEPROMS) too. And\r"
			dw	"within the limitations of the hardware, you can define four custom EPROM types\r"
			dw	"to program EPROMs that were not considered when this firmware was written.\r"
			dw	"                                                      -Martin Eberhard\r\r"
			dw	"This design Copyright (c) 2016 Martin Eberhard - like anyone would steal it."
			dw	0
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890


ehelp_msg:	dw	"\r\r"
			dw	"                             EPROM COMMANDS HELP\r\r"
			dw	"Use EL for a list of the supported EPROM Device Types. Choose a Device Type\r"
			dw	"with the ET command. ED will display details about an EPROM Device Type, and\r"
			dw	"also a list of manufacturer's part numbers for EPROMs of that Device Type.\r"
			dw	"These lists of part numbers are not complete (particulary for the common EPROMs\r"
			dw	"such as the 2708 and the 2716). Look at your EPROM's datasheet and find the\r"
			dw	"correct Device Type, if it is not listed. Use the Custom EPROM Editor to create\r"
			dw	"a new EPROM Type if none match your EPROM.\r\r"
			dw	"For these commands, <adr> is the (4-digit hex) beginning address and <cnt> is\r"
			dw	"the (4-digit hex) byte count for the for the operation. <adr> defaults to 0000.\r"
			dw	"<cnt> defaults to the entire EPROM size, which depends on the selected type.\r\r"
			dw	"The Buffer Address Offset (set with the BAO command) is added to the high byte\r"
			dw	"of the EPROM's address to compute the buffer address for read, compare, and\r"
			dw	"program operations. This allows you to choose where in the buffer to put EPROM\r"
			dw	"read data, and from where in the buffer to get EPROM programming data.\r\r"
			dw	"The DI command is useful when your EPROM is used in a system with inverted\r"
			dw	"data. When DI is enabled, data are inverted when written to the EPROM and when\r"
			dw	"read back from the EPROM.\r"
			dw	0

;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890
fhelp_msg:	dw	"\r\r"
			dw	"                         FILE TRANSFER COMMANDS HELP\r"
			dw	"Transfer files to and from the buffer in Intel Hex or Motorola S-record format.\r"
			dw	"UI and US upload buffer data in Intel Hex and Motorola S-record formats. If no\r"
			dw	"<cnt> value is provided, then the byte count will be the size of the currently\r"
			dw	"selected EPROM Type. No special command is needed to download to the buffer:\r"
			dw	"the hex records themselves are recognized. Downloaded records will generate an\r"
			dw	"error for the following reasons:\r"
			dw	" ERROR CODE        ERROR\r"
			dw	"   ? Cnt      S5 record-count mismatch (Motorola S-records only)\r"
			dw	"   ? Csm      Checksum error\r"
			dw	"   ? Hex      Illegal hexadecimal character\r"
			dw	"   ? Rec      Unsupported record type\r\r"
			dw	"The File Address Offset (set with the FAO command) affects the upper byte of\r"
			dw	"each record's 2-byte address. For downloads, the File Address Offset is\r"
			dw	"subtracted from the upper address byte of each received record. For uploads,\r"
			dw	"the File Address Offset is added to the upper address byte in each record.\r\r"
			dw	"FAO with no parameter resets the File Address Offset to its default. For\r"
			dw  "uploads, the default is 00. For downloads, the default is the high address byte\r"
			dw	"from the first received record. Received data will not be written to the buffer\r"
			dw	"if the resulting address high byte is greater than 1F.\r"
			dw	0
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890

lhelp_msg:	dw	"\r\r"
			dw	"                             THE FIRMWARE LOADER\r\r"
			dw	"This firware can be loaded via the ME2700 serial port. To invoke the Loader,\r"
			dw	"type capital 'L' a few times immediately after power on, or immediately after\r"
			dw	"issuing a RESET command. You should see the ME Loader prompt instead of the\r"
			dw	"ME2700 banner.\r\r"
			dw	"IMPORTANT: The Loader requires your terminal program to accept XON/XOFF\r"
			dw	"handshaking. The loader expects an Intel hex file exactly as produced by the\r"
			dw	"Microchip MPASM assembler. (The firmware must be written to be compatible with\r"
			dw	"the ME Loader Kernel version 1.x, not documented here.)  Once you see the\r"
			dw	"ME Loader prompt, send the Intel hex firmware file to the ME2700. It will take\r"
			dw	"a while to load. When it is done, the error count must be 0000 - otherwise, the\r"
			dw	"firmware is probably corrupted.\r\r"
			dw	"Note that a bad firmware load will corrupt the ME2700 firmware, but it will not\r"
			dw	"corrupt the Loader. Even with corrupted firmware, you can type a few 'L's\r"
			dw	"immediately after powering on, to invoke the Loader and try again.\r\r"
			dw	"You can exit the Loader and run the loaded firmware either by power-cycling the\r"
			dw	"ME2700 or by typing the ESC key three times in succession.\r" 
			dw	0
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890

eemenu_msg:	dw	"\r\r"
			dw	"CUSTOM EPROM EDITOR GENERAL COMMANDS\r\r"
			dw	"  ?           Reprint this menu\r"
			dw	"  ?A          Pin Assignment command menu\r"
			dw	"  ?P          Programming Parameter command menu\r"
			dw	"  COPY <type> Copy EPROM Device Type\r"
			dw	"  DELETE      Delete EPROM Device Type\r"
			dw	"  ED          Display EPROM Details\r"
			dw	"  EN <name>   Name EPROM Device Type\r"
			dw	"  TPROG       Test EPROM programming (scope loop) until ^C or ESC\r"
			dw	"  TREAD       Test EPROM reading (scope loop) until ^C or ESC\r"
			dw	"  Q           Quit to main menu\r"
			dw	0

;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890
eamenu_msg:	dw	"\r\r"
			dw	"CUSTOM EPROM EDITOR PIN ASSIGNMENT COMMANDS\r\r"
			dw	"  A9 {0,18-22}     A9 Pin\r"
			dw	"  A10 {0,18-22}    A10 Pin\r"
			dw	"  A11 {0,18-22}    All Pin (overrides Stuck-High signal)\r"
			dw	"  A12 {0,18-22}    A12 Pin (overrides -AS)\r"
			dw	"  ASN {0,18-22}    -AS Pin (overrides A12)\r"  
			dw	"  CS {0,18-22}     CS Pin\r" 
			dw	"  CSP {0/1}        CS Polarity {-/+}\r"
			dw	"  HI {0,18-22}     Stuck-High pin (overrides A11)\r" 
			dw	"  OEN {0,18-22}    -OE Pin\r"
			dw	"  PGM {0,18-22}    PGM Pin (WE pin for EEPROMs)\r"
			dw	"  PGP {0/1}        PGM Polarity {-/+}\r"
			dw	"  PPP {0,18,20,21} Vpp Pin\r"
			dw	"  VBB {0/1}        Assign -5V Vbb to pin 21 {no/yes}\r"
			dw	"  VDD {0/1}        Assign +12V Vdd to pin 19 {no/yes}\r\r"
			dw  "If more than one signal is assigned to the same pin, then the last assignment\r"
			dw	"will supersede prior assignments. Exceptions: Vpp may share the same pin as -OE\r"
			dw	"or CS. PGM may share the same pin as -OE or CS. Unassigned pins are stuck-low.\r"
			dw	0
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890

epmenu_msg:	dw	"\r\r"
			dw	"CUSTOM EPROM EDITOR PROGRAMMING PARAMETER COMMANDS\r\r"
			dw	"  BCK {0/1} Blank check {disabled/enabled} (disable for e.g. EEPROMs)\r"
			dw	"  FF1 {0/1} Fast pass 1 data=FFh {no/yes} (for EEPROM erase)\r"
			dw	"  FN1 <n>   'n' value for Fast Pass 1 (0<n<7)\r" 
			dw	"  FN2 <n>   'n' value for Fast Pass 2 (0<n<7)\r"
			dw	"  FP1 {0-5} Define Fast Pass 1-{  0: P+n        1: P, then one n*PPW pulse\r"
			dw	"  FP2 {0-5} Define Fast Pass 2-{  2: P+nP       3: P, then one n*P*PPW pulse\r"
			dw	"                               {  4: n pulses   5: one n*PPW pulse\r"
			dw	"  OEV {0/1} Set -OE to +12V during programming {no/yes}\r"
			dw	"  PMX <max> Fast algorithm maximum P, or SPA pass count (0 to 255)\r"
			dw	"  POL {0/1} EEPROM-style write-completion polling {no/yes}\r" 
			dw	"  PPS <t>   Pulse separation (<t> = 0 to 127, 0 means minimum)\r"  
			dw	"  PPW <t>   Pulse width (<t> = 0 to 127, 0 means ~350 nS)\r"
			dw	"  PTU {0/1} PPS and PPW time units: {10 uS/1 mS}\r"
			dw	"  PUL {0-2} Program Pulse signal: {0=Vpp/0V, 1=Vpp/5V, 2=PGM}\r"
			dw	"  SPA       Use Simple Program Algorithm (not a Fast algorithm)\r"
			dw	"  VCP {0-3} Vcc during prog: {0=0V, 1=5V, 2=6.2V, 3=12V}\r"
			dw	"  VPP {0-5} Vpp Programming voltage\r"
			dw	"            Vpp pin 18: {0V, 13.4V, 13.8V, 21.7V, 25.9V, Ext. negative supply}\r"
			dw	"            Vpp pins 19-21: {0V, 12.7V, 13.1V, 21V, 25.2V, not allowed}\r"
			dw	"  VPR {0/1} Vpp when reading the EPROM: {0V/5V}\r"
			dw	0
;				 12345678901234567890123456789012345678901234567890123456789012345678901234567890


