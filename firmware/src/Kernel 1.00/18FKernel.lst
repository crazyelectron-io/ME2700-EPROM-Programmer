MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001     title "EPROM Programmer Kernel Rev PIC18 1.00"
                      00002     subtitle "Copyright (C) 2015 Martin Eberhard"
                      00003     list b=4, c=132, n=80
                      00004 
                      00005 ;********************************************************************************
                      00006 ;* EPROM Programmer Loader Kernel                                               *
                      00007 ;* Written for both the ME2700 EPROM programmer                                 *
                      00008 ;* designed to work with the PIC18F44K20 or the PIC18F45K20                     *
                      00009 ;*                                                                              *
                      00010 ;*Revision    Date        Author         Comments                               *
                      00011 ;*  1.00    20SEP2015   M.Eberhard  Created                                     *
                      00012 ;*                                                                              *
                      00013 ;* To Do (maybe)                                                                *
                      00014 ;*   Use serial RAM to hold entire code image before writing to Flash           *
                      00015 ;********************************************************************************
                      00016 ; Major revision must change if the firmware is not fully compatable with       *
                      00017 ; previous revisions.                                                           *
                      00018 ;********************************************************************************
  00000001            00019 REV_MAJOR       equ 0x01        ;major revision number
  00000000            00020 REV_MINOR       equ 0x00        ;minor revision number
                      00021 
  000000FF            00022 TRUE    equ     0xff
  00000000            00023 FALSE   equ     0
                      00024 
                      00025     errorlevel 1        ;eliminate all the 'not in bank 0' messages
                      00026 
                      00027 ;********************************************************************************
                      00028 ;*                              GENERAL NOTES                                   *
                      00029 ;*                                                                              *
                      00030 ;* This Loader Kernel allows EPROM programmer firmware to be loaded via the     *
                      00031 ;* serial port and written to the PIC's FLASH memory, without any development   *
                      00032 ;* hardware (such as a PICkit 3). It also provides some useful subroutines for  *
                      00033 ;* the EPROM programmer, reusing code needed for the loader. All of these       *
                      00034 ;* available subroutines can be accessed via a fixed-location jump table.       *
                      00035 ;*                                                                              *
                      00036 ;* Firmware load is via Intel Hex file, as produced by the Microchip's MPASM    *
                      00037 ;* (version 8.83). Unfortunately, the RAM in the PIC microcontroller is too     *
                      00038 ;* small to hold the entire firmware, so downloaded firmware is written into    *
                      00039 ;* FLASH as it is received. Any Intel Hex errors, as well as read-back verify   *
                      00040 ;* errors, will be reported - but these errors will likely result in corrupted  *
                      00041 ;* firmware. However, this entire kernel is protected (by 'boot' protection in  *
                      00042 ;* configuration register CONFFIG2) and cannot be overwritten. So you can try   *
                      00043 ;* reloading the firmware if it fails to load the first time.                   *
                      00044 ;*                                                                              *
                      00045 ;* This program must be no more than 2048 bytes long - the amount of FLASH that *
                      00046 ;* is protected by the 'boot' protection in config2. If the code is larger than *
                      00047 ;* 2048 bytes, then an error will be generated when assembled.                  *                       
                                                                                    *
                      00048 ;* The EPROM programmer firmware should load at address 0x800 (LOADED_CODE).    *
                      00049 ;* This program installs a dummy program there, which will be over-written when *
                      00050 ;* programmer code is loaded via the serial port.                               *
                      00051 ;*                                                                              *
                      00052 ;* To invoke the loader, lean on the 'L' key (so that it auto-repeats), and     *
                      00053 ;* then turn on the EPROM programmer. You should see the Loader message instead *
                      00054 ;* of the EPROM programmer's sign-on message.                                   *
                      00055 ;*                                                                              *
                      00056 ;* To leave the loader and run the loaded firmware, type 3 or more ESCs at the  *
                      00057 ;* loader prompt. (ESCs will be ignored while a file is loading.)               *
                      00058 ;*                                                                              *
                      00059 ;* Note that the PIC gets partially initialized by this loader. The programmer  *
                      00060 ;* firmware needs to initialize everything else.                                *
                      00061 ;*                                                                              *
                      00062 ;* This program assumes the PIC is clocked at 16 MHz, meaning a 4 MHz CPU       *
                      00063 ;* operating speed, or 0.25 uS instruction cycle time. The internal oscilator   *
                      00064 ;* has an accuracy of +/- 10%, which must be considered in all timing.          *
                      00065 ;*                                                                              *
                      00066 ;* Page references in the comments refer to the appropriate pages in Microchip  *
                      00067 ;* document DS40001303H "PIC18F2XK20/4XK20 28/40/44-Pin Flash Microcontrollers  *
                      00068 ;* with XLP Technology"                                                         *
                      00069 ;********************************************************************************
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  2
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00070     page
                      00071 ;********************************************************************************
                      00072 ;* CALL Vectors for External Code Subroutine Access                             *
                      00073 ;* Address  Vector           Notes                                              *
                      00074 ;*  0000    RESET           Cold Reset (not meant to be called)                 *
                      00075 ;*  0002    K_KERN_REV      get Loader Kernel firmware revision level in W      *
                      00076 ;*  0004    K_PROG_ID       returns W = 00                                      *
                      00077 ;*  000A    K_CONIN         get one Rx Queue chr into W & R0. Z set if empty    *
                      00078 ;*                          trashes FSR0                                        *
                      00079 ;*  000C    K_CONOUT        Send W to console (returns chr in R0, trashes FSR0) *
                      00080 ;*  000E    K_PRINTF        print 0-terminated string at TBLPTRH:TBLPTRL        * 
                      00081 ;*                          trashes W,R0,R1,R2,FSR0,TBLPTRL,TBLPTRH,TABLAT      *
                      00082 ;*  0010    K_EEPRINT       print 0-terminated string at EEADR from EEPROM.     *
                      00083 ;*                          Trashes R0,FSR0,READR.                              *
                      00084 ;*  0012    K_PRINTHEX1     print low nibble of W as 1 hex chr. Trashes R0,FSR0 *
                      00085 ;*  0014    K_PRINTHEX2     print W as 2 hex chrs. Trashes R0,R1,FSR0           *
                      00086 ;*  0016    K_PRINTDEC      print R1:R0 in decimal, leading zeros suppressed.   *
                      00087 ;*                          trashes W,R0,R1,PRODH,PRODL,FSR0,INP_FLAG           *
                      00088 ;*  0018    K_PRINTSN       print this unit's serial number. Trashes FSR0.      *
                      00089 ;*  001A    K_HEX2BIN       Convert hex value in R0 to binary, combine it with  *
                      00090 ;*                          nibble already in R1. On return, R0=new binary      *
                      00091 ;*                          nibble; R1=W=combined nibbles                       *
                      00092 ;*  001C    K_GETLIN        Get null-terminated input line from user            *
                      00093 ;*  001E    K_PARSE         Parse table at TBLPTR looking for command at FSR1   *
                      00094 ;*  0020    K_GETCHR        Get next chr from LINEBUF at FSR1, Result in W      *
                      00095 ;*                          and R0. FSR1 incremented.                           *
                      00096 ;*  0022    K_GETUCHR       Get next chr from LINEBUF at FSR1, convert to       *
                      00097 ;*                          uppercase. Result in W and R0. FSR1 incremented.    *
                      00098 ;*  0024    K_GETDEC        Get decimal value from LINBUF. Result in W & PRODL. *
                      00099 ;*                          trashes R0                                          *
                      00100 ;*  0026    K_GETHEX2       Get 2-digit hex chr with checksum                   *
                      00101 ;*  0028    K_GETHEX4       Get 4-digit hex value from LINBUF at FSR1. Result   *
                      00102 ;*                          in R2:R1, Trash W,R0                                *
                      00103 ;*  002A    K_ASKYN         ask user Y/N. Z set if Y, clear if N. Trashes FSR0  *
                      00104 ;*  002C    K_CHKABORT      check for user abort. Z if no chr, C if abort,      *
                      00105 ;*                          received chr in W and R0, if any.                   *
                      00106 ;*  002E    K_RDSRAM        read SRAM byte at ADDRESSH:ADDRESSL, Result in W.   *
                      00107 ;*                          Trashes R0.                                         *
                      00108 ;*  0030    K_WRSRAM        write W to SRAM at ADDRESSH:ADDRESSL.               *
                      00109 ;*                          Trashes W ,R0, R1.                                  *
                      00110 ;*  0032    K_RDEEPROM      read EEPROM byte at address W, result in W          *
                      00111 ;*  0034    K_WREEPROM      write W to EEPROM at address EEADR                  *
                      00112 ;* Reserved 2 slots for future commands here                                    *
                      00113 ;*  003A    K_STALL25M      stall for W * 25 mSec (trashes R0 & R1)             *
                      00114 ;*  003C    K_STALL250U     stall for W * 250 uSec (trashes R0)                 *
                      00115 ;*  003E    K_STALL1U       stall for W + 1 uSec                                *
                      00116 ;*                                                                              *
                      00117 ;*  0800    LOADED_CODE     beginning of serial port-loaded programmer code     *
                      00118 ;********************************************************************************
                      00119 ;* Kernel Initialization                                                        *
                      00120 ;*                                                                              *
                      00121 ;*  # The PIC configuration registers are initialized. Note that this loader    *
                      00122 ;*    will not allow you to change the configuration registers.                 *
                      00123 ;*  # The oscillator is initialized.                                            *
                      00124 ;*  # The Vpp switcher components are initialized, with the PWM off.            *
                      00125 ;*  # The SPI bus is initialized, and the external SPI SRAM is initialized.     *
                      00126 ;*  # Ports are initialized with the UART enabled.                              *
                      00127 ;*  # The transmit and receive queues are initialized.                          *
                      00128 ;*  # The transmit and receive interrupts are active.                           *
                      00129 ;********************************************************************************
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  3
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00130     page
                      00131 ;********************************************************************************
                      00132 ;* Intel Hex Format for Firmware Download                                       *
                      00133 ;*                                                                              *
                      00134 ;*  # Three record types are accepted; all other records are ignored.           *
                      00135 ;*     1) Type 00 records are data records. Data records are written to FLASH   *
                      00136 ;*        only if a Type 04 record has already been received, with extended     *
                      00137 ;*        address = 0000 (for program memory) If no Type 04 record has been     *
                      00138 ;*        received yet, or if the last Type 04 record set the extended address  *
                      00139 ;*        to something other than 0000, then the data record will be ignored.   *
                      00140 ;*        This means (for example) that you cannot write to the EEPROM or the   *
                      00141 ;*        Config registers of the PIC.                                          *
                      00142 ;*                                                                              *
                      00143 ;*     2) A Type 01 record (with 0 bytes of data) is an End-Of-File record, and *
                      00144 ;*        is required at the end of the file to force a write to FLASH of the   *
                      00145 ;*        last RAM buffer full of data. NOTE: a data record with 0 bytes of     *
                      00146 ;*        data is NOT treated as an End-of-file record.                         *
                      00147 ;*     3) Type 04 records set the extended address for the subsequent records.  *
                      00148 ;*        The "address" field of the Type 04 record (bytes 2 and 3) is ignored. *
                      00149 ;*        The first 2 bytes of the "data" field (bytes 5 and 6) set the         *
                      00150 ;*        extended address. MPASM sets the extended address to 0000 for FLASH   *
                      00151 ;*        data, 00F0 for EEPROM, and ???? for the PIC Config registers.         *
                      00152 ;*  # The PIC's FLASH memory is organized in 32-byte "rows".                    *
                      00153 ;*  # The PIC's erase block is 64 bytes long, or two rows long. For this        *
                      00154 ;*    reason, Flash writing is done in pairs of rows.                           *
                      00155 ;*  # This loader assumes that each Intel hex record fits completely within two *
                      00156 ;*    32-byte FLASH rows, for a total of 64 bytes. However, one FLASH row pair  *
                      00157 ;*    may be (probably will be) made up of several hex records.                 *
                      00158 ;*  # If the hex file has data for only part of a FLASH row-pair, then only the *
                      00159 ;*    data supplied in the Hex file will be changed - the other bytes in that   *
                      00160 ;*   FLASH row-pair will remain unchaged, because this program first reads the  *
                      00161 ;*   old FLASH data from each row-pair into its RAM buffer, filling in the      *
                      00162 ;*    missing data for that row-pair.                                           *
                      00163 ;*  # After each row-pair is written, it is read back and verified.             *
                      00164 ;*  # The checksum is checked for all records, including ignored records.       *
                      00165 ;*  # The following conditions will generate an error message, and increment    *
                      00166 ;*    error count that is reported after the end of the file:                   *
                      00167 ;*     1) Checksum Error                                                        *
                      00168 ;*     2) Bad Hex Error (something besides 0-9 or A-F when expecting hex)       *
                      00169 ;*     3) Verify Error (FLASH readback did not match the RAM buffer data)       *
                      00170 ;*  # A pair of FLASH writes occur when a new hex record addresses FLASH memory *
                      00171 ;*    in a different FLASH row-pair than the previous record, or when a type 01 *
                      00172 ;*    record is received. This means that FLASH write verification occurs after *
                      00173 ;*    the address and record-type fields of a hex data record have been         *
                      00174 ;*    received, and before the data bytes are received. And this means that if  *
                      00175 ;*    a verify fails, the verify error message will be printed in the middle of *
                      00176 ;*    a hex record, and will refer to the previous record(s).                   *
                      00177 ;*  # All characters are ignored until a colon (marking the start of an Intel   *
                      00178 ;*    hex record) has been received. This means that comment lines in the Intel *
                      00179 ;*    hex file will be ignored. This also means that any record where the       *
                      00180 ;*    initial colon has been corrupted will be ignored without being caught as  *
                      00181 ;*    an error.                                                                 *
                      00182 ;*  # Receipt of a type 01 record (End-Of-File) causes the following actions:   *
                      00183 ;*     1) The total number of records loaded into the FLASH is printed. This    *
                      00184 ;*        can be checked manually, to make sure no records were dropped, and    *
                      00185 ;*        the load was in fact successful.                                      *
                      00186 ;*     2) The total number of errors detected is printed. Anything other than   *
                      00187 ;*        0000 means that the load was unsuccesful, and the loaded code should  *
                      00188 ;*        not be trusted.                                                       *
                      00189 ;*     3) control returns to the loader, reprinting the loader's brief sign-    *
                      00190 ;*        on message. (To run the new code, hit the ESC key 3 times in a row)   *
                      00191 ;********************************************************************************
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  4
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00192     page
                      00193 ;********************************************************************************
                      00194 ;* Include standard headers, programmer header, and macros                      *
                      00195 ;********************************************************************************
                      00196     #include    P18F45K20.INC
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ;  MPASM PIC18F45K20 processor include
                      00005 ; 
                      00006 ;  (c) Copyright 1999-2011 Microchip Technology, All rights reserved
                      00007 ;==========================================================================
                      00008 
                      01568         LIST
                      00197     #include    ASCII.inc
                      00013     list
                      00198     #include    18FKernelMemory.inc
                      00001 ;* RAM Usage: RAM allocations are assigned to be compatible with the EPROM      *
                      00002 ;* programmer firmware.                                                         *
                      00003 ;********************************************************************************
                      00004 
                      00005 ;Code Space assignments (from Kernel)
  00000002            00006 K_KERN_REV      equ 0x0002  ;return kernal loader major rev and minor rev in high & low nibbles of W
  00000004            00007 K_PROG_ID       equ 0x0004  ;return programmer ID in W. 00 for now.
  0000000A            00008 K_CONIN         equ 0x000A  ;get one chr from Rx Queue into W & R0. Z set if empty. Trashes FSR0.
  0000000C            00009 K_CONOUT        equ 0x000C  ;print W (returns chr in R0 unless chr was CR. Trashes FSR0.)
  0000000E            00010 K_PRINTF        equ 0x000E  ;print 0-terminated string at TBLPTRH:TBLPTRL. Trashes R0,FSR0,TBLPTR
  00000010            00011 K_EEPRINT       equ 0x0010  ;print 0-terminated string from EEPROM at EEADR, Trashes R0,FSR0,READR
  00000012            00012 K_PRINTHEX1     equ 0x0012  ;print low nibble of W as 1 hex chr. trashes R0,FSR0
  00000014            00013 K_PRINTHEX2     equ 0x0014  ;print W as 2 hex chrs. Trashes R0,R1,FSR0
  00000016            00014 K_PRINTDEC      equ 0x0016  ;print R1:R0 in decimal, leading zeros suppressed. Trash W,R0,R1,R2,FSR0,PRO
                            DH,PRODL
  00000018            00015 K_PRINTSN       equ 0x0018  ;print this unit's serial number. Trashes FSR0.
  0000001A            00016 K_HEX2BIN       equ 0x001A  ;Convert hex value in R0 to binary, combine it with R1. Trashes FSR0.
  0000001C            00017 K_GETLIN        equ 0x001C  ;Get W-byte null-terminated input line from user. Returns FSR1= LINBUF
  0000001E            00018 K_PARSE         equ 0x001E  ;Search cmd table at TBLPTR for cmd at FSR0, return W=cmd index
  00000020            00019 K_GETCHR        equ 0x0020  ;Get next LINBUF chr at FSR1. Result in W and R0
  00000022            00020 K_GETUCHR       equ 0x0022  ;Get next LINBUF chr at FSR1 and convert to uppercase. Result in W & R0
  00000024            00021 K_GETDEC        equ 0x0024  ;Get 8-bit decimal value from LINBUF at FSR1. Result in W & PRODL. Trash R0
  00000026            00022 K_GETHEX2       equ 0x0026  ;Get 2-digit hex, result in W & R1, sum in CHECKSUM, Z set if CHECKSUM=0
  00000028            00023 K_GETHEX4       equ 0x0028  ;Get 4-digit hex value from LINBUF at FSR1. Result in R2:R1. Trash W,R0
  0000002A            00024 K_ASKYN         equ 0x002A  ;ask user Y/N. Z set if Y, cleared if N. Trashes FSR0.
  0000002C            00025 K_CHKABORT      equ 0x002C  ;Check for user abort. Z if no chr, C if abort, chr in W and R0
  0000002E            00026 K_RDSRAM        equ 0x002E  ;read SRAM byte at ADDRESSH:ADDRESSL, Result in W, trash R0
  00000030            00027 K_WRSRAM        equ 0x0030  ;write W to SRAM at ADDRESSH:ADDRESSL. Trashes W R0,R1
  00000032            00028 K_RDEEPROM      equ 0x0032  ;read EEPROM byte at address W, result in W
  00000034            00029 K_WREEPROM      equ 0x0034  ;write W to EEPROM at address EEADR
                      00030 ;2 slots reserved here
  0000003A            00031 K_STALL25M      equ 0x003A  ;stall for W * 25 mSec (trashes R0,R1
  0000003C            00032 K_STALL250U     equ 0x003C  ;stall for W * 250 uSec (trashes R0)
  0000003E            00033 K_STALL1U       equ 0x003E  ;stall for W + 1 uSec
                      00034 
  00000800            00035 LOADED_CODE     equ 0x800       ;beginning of main programmer code
                      00036 
                      00037 ;*--------------------------------------------------------------*
                      00038 ;* Access RAM usage (visible from every bank)                   *
                      00039 ;* Those entries marked with (K) are fixed locations that are   *
                      00040 ;* accessible from the downloaded firmware.                     *
                      00041 ;* Those marked with (I) are used by the interrupt service      *
                      00042 ;* routines.                                                    *
                      00043 ;*--------------------------------------------------------------*
  00000000            00044 RQ_IPTR     equ 0x00        ;(K)(I)points to first empty slot in receive queue
                      00045                             ;(Written only by Rx interrupt!)
  00000001            00046 RQ_OPTR     equ 0x01        ;(K)(I)points to oldest chr in receive queue
  00000002            00047 TQ_IPTR     equ 0x02        ;(K)(I)points to first empty slot in transmit queue
  00000003            00048 TQ_OPTR     equ 0x03        ;(K)(I)points to oldest chr in transmit queue
                      00049                             ;(Written only by Tx interrupt!)
  00000004            00050 CHECKSUM    equ 0x04        ;checksum for current hex record
  00000005            00051 ADDRESSL    equ 0x05        ;address low byte
  00000006            00052 ADDRESSH    equ 0x06        ;address high byte
  00000007            00053 RECOUNTL    equ 0x07        ;low byte of count of hex records
  00000008            00054 RECOUNTH    equ 0x08        ;high byte of count of hex records
  00000009            00055 ERRCNTL     equ 0x09        ;16-bit error counter
  0000000A            00056 ERRCNTH     equ 0x0A
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  5
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00057 
  0000000B            00058 INT_FLAGS   equ 0x0B        ;(K)(I)flags used by int service routines and kernel routines
  00000000            00059 XOFF_STATE      equ 0x00        ;(K)transmitter stopped due to XOFF state
  00000001            00060 TQ_EMPTY        equ 0x01        ;(K)tx queue is empty
  00000002            00061 PREV_CR         equ 0x02        ;(K)Previous received chr was a CR (used by rx int)
  00000003            00062 PREV_LF         equ 0x03        ;(K)Previous received chr was a LF (used by rx int)
  00000004            00063 RQ_FULL         equ 0x04        ;(K)Receive queue full
                      00064 
  0000000C            00065 KERN_FLAGS  equ 0x0C        ;(K)flags used by int service routines and kernel routines
  00000000            00066 ERR_FLAG        equ 0x00        ;(K)generic error flag
  00000001            00067 FLASH_MEM       equ 0x01        ;'FLASH memory has been selected' state bit (only during code load)
  00000001            00068 INP_FLAG        equ 0x01        ;(K)input value found (never during code load)
  00000002            00069 ECHO_FLAG       equ 0x02        ;(K)Echo enabled when set
  00000003            00070 CR_FLAG         equ 0x03        ;(K)CR detected in LINBUF
                      00071 
  0000000D            00072 R0              equ 0x0D        ;general purpose registers
  0000000E            00073 R1              equ 0x0E
  0000000F            00074 R2              equ 0x0F        ;Other header files assume that R2 is the last one
                      00075 
                      00076 ;*--------------------------------------------------------------*
                      00077 ;* Linear-memory buffers                                        *
                      00078 ;* Those entries marked with (K) are fixed locations that are   *
                      00079 ;* accessible by from the downloaded firmware.                  *
                      00080 ;* The PIC18F44K20 has 768 bytes of SRAM. The first 96 bytes    *
                      00081 ;* map to the Access Bank.                                      *
                      00082 ;*--------------------------------------------------------------*
                      00083 ;Input line buffer
  00000060            00084 LINBUF          equ     .96                 ;just past the Access Bank
  00000050            00085 MAXLIN          equ     .80                 ;max input line size
                      00086 
                      00087 ;transmit queue (must be on (TQ_SIZE*2)-byte boundary)
  000000E0            00088 TX_QUEUE        equ     0xE0                ;(K) 16-byte transmit queue
  00000010            00089 TQ_SIZE         equ     0x10
                      00090 
                      00091 ;receive buffer (must be on RQ_SIZE-byte boundary)
  00000100            00092 RX_QUEUE        equ     0x100               ;(K) 256-byte receive buffer
  00000100            00093 RQ_SIZE         equ     0x100
                      00094 
                      00095 ;General purpose RAM buffer, used during code load here 
  00000200            00096 RAM_BUF         equ     0x200           ;(must be on 256-byte boundary)
  00000100            00097 RAMBUF_SIZ      equ     0x100           ;256-byte RAM buffer
                      00098 
                      00099 ;*--------------------------------------------------------------*
                      00100 ;* Internal EEPROM allocation                                   *
                      00101 ;*--------------------------------------------------------------*
  00000000            00102 EE_INIT         equ     0x00                    ;initialized string
  00000014            00103 EE_INITLEN      equ     .20                     ;Room for loader_msg
                      00104 
  00000014            00105 EE_SN           equ     EE_INIT+EE_INITLEN      ;Serial number
  00000008            00106 EE_SNLEN        equ     .8                      ;Length of serial number
                      00107 
  0000001C            00108 EE_VARBEG       equ     EE_SN+EE_SNLEN          ;beginning of variables
  000000E4            00109 EE_VARLEN       equ     .256-EE_VARBEG          ;room for variables
                      00110 
                      00111 
                      00112 
                      00199     #include    18FKernel.inc
                      00001 ;********************************************************************************
                      00002 ;* Kernel Header File                                                           *
                      00003 ;*                                                                              *
                      00004 ;* Page references in the comments refer to the appropriate pages in Microchip  *
                      00005 ;* document DS40001303H "PIC18F2XK20/4XK20 Data Sheet"                          *
                      00006 ;********************************************************************************
                      00007 
                      00008 ;*----------------------------------------------*
                      00009 ;Configuration Register setup
                      00010 ;*----------------------------------------------*
08 00 1E 07 80 0F C0 000011     config  FOSC=INTIO67        ;Internal oscillator block (Page 283)
       F 80 0F 40 
                      00012     config  FCMEN=OFF           ;Disable failsafe clock monitor
                      00013     config  IESO=OFF            ;Disable oscillator switchover mode
                      00014 
                      00015     config  PWRT=ON             ;Power-up timer enabled (Page 284)
                      00016     config  BOREN=OFF           ;Brownout reset disabled
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  6
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00017     config  BORV=30             ;Brownout reset voltage=3.0V (don't care)
                      00018 
                      00019     config  WDTEN=OFF           ;Watchdog timer disabled (Page 284)
                      00020     config  WDTPS=32768         ;Watchdog timer postscale (don't care)
                      00021 
                      00022     config  CCP2MX=PORTC        ;CCP2 output on port bit C1 (Page 285)
                      00023     config  PBADEN=ON           ;Port B bits <4-0> inputs configured as analog
                      00024     config  LPT1OSC=ON          ;Timer 1 configured for low-power operation
                      00025     config  HFOFST=OFF          ;HFINTOSC output & ready status delayed until osc stable
                      00026     config  MCLRE=OFF           ;MCLR pin disabled
                      00027 
                      00028     config  STVREN=OFF          ;disable stack overflow reset (Page 285)
                      00029     config  LVP=OFF             ;Single-supply programming disabled
                      00030     config  XINST=OFF           ;Disable extended instruction set
                      00031     config  DEBUG=OFF           ;Disable debugger
                      00032 
                      00033     config  CP0=OFF             ;Disable code protection block 0 (Page 286)
                      00034     config  CP1=OFF             ;Disable code protection block 1
                      00035     config  CP2=OFF             ;Disable code protection block 2
                      00036     config  CP3=OFF             ;Disable code protection block 3
                      00037 
                      00038     config  CPB=OFF             ;Disable boot-block code protection (Page 286)
                      00039     config  CPD=OFF             ;Disable EEPROM protection
                      00040 
                      00041     config  WRT0=OFF            ;Disable write protection block 0 (Page 287)
                      00042     config  WRT1=OFF            ;Disable write protection block 1
                      00043     config  WRT2=OFF            ;Disable write protection block 2
                      00044     config  WRT3=OFF            ;Disable write protection block 3
                      00045 
                      00046     config  WRTC=ON             ;Enable configuration register write protect (Page 287)
                      00047     config  WRTB=ON             ;Enable boot-block write protect
                      00048     config  WRTD=OFF            ;Disable data EEPROM write protect
                      00049 
                      00050     config  EBTR0=OFF           ;Disable block 0 table-read protection (Page 288)
                      00051     config  EBTR1=OFF           ;Disable block 1 table-read protection
                      00052     config  EBTR2=OFF           ;Disable block 2 table-read protection
                      00053     config  EBTR3=OFF           ;Disable block 3 table-read protection
                      00054 
                      00055     config  EBTRB=OFF           ;Disable boot-block table-read protection (Page 288)
                      00056 
                      00057 ;*------------------------------------------------------------------------*
                      00058 ; I/O Port A Initialization Values (Page 113)
                      00059 ;  Bit  Name            Dir         Function        Use
                      00060 ;   0   M25V        Analog Input    C12IN0-     25-volt compare
                      00061 ;   1   M21V        Analog Input    C12IN1-     21-volt compare
                      00062 ;   2   P18_0       Output          RA2         Pin 18 Control:
                      00063 ;   3   P18_1       Output          RA3         00 = TTL low
                      00064 ;                                               01 = TTL high
                      00065 ;                                               10 = -40V (Interil option req'd)
                      00066 ;                                               11 = Vpp
                      00067 ;
                      00068 ;   4   P19_0       Output          RA4         Pin 19 Control:
                      00069 ;   5   P19_1       Output          RA5         00 = TTL low
                      00070 ;                                               01 = TTL high
                      00071 ;                                               10 = +12V
                      00072 ;                                               11 = N/A (TTL high)
                      00073 ;
                      00074 ;   6   P20_0       Output          RA6         Pin 20 Control:
                      00075 ;   7   P20_1       Output          RA7         00 = TTL 0
                      00076 ;                                               01 = TTL 1
                      00077 ;                                               10 = +12V
                      00078 ;                                               11 = Vpp
                      00079 ;*----------------------------- -------------------------------------------*
  00000000            00080 M25V            equ     0
  00000001            00081 M21V            equ     1
  00000002            00082 P18_0           equ     2
  00000003            00083 P18_1           equ     3
  00000004            00084 P19_0           equ     4
  00000005            00085 P19_1           equ     5
  00000006            00086 P20_0           equ     6
  00000007            00087 P20_1           equ     7
                      00088 
  00000003            00089 TRISA_INIT      equ     (1 << M25V) | (1 << M21V)
  00000003            00090 ANSEL_INIT      equ     (1 << M25V) | (1 << M21V)
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  7
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00091 
                      00092 ;*------------------------------------------------------------------------*
                      00093 ; I/O Port B Initialization Values (Page 116)
                      00094 ;  Bit  Name             Dir        Function        Use
                      00095 ;   0   P2Vn        output          RB0         0 applies +5V to pin 24
                      00096 ;   1   M13_1V      Analog Input    C12IN3-     13.1-volt compare
                      00097 ;   2   P24_12Vn    Output          RB2         0 applies +12V to pin 24
                      00098 ;   3   M12_75V     Analog Input    C12IN2-     12.75-volt compare
                      00099 ;   4   P24_6Vn     Output          RB4         0 applies 6.2V to pin 24
                      00100 ;   5   A9n         Output          RB5         Inverted address bit 9
                      00101 ;   6   DBUFDIR     Output          RB6         Data buffer direction:
                      00102 ;                                               1 = Write to EPROM
                      00103 ;                                               0 = Read from EPROM
                      00104 ;   7   DBUFOEn     Output          RB7         0 enables  data buffer output   
                      00105 ;*------------------------------------------------------------------------*
  00000000            00106 P24_5Vn         equ     0
  00000001            00107 M13_1V          equ     1
  00000002            00108 P24_12Vn        equ     2
  00000003            00109 M12_75V         equ     3
  00000004            00110 P24_6Vn         equ     4
  00000005            00111 A9n             equ     5
  00000006            00112 DBUFDIR         equ     6
  00000007            00113 DBUFOEn         equ     7
                      00114 
  0000000A            00115 TRISB_INIT      equ     (1 << M13_1V) | (1 << M12_75V)
  0000000A            00116 ANSELH_INIT     equ     (1 << M13_1V) | (1 << M12_75V)
                      00117 
                      00118 ;*------------------------------------------------------------------------*
                      00119 ; I/O Port C Initialization Values (Page 119)
                      00120 ;  Bit  Name         Dir        Function        Use
                      00121 ;
                      00122 ;   0   A8n         Output      RC0         Inverted address bit 8
                      00123 ;   1   SRAM_CEn    Output      RC1         Active-low SRAM chip enable
                      00124 ;   2   VPPULSE     Output      CCP1/P1A    Vpp Switcher pulse output
                      00125 ;   3   SCK         Output      SCK1        SPI Clock to SRAM
                      00126 ;   4   SI          Input       SDI1        SPI Data In from SRAM
                      00127 ;   5   SO          Output      SDO1        SPI Data Out to SRAM
                      00128 ;   6   TxD         Output      TX1         RS-232 transmit data
                      00129 ;   7   RxD         Input       RX1         RS-232 receive data
                      00130 ;*------------------------------------------------------------------------*
  00000000            00131 A8n             equ     0
  00000001            00132 SRAM_CEn        equ     1
  00000002            00133 VPULSE          equ     2
                      00134 
  00000090            00135 TRISC_INIT      equ     0x90
                      00136 
                      00137 ;*------------------------------------------------------------------------*
                      00138 ; I/O Port D Initialization Values (Page 122)
                      00139 ;  Bit  Name         Dir        Function        Use
                      00140 ;   0   D0          In/out      RD0         Data bit 0
                      00141 ;   1   D1          In/out      RD1         Data bit 1
                      00142 ;   2   D2          In/out      RD2         Data bit 2
                      00143 ;   3   D3          In/out      RD3         Data bit 3
                      00144 ;   4   D4          In/out      RD4         Data bit 4
                      00145 ;   5   D5          In/out      RD5         Data bit 5
                      00146 ;   6   D6          In/out      RD6         Data bit 6
                      00147 ;   7   D7          In/out      RD7         Data bit 7
                      00148 ;*------------------------------------------------------------------------*
  000000FF            00149 TRISD_INIT      equ     0xff            ;initialize as inputs
                      00150 
                      00151 ;*------------------------------------------------------------------------*
                      00152 ; I/O Port E Initialization Values (Page 125)
                      00153 ;  Bit  Name         Dir        Function        Use
                      00154 ;   0   P21_0       Output      RE0         Pin 21 Control:
                      00155 ;   1   P21_1       Output      RE1         00 = TTL 0
                      00156 ;                                           01 = TTL 1
                      00157 ;                                           10 = -5V
                      00158 ;                                           11 = Vpp
                      00159 ;
                      00160 ;   2   ADRCLK      Output      RE2         Positive edge clocks address low byte
                      00161 ;                                           Also light BUSY LED when high
                      00162 ;   3   SETUP       In          RE3         SETUP (jumper to +3.3 on ICP connector)
                      00163 ;   (Note: Pin RE3 gets high voltage during PIC programming)
                      00164 ;*------------------------------------------------------------------------*
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  8
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000000            00165 P21_0           equ     0
  00000001            00166 P21_1           equ     1
  00000002            00167 ADRCLK          equ     2
  00000003            00168 SETUP           equ     3
                      00169 
  00000008            00170 TRISE_INIT      equ     (1 << SETUP)        ;SETUP is an input
                      00171 
                      00172 ;*------------------------------------------------------------------------*
                      00173 ;Baud Rates (See page 237)
                      00174 ; Assuming 16 MHz oscillator, and BRG16=1
                      00175 ;*------------------------------------------------------------------------*
  000001A0            00176 BAUD9600    equ     .416
  000000CF            00177 BAUD19200   equ     .207
  00000067            00178 BAUD38400   equ     .103
  00000044            00179 BAUD57600   equ     .68
  000001A0            00180 BAUDRATE    equ     BAUD9600
                      00181 
                      00182 ;*----------------------------------------------*
                      00183 ;* System Equates (Page ??)                     *
                      00184 ;* and fixed-location firmware routines         *
                      00185 ;*----------------------------------------------*
  00000000            00186 RESET_VECTOR    equ 0x00                        ;defined by PIC hardware
  00000008            00187 INT_VECTOR      equ 0x08                        ;interrupt vector (priority disabled)
  0000000A            00188 CALL_TABLE      equ 0x0A                        ;more routines here
                      00189 
  00F00000            00190 EEPROM          equ 0xF00000                    ;address for initializing EEPROM
                      00191 
                      00192 ;The following registers are no longer used, once the code is running.
                      00193 
  00000010            00194 REC_TYPE    equ R2+1        ;Intel hex record type
  00000011            00195 ROWA_LOW    equ R2+2        ;low address byte of previous hex record
  00000012            00196 ROWA_HIGH   equ R2+3        ;high address byte of previous hex record
                      00197 
                      00198 
                      00199 ;*--------------------------------------------------------------*
                      00200 ;Flash memory constants
                      00201 ;*--------------------------------------------------------------*
  00000020            00202 FLASH_ROW       equ     .32     ;bytes per row
  00000002            00203 FLASH_BLOCK     equ     2       ;flash rows per erase block
                      00204 
                      00205 ;*--------------------------------------------------------------*
                      00206 ;* External Serial SRAM Equates for the Microchip 23K640        *
                      00207 ;*--------------------------------------------------------------*
  00000003            00208 SRAM_DREAD      equ     0x03        ;read data
  00000002            00209 SRAM_DWRITE     equ     0x02        ;write data
  00000005            00210 SRAM_SREAD      equ     0x05        ;Status read
  00000001            00211 SRAM_SWRITE     equ     0x01        ;Status write
                      00212 
                      00213 ;===================================================================
                      00214 ; The following 2 macros make assumptions about where RX_QUEUE and
                      00215 ; TX_QUEUE are placed in memory, and what their sizes are. If you
                      00216 ; change the location or size of these queues, then these macros
                      00217 ; must also be changed.
                      00218 ;===================================================================
                      00219 ;specialized macro to increment receive queue pointers
                      00220 ;these assume that the receive queue is located on a 256-byte
                      00221 ;boundary, and is 256 bytes long.
                      00222 inc_rq  macro pointer
                      00223         incf    pointer,F,0     ;linear increment the pointer
                      00224                                 ;any carry gets chucked to wrap
                      00225         endm
                      00226 
                      00227 ;specialized macro to increment transmit queue pointers
                      00228 ;these assume that the transit queue is located on a 32-byte
                      00229 ;boundary, and is 16 bytes long
                      00230 inc_tq  macro pointer
                      00231         incf    pointer,F,0     ;linear increment the pointer
                      00232         bcf     pointer,0x4,0   ;clear any overflow
                      00233         endm
                      00234 
                      00235         
                      00200 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE  9
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00201     page
                      00202 
                      00203 ;################################################################################
                      00204 ;# Overwrite the EEPROM data, so that it will appear uninitialized              #
                      00205 ;################################################################################
F00000                00206     org     EEPROM
F00000 6E55 6E69 7469 00207     de      "Uninitialized EEPROM",0
       6169 696C 657A 
       2064 4545 5250 
       4D4F 0000 
                      00208 
                      00209 ;################################################################################
                      00210 ;# Dummy Firmware - gets overwritten by programmer firmware                     #
                      00211 ;################################################################################
000800                00212     org     LOADED_CODE
                      00213 
000800 EE08 F00C      00214                 lfsr    0,nocode_msg
000804 EC9D F001      00215                 call    loader_printf
000808 EFFC F000      00216                 goto    code_loader
                      00217 
00080C 0D0D 6F4E 7020 00218 nocode_msg:     dw  "\r\rNo programmer firmware loaded."
       6F72 7267 6D61 
       656D 2072 6966 
       6D72 6177 6572 
       6C20 616F 6564 
       2E64 
00082C 530D 6E65 2064 00219                 dw  "\rSend ME2700.hex now.\r",0
       454D 3732 3030 
       682E 7865 6E20 
       776F 0D2E 0000 
                      00220 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 10
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00221     page
                      00222 ;################################################################################
                      00223 ;# Reset Vector - hardware-fixed location                                       #
                      00224 ;# Maximum of 1 word long - otherwise it will collide with K_KERN_REV.          #
                      00225 ;################################################################################
000000                00226     org     RESET_VECTOR                ;routine must be exactly 2 words long
000000 D096           00227                 bra     init
                      00228 
                      00229 ;************************************===========================================*
                      00230 ;* Externally Accessible Subroutine *
                      00231 ;************************************
                      00232 ; Fixed-location subroutine to return the version for this loader.
                      00233 ; This subroutine can only be 1 word long here!
                      00234 ; On Exit:
                      00235 ;     W bits 7:4 = major revision number
                      00236 ;     W bits 3:0 = minor revision number
                      00237 ;*==============================================================================*
000002 0C10           00238 K_KERN_REV:     retlw   (REV_MAJOR << 4) | REV_MINOR
                      00239 
                      00240 ;************************************===========================================*
                      00241 ;* Externally Accessible Subroutine *
                      00242 ;************************************
                      00243 ; Fixed-location subroutine to return the ID for this programmer.
                      00244 ; This subroutine can only be 1 word long here!
                      00245 ; On Exit:
                      00246 ;     W=0 for ME1702A, 1 for ME5204
                      00247 ;*==============================================================================*
000004 0C00           00248 K_KERN_ID:      retlw   0x00
                      00249 
                      00250 ;################################################################################
                      00251 ;# Low-priority Interrupt Vector - hardware-fixed location. There is room for   #
                      00252 ;# just one instruction word here.                                              #
                      00253 ;################################################################################
000008                00254     org     INT_VECTOR
000008 D152           00255                 bra     int_service
                      00256 
                      00257 ;################################################################################
                      00258 ;# Kernel call vectors (fixed locations for access by external code)            #
                      00259 ;# INT_VECTOR = 0x04. This table begins at 0x05, immediately following the      #
                      00260 ;# interrupt vector.                                                            #
                      00261 ;################################################################################
00000A                00262     org     CALL_TABLE
                      00263 
00000A D207           00264 K_CONIN:        bra     get_rxchr       ;get one chr from Rx Q into W & R0. Z set if empty
00000C D1D8           00265 K_CONOUT:       bra     printw          ;send W to console
00000E D199           00266 K_PRINTF:       bra     printf          ;print 0-terminated string at TBLPTRH:TBLPTRL
000010 D1FD           00267 K_EEPRINT:      bra     ee_print        ;print 0=terminates string from EEPROM at EEADR
000012 D1D0           00268 K_PRINTHEX1:    bra     print_hex1      ;print low nibble of W as 1 hex chr
000014 D1CB           00269 K_PRINTHEX2:    bra     print_hex2      ;print W as 2 hex chrs
000016 D1A0           00270 K_PRINTDEC:     bra     print_dec       ;print R1:R0 in decimal, leading zeros suppressed
000018 D1EF           00271 K_PRINTSN:      bra     print_sn        ;print serial number
00001A D30D           00272 K_HEX2BIN:      bra     hex2bin         ;convert hex value in R0 to binary, combine with R1
00001C D20C           00273 K_GETLIN:       bra     getlin          ;Get a 0-terminated line from the user
00001E D2DB           00274 K_PARSE:        bra     parse_cmd       ;search cmd table at TBLPTR for cmd at FSR0, return W=cmd index
000020 D259           00275 K_GETCHR:       bra     get_chr         ;get next character at FSR1, result in W & R0
000022 D251           00276 K_GETUCHR:      bra     get_uchr        ;get next uppercase chr at FSR1, result in W & R0
000024 D25F           00277 K_GETDEC:       bra     get_dec         ;Get 8-bit decimal value in W & PRODL. Trash R0
000026 D2F4           00278 K_GETHEX2:      bra     get_lbhex2      ;get 2-digit hex, result in W & R1, sum in CHECKSUM, Z set if CH
                            ECKSUM=0
000028 D274           00279 K_GETHEX4:      bra     get_lbhex4      ;Get 4-digit hex value into R2:R1. Trash W,R0
00002A D236           00280 K_ASKYN:        bra     ask_yn          ;Ask user Y/N. Z set if Y, cleared if N
00002C D241           00281 K_CHKABORT:     bra     chk_abort       ;Check for user abort. Z if no chr, C if abort, chr in W,R0
00002E D28B           00282 K_RDSRAM:       bra     rd_sram         ;read SRAM byte at ADDRESSH:ADDRESSL, Result in W
000030 D28C           00283 K_WRSRAM:       bra     wr_sram         ;write W to SRAM at ADDRESSH:ADDRESSL
000032 D29D           00284 K_RDEEPROM:     bra     rd_eepromw      ;read EEPROM at address W, result in W
000034 D2A2           00285 K_WREEPROM:     bra     wr_eeprom       ;write W to EEPROM at address EEADR
000036 D07B           00286                 bra     init            ;reserved for future command
000038 D07A           00287                 bra     init            ;reserved for future command
00003A D2AE           00288 K_STALL25M:     bra     stall_25ms      ;stall for W * 25 mS
00003C D2B3           00289 K_STALL250U:    bra     stall_250us     ;stall for W * 250 uS
                      00290 
                      00291 ;************************************===========================================*
                      00292 ;* Externally Accessible Subroutine *
                      00293 ;************************************
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 11
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00294 ; Subroutine to stall for W + 1 uS (including the call)
                      00295 ;
                      00296 ; This routine is right at the end of the jump vector table to eliminate the
                      00297 ; overhead of an additional bra instruction, whose 0.50 uS time is significant.
                      00298 ; This routine assumes a 16 MHz oscillator frequency, resulting in a 0.25 uS
                      00299 ; instruction cycle time.
                      00300 ; On Exit:
                      00301 ;     W=0
                      00302 ;     Z set
                      00303 ;*==============================================================================*
00003E                00304 K_STALL1U:                              ;Call Vector right here to make it fast
00003E 0FFF           00305 stall_1us:      addlw   0xff            ;(.25)subtract 1 from W             
000040 A4D8           00306                 btfss   STATUS,Z,0      ;(.25/.5)This way to make loop exactly 1 uS
000042 D7FD           00307                 bra     stall_1us       ;(.50)
                      00308 
000044 0000           00309                 nop                     ;(.25)
000046 0012           00310             return                      ;(.50)
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 12
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00311     page
                      00312 ;################################################################################
                      00313 ;# Null-terminated strings used by kernel                                       #
                      00314 ;################################################################################
000048 4D0D 3245 3037 00315 loader_msg:     dw  "\rME2700 Loader "
       2030 6F4C 6461 
       7265 0020 
000058 2E31           00316                 dw  (REV_MAJOR + '0') + ('.' << 8)
00005A 0D30           00317                 dw  (REV_MINOR + '0') + (CR << 8)
00005C 0000           00318                 dw  0
00005E 3F20 6548 0078 00319 hexerror_msg:   dw  " ?Hex",0
       0000 
000066 3F20 7343 006D 00320 cksumerror_msg: dw  " ?Csm",0
       0000 
00006E 3F20 6556 2072 00321 verifyerr_msg:  dw  " ?Ver ",0          ;this error will print in the middle of a record
       0000 
000076 4C0D 616F 6564 00322 reccount_msg:   dw  "\rLoaded Hex Records: ",0
       2064 6548 2078 
       6552 6F63 6472 
       3A73 0020 0000 
00008E 450D 7272 726F 00323 errcount_msg:   dw  "\rErrors: ",0
       3A73 0020 0000 
00009A 490D 696E 6974 00324 eeinit_msg:     dw  "\rInitializing EEPROM",0
       6C61 7A69 6E69 
       2067 4545 5250 
       4D4F 0000 
0000B0 4E0D 7765 0020 00325 newsn_msg:      dw  "\rNew "            ;fall into sn_msg
0000B6 454D 3732 3030 00326 sn_msg:         dw  "ME2700 Serial Number: ",0
       5320 7265 6169 
       206C 754E 626D 
       7265 203A 0000 
0000CE 6E75 6863 6E61 00327 unchanged_msg:  dw  "unchanged",0
       6567 0064 0000 
0000DA 2820 2F59 294E 00328 yn_msg:         dw  " (Y/N)? ",0
       203F 0000 
0000E4 430D 656C 7261 00329 clrvars_msg:    dw  "\rClear all EEPROM variables",0
       6120 6C6C 4520 
       5045 4F52 204D 
       6176 6972 6261 
       656C 0073 0000 
000102 410D 6C6C 4520 00330 cleared_msg:    dw  "\rAll EEPROM variables cleared",0
       5045 4F52 204D 
       6176 6972 6261 
       656C 2073 6C63 
       6165 6572 0064 
       0000 
000122 520D 6E75 6320 00331 run_msg:        dw  "\rRun code",0
       646F 0065 0000 
                      00332 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 13
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00333     page
                      00334 ;################################################################################
                      00335 ;# Initialization Routine                                                       #
                      00336 ;#   Initialize only the registers where the Reset value is not right for us.   #
                      00337 ;#   The following are initialized correctly by RESET                           #
                      00338 ;#      ADCON0  = 0x00  (A/D converter is disabled. Page 255)                   #
                      00339 ;#      ADCON1  = 0x00  (No A/D pims assigned. Page 256)                        #
                      00340 ;#      BAUDCON = 0x08  (16-bit baud rate generator. Page 233)                  #
                      00341 ;#      CCP1CON = 0x0C  (Single-ended PWM, active high for P1A. Page 165)       #
                      00342 ;#      CCP2CON = 0x00  (Capture/Compare Module 2 disabled. Page 134)           #
                      00343 ;#      CM1CON0 = 0x9C  (Comparator 1 enabled and set up. Page 267)             #
                      00344 ;#      CM2CON0 = 0x00  (Cmparator module 2 disabled. Page 268)                 #
                      00345 ;#      CM2CON1 = 0x00  (FVR is the reference for Comparater 1. Page 270)       #
                      00346 ;#      CCPR1L  = 0x00  (Duty cycle is 0. Page 141)                             #
                      00347 ;#      CVRCON2 = 0x80  (Voltage reference enabled. Page 275)                   #
                      00348 ;#      CVRCON  = 0x00  (Comparator voltage reference disabled. Page 274)       #
                      00349 ;#      ECCP1AS = 0x10  (Shut down PWM when C1OUT is high. Page 171)            #
                      00350 ;#      HLVDCON = 0x00  (High/low voltage detection disabled. Page 276)         #
                      00351 ;#      INTCON2 = 0xFF  (Weak pullups disabled. Page 103)                       #
                      00352 ;#      INTCON3 = 0xC0  (external interrupts disabled. Page 104)                #
                      00353 ;#      OSCON   = 0x72  (Internal 16 MHz oscillator. Page 28)                   #
                      00354 ;#      OSCTUNE = 0x00  (no oscillator tuning)                                  #
                      00355 ;#      PIE1    = 0x20  (USART receive interrupt enabled. Page 107)             #
                      00356 ;#      PIE2    = 0x00  (a bunch of interrupts are disabled. Page 108)          #
                      00357 ;#      PIR1    = 0x00  (receive interrupt is cleared. Page 105)                #
                      00358 ;#      PIR2    = 0x00  (Flash write operation has not been started. Page 106)  #
                      00359 ;#      PSTRCON = 0x01  (Steer PWM output to pin P1A. Page 175)                 #
                      00360 ;#      PWM1CON = 0x80  (auto-restart PWM when C1OUT goes low. Page 174)        #
                      00361 ;#      RCON    = 0x5C  (mainly, IPEN = 0. Page 49 & 111)                       #
                      00362 ;#      RCSTA   = 0x90  (USART receive setup. Page 232)                         #
                      00363 ;#      SLRCON  = 0x1F  (low slew rate on all ports. Page 130)                  #
                      00364 ;#      SPBRG   = 0xAF  (9600 baud. Page 237)                                   #
                      00365 ;#      SPBRGH  = 0xBO  (9600 baud. Page 237)                                   #
                      00366 ;#      SSPCON1 = 0x20  (4 MHz SPI master enabled. Page 182)                    #
                      00367 ;#      SSPSTAT = 0x40  (SPI data changes on clock falling edge. Page 181)      #
                      00368 ;#      T0CON   = 0x00  (Timer 0 is off. Page 145)                              #
                      00369 ;#      T1CON   = 0x00  (Timer 1 is off. Page 148)                              #
                      00370 ;#      T2CON   = 0x04  (Timer 2 is on, no prescaler. Page 155)                 #
                      00371 ;#      T3CON   = 0x00  (Timer 3 is off. Page 157)                              #
                      00372 ;#      TBLPTRU = 0x00  (All code & tables are in the 1st 32K.)                 #
                      00373 ;#      TRISD   = 0xFF  (Data port tristated)                                   #
                      00374 ;#      TXSTA   = 0x24  (USART transmit setup. Page 231)                        #
                      00375 ;#      WDTCON  = 0x00  (Watchdog timer disabled. Page 291)                     #
                      00376 ;################################################################################
00012E                00377 init:
                      00378 
                      00379 ;*------------------------------*
                      00380 ; *Initialize the oscillator    *
                      00381 ;*------------------------------*
                      00382 ;internal oscillator block, 16 MHz (Page 28)
00012E 0E72           00383             movlw   (1 << SCS1) | (1 << IRCF0) | (1 << IRCF1) | (1 << IRCF2)
000130 6ED3           00384             movwf   OSCCON,0
                      00385 
                      00386 ;*------------------------------*
                      00387 ; *Initialize all I/O port pins *
                      00388 ;*------------------------------*
000132 6A89           00389             clrf    LATA,0
000134 0E03           00390             movlw   TRISA_INIT
000136 6E92           00391             movwf   TRISA,0
000138 0E03           00392             movlw   ANSEL_INIT
00013A 6E7E           00393             movwf   ANSEL,0
                      00394 
00013C 688A           00395             setf    LATB,0
00013E 0E0A           00396             movlw   TRISB_INIT
000140 6E93           00397             movwf   TRISB,0
000142 0E0A           00398             movlw   ANSELH_INIT
000144 6E7F           00399             movwf   ANSELH,0
                      00400 
000146 0E02           00401             movlw   (1 << SRAM_CEn)
000148 6E82           00402             movwf   PORTC               ;SRAM disabled
00014A 0E90           00403             movlw   TRISC_INIT
00014C 6E94           00404             movwf   TRISC,0
                      00405 
00014E 6A8C           00406             clrf    LATD,0
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 14
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00407                                         ;TRISD is already 0xFF
                      00408 
000150 6A8D           00409             clrf    LATE,0
000152 848D           00410             bsf     LATE,ADRCLK,0       ;Busy light on
000154 0E08           00411             movlw   TRISE_INIT
000156 6E96           00412             movwf   TRISE,0
                      00413 
                      00414 ;*------------------------------------------------------------------------------*
                      00415 ;* Set up comparator C1 and PWM1 as a voltage regulator for Vpp.                *
                      00416 ;* Comparator C1 compares one of the voltage-measurement resistor dividers to   *
                      00417 ;* the PIC's internal 1.2 volt inernal fixed voltage reference. C1OUT is high   *
                      00418 ;* whenever the output from the voltage measurement divider is higher than the  *
                      00419 ;* internal 1.2V reference. Capture/compare/PWM Module 1 is set up as an        *
                      00420 ;* "enhanced PWM" with a non-inverted output and is further set up to be        *
                      00421 ;* disabled whenever Comparator C1OUT is high. During this initialization, the  *
                      00422 ;* PWM pulse width is set to 0, so that Vpp is off.                             *
                      00423 ;*------------------------------------------------------------------------------*
                      00424 
                      00425 ;Enable the fixed voltage reference.
                      00426 ;(CM2CON1 defaults to set the 1.2 volt FVR as the reference. See page 270.)
                      00427 
000158 0E80           00428             movlw   (1 << FVREN)                    ;Enable FVR (page 275)
00015A 6EB4           00429             movwf   CVRCON2,0
                      00430 
                      00431 ;Set up Timer 2 for the desired frequency (108 KHz) (See page 141)
                      00432 ;(This frequency experimentally determined)
00015C 0E24           00433             movlw   0x24                            ;timer value for 108 KHz
00015E 6ECB           00434             movwf   PR2
                      00435         
000160 0E04           00436             movlw   (1 << TMR2ON)                   ;turn timer 2 on, no prescale
000162 6ECA           00437             movwf   T2CON,0                         ;(page 155)
                      00438 
                      00439 ;Set the duty cycle to 0, to insure no output (page 141)
000164 6ABE           00440             clrf    CCPR1L,0
                      00441 
                      00442 ;Set up PWM1 as an enhanced PWM, with output steered to its P1A pin, and
                      00443 ;controlled by comparator output C1OUT
000166 0E0C           00444             movlw   (1 << CCP1M2) | (1 << CCP1M3)   ;(page 161) Single-ended PWM mode,
000168 6EBD           00445             movwf   CCP1CON,0                       ;active high for P1A
                      00446 
00016A 0E01           00447             movlw   (1 << STRA)                     ;(page 175)
00016C 6EB9           00448             movwf   PSTRCON,0                       ;Steer PWM output to pin P1A
                      00449 
00016E 0E10           00450             movlw   (1 << ECCPAS0)                  ;(page 171)
000170 6EB6           00451             movwf   ECCP1AS,0                       ;Shut down PWM and drive P1A to 0V
                      00452                                                     ;..when C1OUT is high
                      00453 
000172 0E80           00454             movlw   (1<<PRSEN)                      ;(page 174)
000174 6EB7           00455             movwf   PWM1CON,0                       ;auto-restart PWM when C1OUT goes low
                      00456 
                      00457 ;Comparator 1 enabled, inverted, using internal reference for + input, no
                      00458 ;output pins (page 267) For now, also select channel 0 (the 12.5V divider)
                      00459 ;as the - input.
                      00460 
000176 0E9C           00461             movlw   (1 << C1R) | (1 << C1SP) | (1 << C1ON) | (1 << C1POL)
000178 6E7B           00462             movwf   CM1CON0,0
                      00463 
                      00464 ;*------------------------------------------------------*
                      00465 ;* Set up the RS-232 serial port and associated queues  *
                      00466 ;*------------------------------------------------------*
                      00467 ;Set up the EUSART for asynchronous 8-bit, specified baud, enabled
00017A 0E08           00468             movlw   (1 << BRG16)                ;(page 233)
00017C 6EB8           00469             movwf   BAUDCON,0
                      00470 
00017E 0EA0           00471             movlw   low(BAUDRATE)               ;(page 237)
000180 6EAF           00472             movwf   SPBRG,0
000182 0E01           00473             movlw   high(BAUDRATE)
000184 6EB0           00474             movwf   SPBRGH,0
                      00475 
000186 0E24           00476             movlw   (1 << BRGH) | (1 << TXEN)   ;(page 231)
000188 6EAC           00477             movwf   TXSTA,0
                      00478 
00018A 0E90           00479             movlw   (1 << SPEN) | (1 << CREN)   ;(page 232)
00018C 6EAB           00480             movwf   RCSTA,0
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 15
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00481 
                      00482 ;initialize the receive queue
                      00483     if  low(RX_QUEUE)
                      00484             movlw   low(RX_QUEUE)
                      00485             movwf   RQ_IPTR,0
                      00486             movwf   RQ_OPTR,0
                      00487     else
00018E 6A00           00488             clrf    RQ_IPTR,0
000190 6A01           00489             clrf    RQ_OPTR,0
                      00490     endif
                      00491 
                      00492 ;initialize the transmit queue
000192 0EE0           00493             movlw   low(TX_QUEUE)
000194 6E02           00494             movwf   TQ_IPTR,0
000196 6E03           00495             movwf   TQ_OPTR,0
                      00496 
                      00497 ;initialize interrupt flags: both queues are empty
000198 0E02           00498             movlw   (1 << TQ_EMPTY)
00019A 6E0B           00499             movwf   INT_FLAGS,0
                      00500 
00019C 50AE           00501             movf    RCREG,W,0           ;chuck any junk in the UART receiver
00019E 50AE           00502             movf    RCREG,W,0           ;it's a double-buffer
                      00503 
                      00504 ;Enable echo
0001A0 0E04           00505             movlw   (1 << ECHO_FLAG)
0001A2 6E0C           00506             movwf   KERN_FLAGS,0
                      00507 
                      00508 ;Set up UART interrupts (Page 107)
0001A4 0E20           00509             movlw   (1 << RCIE)         ;enable USART Rx int
0001A6 6E9D           00510             movwf   PIE1,0              ;note: Tx int gets enabled when enqueing data
                      00511 
                      00512 ;*------------------------------------------------------------------*
                      00513 ; Set up the Master Synchronous Serial Port for SPI communication   *
                      00514 ; with the external serial SRAM chip, and set up the SRAM chip      *
                      00515 ;*------------------------------------------------------------------*
0001A8 0E20           00516             movlw   (1 << SSPEN)                ;(page 182)
0001AA 6EC6           00517             movwf   SSPCON1,0                   ;enabled, SPI Master, 4 MHz operation
0001AC 0E40           00518             movlw   (1<<CKE)
0001AE 6EC7           00519             movwf   SSPSTAT                     ;data changes on clock falling edge (page 181)
                      00520 
                      00521 ;Set the external Serial SRAM for byte mode
0001B0 928B           00522             bcf     LATC,SRAM_CEn,0             ;enable SRAM
                      00523 
0001B2 0E01           00524             movlw   SRAM_SWRITE                 ;SRAM write status command
0001B4 6EC9           00525             movwf   SSPBUF,0                    ;write command to SPI
0001B6 DA08           00526             rcall   wait_spi                    ;wait for it to complete
                      00527 
0001B8 6AC9           00528             clrf    SSPBUF,0                    ;0 to status register means byte mode
0001BA DA06           00529             rcall   wait_spi                    ;wait for it to complete
                      00530 
0001BC 828B           00531             bsf     LATC,SRAM_CEn,0             ;disable SRAM
                      00532 
                      00533 ;-----------------------------------*
                      00534 ; Initalize various PIC registers   *
                      00535 ;-----------------------------------*
0001BE 6AD5           00536             clrf    T0CON,0                     ;disable timer 0 (page 145)
                      00537 
                      00538 ;Turn on the BUSY LED, and clock 0 into the low-address latch
0001C0 848B           00539             bsf     LATC,ADRCLK,0
                      00540 
                      00541 ;Enable UART interrupts - we're ready to go (Page 102)
0001C2 0EC0           00542             movlw   (1 << GIE) | (1 << PEIE)
0001C4 6EF2           00543             movwf   INTCON,0
                      00544 
                      00545 ;################################################################################
                      00546 ;# Choose Setup, Loader, or Loaded Code                                         #
                      00547 ;# Test for user typing 'L's to invoke the loader. If not, go to loaded code.   #
                      00548 ;# auto-repeat is faster than 500 mS per character - we should see one within   #
                      00549 ;# 500 mS.                                                                      #
                      00550 ;################################################################################
                      00551 ;Check for Initialized string, and go set up the EEPROM if it's not there
0001C6 0E14           00552             movlw   EE_INITLEN          ;Initialized length 
0001C8 6E0E           00553             movwf   R1,0                ;byte counter
                      00554 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 16
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0001CA 0E00           00555             movlw   high(loader_msg)    ;init string in FLASH
0001CC 6EF7           00556             movwf   TBLPTRH,0
0001CE 0E48           00557             movlw   low(loader_msg)
0001D0 6EF6           00558             movwf   TBLPTRL,0
                      00559 
0001D2 0E00           00560             movlw   EE_INIT             ;init string address in EEPROM
0001D4 6EA9           00561             movwf   EEADR,0             ;..where rd_eeprom wants the address
                      00562 
0001D6 D9CC           00563 ckid_loop:      rcall   rd_eeprom       ;get an EEPROM byte
0001D8 2AA9           00564                 incf    EEADR,F,0       ;bump pointer
                      00565 
0001DA 0009           00566                 tblrd*+                 ;get string byte
0001DC 18F5           00567                 xorwf   TABLAT,W,0      ;compare EEPROM to string
0001DE A4D8           00568                 btfss   STATUS,Z,0
0001E0 D28C           00569                 bra     new_eeprom      ;mismatch: go setup EEPROM
                      00570 
0001E2 2E0E           00571                 decfsz  R1,F,0          ;test all bytes
0001E4 D7F8           00572                 bra     ckid_loop
                      00573 
                      00574 ;Test for SETUP jumper, and go to set up the EEPROM if it's there
0001E6 B684           00575             btfsc   PORTE,SETUP,0
0001E8 D29A           00576             bra     edit_eeprom
                      00577 
                      00578 ; The ID is good - assume the EEPROM is properly initialized
                      00579 
                      00580 ;Is the user trying to load code?
0001EA 0E28           00581             movlw   .40                 ;40 * 25 mS = wait for 1000 mS
0001EC D9D5           00582             rcall   stall_25ms
                      00583 
0001EE D915           00584             rcall   get_rxchr           ;get Rx chr. W will not equal 'L' if nothing typed
0001F0 0A4C           00585             xorlw   'L'                 ;L takes us to the loader
0001F2 A4D8           00586             btfss   STATUS,Z,0
0001F4 EF00 F004      00587             goto    LOADED_CODE         ;no L typed: go to programming firmware
                      00588 
                      00589 ;fall into code_loader
                      00590 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 17
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00591     page
                      00592 ;################################################################################
                      00593 ;# Intel Hex Firmware Loader                                                    #
                      00594 ;# Receive an entire file of Intel Hex records, and write them to FLASH memory  #
                      00595 ;# as appropriate.                                                              #
                      00596 ;#                                                                              #
                      00597 ;# Entry here is only from initialization (above), when the user has typed      #
                      00598 ;# several 'L's (that must be flushed), or from the dumme firmware code.        #
                      00599 ;################################################################################
                      00600 ; Print sign-on message, and initialize variables at beginning of file
0001F8 D9DB           00601 code_loader:    rcall   start_loader            ;clear counters, print sign-on message
                      00602 
                      00603 ;eat any following 'L's without echoing them
0001FA D90F           00604 flush_l:            rcall   get_rxchr           ;Z set if no chr. This does not echo
0001FC E0FE           00605                     bz      flush_l             ;no characters
                      00606 
0001FE 0A4C           00607                     xorlw   'L'
000200 E0FC           00608                     bz      flush_l             ;spin until non-'L' character
                      00609 
                      00610 ;echo the first non-'L' character, and begin looking for hex records
000202 D8DE           00611                 rcall   printr0                 ;manually echo the first non-'L' chr
                      00612 
000204 D001           00613                 bra     load_start              ;we already have the first chr in R0
                      00614 
                      00615 ;--------------------------------------------------------------------------------------
                      00616 ; (1)Wait for colon to start an Intel Hex record. If the user types three sequential
                      00617 ; ESCs, *and* we are not in the middle of a load (i.e. FLASH_MEM is not set), then
                      00618 ; test_esc will go to main. Ignore everything else.
                      00619 ;--------------------------------------------------------------------------------------
000206 DA6C           00620 wait_recstart:  rcall   test_esc                ;check for 3 ESCs, and get chr into R0
                      00621 
000208 500D           00622 load_start:     movf    R0,W,0                  ;beginning of hex record?
00020A 0A3A           00623                 xorlw   ':'                     ;all records start with colon
00020C E1FC           00624                 bnz     wait_recstart           ;spin until we get a colon
                      00625 
00020E 6A04           00626                 clrf    CHECKSUM,0              ;initialize checksum
000210 900C           00627                 bcf     KERN_FLAGS,ERR_FLAG,0   ;good hex so far
                      00628 
                      00629 ;--------------------------------------------------------------------------------------
                      00630 ; (2)Get hex record byte count and save it in R2
                      00631 ;--------------------------------------------------------------------------------------
000212 DA08           00632                 rcall   get_rqhex2              ;get byte count
000214 6E0F           00633                 movwf   R2,0                    ;save record byte count
                      00634 
                      00635 ;--------------------------------------------------------------------------------------
                      00636 ; (3,4)Get high & low address bytes from hex record, save them in ADDRESSH, ADDRESSL
                      00637 ;--------------------------------------------------------------------------------------
000216 DA06           00638                 rcall   get_rqhex2              ;get address high byte into W & R1
000218 6E06           00639                 movwf   ADDRESSH,0              ;save high byte in ADDRESSH
00021A DA04           00640                 rcall   get_rqhex2              ;get address low byte into W & R1
00021C 6E05           00641                 movwf   ADDRESSL,0              ;save low byte in ADDRESSL
                      00642 
                      00643 ;--------------------------------------------------------------------------------------
                      00644 ; (5)Get record-type byte and save it in REC_TYPE. Set msb of ADDRESSH if not type 0
                      00645 ; record. (msb of ADDRESSH set means this record has no FLASH data.) Also set msb
                      00646 ; of ADDRESSH if FLASH memory has not yet been selected by a type 4 record
                      00647 ;--------------------------------------------------------------------------------------
00021E DA02           00648                 rcall   get_rqhex2              ;get Hex record type byte into W & R1
000220 6E10           00649                 movwf   REC_TYPE,0              ;save record type in REC_TYPE
                      00650 
000222 5210           00651                 movf    REC_TYPE,F,0            ;test for type 0 record
000224 B4D8           00652                 btfsc   STATUS,Z,0              ;if no, remember no data should be loaded
000226 A20C           00653                 btfss   KERN_FLAGS,FLASH_MEM,0  ;type 0. FLASH memory already selected?
000228 8E06           00654                 bsf     ADDRESSH,7,0            ;set msb so data won't load
                      00655 
                      00656 ;--------------------------------------------------------------------------------------
                      00657 ; Is this in a different FLASH row pair as the previously-received record? Is this
                      00658 ; record not a data record at all? If so, we must first flush the RAM buffer by
                      00659 ; writing it to FLASH, before we can receive the data from this new record.
                      00660 ; If msb of ADDRESSH is set, then this record should not cause a write to FLASH.
                      00661 ; Reasons for not loading data (msb of ADDRESSH is set):
                      00662 ; 1) This is not a data record (not type 0)
                      00663 ; 2) FLASH memory has not yet been selected (haven't received type 4 record with 0000)
                      00664 ;--------------------------------------------------------------------------------------
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 18
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00022A 5011           00665                 movf    ROWA_LOW,W,0        ;compare record's address low byte
00022C 1805           00666                 xorwf   ADDRESSL,W,0        ;low byte row number match?
00022E 0BC0           00667                 andlw   0xC0                ;test for 64-byte row pair
000230 E104           00668                 bnz     new_row
                      00669 
000232 5012           00670                 movf    ROWA_HIGH,W,0       ;high byte match?
000234 0B7F           00671                 andlw   0x7f                ;so that we trap msb set in ADDRESSH
000236 1806           00672                 xorwf   ADDRESSH,W,0
000238 E009           00673                 bz      same_row
                      00674 
                      00675 ;--------------------------------------------------------------------------------------
                      00676 ; This record is not in the same FLASH row pair as the previous record. Was the
                      00677 ; previous record one that should be written to FLASH? If so, we must flush the RAM
                      00678 ; buffer into FLASH before we can receive data from this next record.
                      00679 ;
                      00680 ;  FLASH_MEM set for program data, cleared otherwise (set by extended address record)
                      00681 ;  ADDRESSL = low byte of new record address
                      00682 ;  ADDRESSH = high byte of new record address - msb set means none
                      00683 ;  REC_TYPE = record type for new record
                      00684 ;  R2 = record byte count
                      00685 ;  RECOUNTH,RECOUNTL = total record count
                      00686 ;  ROWA_HIGH, ROWA_LOW = address of previous completed record 
                      00687 ;  ROWA_HIGH bit 7 set means the previous record was not FLASH data
                      00688 ;  FSR1H = high(RAM_BUF)
                      00689 ;--------------------------------------------------------------------------------------
00023A AE12           00690 new_row:        btfss   ROWA_HIGH,7,0   ;was previous row a FLASH data record (msb cleared)?
00023C DA1C           00691                 rcall   write_flash     ;yes: write it to FLASH now
                      00692 
                      00693 ;--------------------------------------------------------------------------------------
                      00694 ; Now that the RAM buffer is available, deal with the new record that we have already
                      00695 ; begun to receive. We have already received the byte count, address, record type. 
                      00696 ;
                      00697 ; Set up to read hex record data into the RAM buffer
                      00698 ;
                      00699 ;  FLASH_MEM set for program data, cleared otherwise (extended address stuff)
                      00700 ;  ADDRESSL = low byte of new record address
                      00701 ;  ADDRESSH = high byte of new record address - msb set means none
                      00702 ;  REC_TYPE = record type for new record
                      00703 ;  R2 = record byte count
                      00704 ;  RECOUNTH,RECOUNTL = total record count
                      00705 ;  ROWA_HIGH, ROWA_LOW = address of previous completed record (msb set means none)
                      00706 ;  FSR1H = high(RAM_BUF)
                      00707 ;--------------------------------------------------------------------------------------
                      00708 ;compute and save new FLASH row-pair address in ROWA_HIGH, ROWA_LOW
00023E C006 F012      00709                 movff   ADDRESSH,ROWA_HIGH      ;high address, including msb flag
                      00710 
000242 5005           00711                 movf    ADDRESSL,W,0
000244 0BC0           00712                 andlw   0xC0                    ;make it a 64-byte row-pair address
000246 6E11           00713                 movwf   ROWA_LOW,0              ;...saved in PREVA
                      00714 
                      00715 ;--------------------------------------------------------------------------------------
                      00716 ; See if this data is actually for FLASH memory (msb of high address byte cleared).
                      00717 ; If so, read the existing FLASH data into the buffer before receiving the hex record
                      00718 ; data, so that any FLASH data in this row that is not part of the hex file will remain
                      00719 ; unchanged.
                      00720 ;
                      00721 ;  FLASH_MEM set for program data, cleared otherwise (extended address stuff)
                      00722 ;  ADDRESSL = low byte of new record address
                      00723 ;  ADDRESSH = high byte of new record address - msb set means none
                      00724 ;  REC_TYPE = record type for new record
                      00725 ;  R2 = record byte count
                      00726 ;  RECOUNTH,RECOUNTL = total record count
                      00727 ;  ROWA_HIGH, ROWA_LOW = ADDRESSH, ADDRESSL
                      00728 ;  FSR1H = high(RAM_BUF)
                      00729 ;--------------------------------------------------------------------------------------
000248 AE12           00730                 btfss   ROWA_HIGH,7,0           ;is this a FLASH data record (msb cleared)?
00024A DA07           00731                 rcall   read_ver_flash          ;yes: read the flash data into RAM
                      00732 
                      00733 ;--------------------------------------------------------------------------------------
                      00734 ; The FLASH row-pair is already set up, and FSR1H already points to the RAM buffer.
                      00735 ; Now set up FSR1L as RAM buffer pointer for this hex record. The buffer address for
                      00736 ; this hex record is the address within the FLASH row-pair - the low 6 bits of the
                      00737 ; record address.
                      00738 ;
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 19
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00739 ;  FLASH_MEM set for program data, cleared otherwise (extended address stuff)
                      00740 ;  ADDRESSL = low byte of new record address
                      00741 ;  ADDRESSH = high byte of new record address - msb set means none
                      00742 ;  REC_TYPE = record type for new record
                      00743 ;  R2 = record byte count
                      00744 ;  RECOUNTH,RECOUNTL = total record count
                      00745 ;  ROWA_HIGH, ROWA_LOW = address of previous completed record (msb set means none)
                      00746 ;  FSR1H = high(RAM_BUF)
                      00747 ;--------------------------------------------------------------------------------------
00024C 520F           00748 same_row:       movf    R2,F,0                  ;0-data-byte record?
00024E E007           00749                 bz      dr_ckcum                ;yes: just check the checksum
                      00750 
000250 5005           00751                 movf    ADDRESSL,W,0            ;low byte of FLASH address      
000252 0B3F           00752                 andlw   0x3F                    ;make it a RAM buffer address
000254 6EE1           00753                 movwf   FSR1L,0 
                      00754 
                      00755 ;--------------------------------------------------------------------------------------
                      00756 ; Loop to get all R2 bytes of data in this record. We assume that all bytes
                      00757 ; within this record will fit within the same FLASH row-pair.
                      00758 ;--------------------------------------------------------------------------------------
000256 D9E6           00759 dr_data_loop:       rcall   get_rqhex2          ;get a hex data byte into W & R1
000258 6EE6           00760                     movwf   POSTINC1            ;write byte to buffer, bump pointer
00025A 2E0F           00761                     decfsz  R2,F,0              ;bump & test loop pointer
00025C D7FC           00762                     bra     dr_data_loop
                      00763 
                      00764 ;--------------------------------------------------------------------------------------
                      00765 ; Get and test the record checksum. Report checksum error if wrong.
                      00766 ;--------------------------------------------------------------------------------------
00025E D9E2           00767 dr_ckcum:       rcall   get_rqhex2              ;get checksum into Z
000260 EE00 F066      00768                 lfsr    0,cksumerror_msg        ;checksum error message
000264 A4D8           00769                 btfss   STATUS,Z,0              ;checksum should be zero
000266 D866           00770                 rcall   report_error
                      00771 
                      00772 ;--------------------------------------------------------------------------------------
                      00773 ; Report any hex errors accumulated during this record
                      00774 ;--------------------------------------------------------------------------------------
000268 B00C           00775                 btfsc   KERN_FLAGS,ERR_FLAG,0
00026A D862           00776                 rcall   hex_error
                      00777 
                      00778 ;--------------------------------------------------------------------------------------
                      00779 ; If this record has data to be loaded into FLASH, then bump RECOUNTH,RECOUNTL
                      00780 ;--------------------------------------------------------------------------------------
00026C BE06           00781                 btfsc   ADDRESSH,7,0            ;flash data record to load?
00026E D002           00782                 bra     not_written             ;no: don't bump count
                      00783 
000270 4A07           00784                 infsnz  RECOUNTL,F,0            ;bump FLASH data record count
000272 2A08           00785                 incf    RECOUNTH,F,0            ;carry to high byte if low byte is 0
000274                00786 not_written:
                      00787 ;--------------------------------------------------------------------------------------
                      00788 ; Deal with the record type.
                      00789 ;--------------------------------------------------------------------------------------
                      00790 ;was this record type 1? Done loading hex file if so. 
000274 0410           00791                 decf    REC_TYPE,W,0            ;test for REC_TYPE = 1
000276 E009           00792                 bz      load_done
                      00793 
                      00794 ;was this record type 4? if not, we are done with this record
000278 0A03           00795                 xorlw   0x03                    ;we already decremented REC_TYPE into W
00027A E1C5           00796                 bnz     wait_recstart           ;not type 4: done with this record
                      00797 
                      00798 ;This was a type 4 record. Set FLASH_MEM if record data = 0000 (FLASH memory space)
                      00799 
00027C 920C           00800                 bcf     KERN_FLAGS,FLASH_MEM,0
                      00801 
00027E 6AE1           00802                 clrf    FSR1L,0                 ;look at first data byte
000280 50E6           00803                 movf    POSTINC1,W,0            ;and the second data byte
000282 10E7           00804                 iorwf   INDF1,W,0               ;both must be zero to select FLASH memory
000284 B4D8           00805                 btfsc   STATUS,Z,0
000286 820C           00806                 bsf     KERN_FLAGS,FLASH_MEM,0
                      00807 
000288 D7BE           00808                 bra     wait_recstart           ;with REC_TYPE = 1                              
                      00809 
                      00810 ;--------------------------------------------------------------------------------------
                      00811 ; The code load is complete. Print results, and start over
                      00812 ;--------------------------------------------------------------------------------------
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 20
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00028A EE00 F076      00813 load_done:      lfsr    0,reccount_msg      ;Loaded recs:
00028E D855           00814                 rcall   loader_printf
                      00815 
000290 C008 F00E      00816                 movff   RECOUNTH,R1         ;record count
000294 C007 F00D      00817                 movff   RECOUNTL,R0
000298 D85F           00818                 rcall   print_dec
                      00819 
00029A EE00 F08E      00820                 lfsr    0,errcount_msg      ;"errors:"
00029E D84D           00821                 rcall   loader_printf
                      00822 
0002A0 C00A F00E      00823                 movff   ERRCNTH,R1          ;error count
0002A4 C009 F00D      00824                 movff   ERRCNTL,R0
0002A8 D857           00825                 rcall   print_dec
                      00826 
0002AA D982           00827                 rcall   start_loader        ;clear counters, reprint sign-on message
0002AC D7AC           00828                 bra     wait_recstart       ;back to the beginning
                      00829 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 21
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00830     page
                      00831 ;################################################################################
                      00832 ;# UART Interrrupt Handlers                                                     #
                      00833 ;#   This services both the transmit and receive UART interrupts once.          #
                      00834 ;#   Note: interrupts cause the PIC to save W, BSR's, STATUS automatically in   #
                      00835 ;#   shadow registers. (Page 112)                                               #
                      00836 ;#   FSR2 is reserved for use by these ISRs.                                    #
                      00837 ;################################################################################
                      00838 
                      00839 ;Service the UART receive interrupt, if needed. The receive interrupt
                      00840 ;is always enabled, though the general interrupt bit may be disabled.
0002AE BA9E           00841 int_service:    btfsc   PIR1,RCIF,0         ;test for pending UART rx interrupt
0002B0 D811           00842                 rcall   rxi_service
                      00843 
                      00844 ;Service the UART transmit interrupt, if needed
0002B2 B89D           00845                 btfsc   PIE1,TXIE,0         ;is the transmit interrupt enabled?
0002B4 A89E           00846                 btfss   PIR1,TXIF,0         ;y: test for pending UART tx interrupt
0002B6 0011           00847                 retfie  1                   ;n: done. restire & return
                      00848 
                      00849 ;Fall into txi_service
                      00850 
                      00851 ;********************************************************************************
                      00852 ;* Transmit Interrupt Routine
                      00853 ;* Transmit UART character from transmit queue
                      00854 ;* If this empties the transmit queue, then turn TX interrupt off 
                      00855 ;* On Entry:
                      00856 ;*     The transmit queue is NOT empty
                      00857 ;*     Transmit is NOT blocked by XOFF
                      00858 ;*     The next chr to transmit is at TQ_OPTR
                      00859 ;* On Exit:
                      00860 ;*     if Tx queue is empty, then the transmit int is disabled via TXIE (in PIE1)
                      00861 ;*     and TQ_EMPTY is set
                      00862 ;********************************************************************************
0002B8 0E00           00863 txi_service:    movlw   high(TX_QUEUE)          ; point FSR0 to transmit queue
0002BA 6EDA           00864                 movwf   FSR2H,0
0002BC 5003           00865                 movf    TQ_OPTR,W,0
0002BE 6ED9           00866                 movwf   FSR2L,0
                      00867 
0002C0 50DF           00868                 movf    INDF2,W,0               ;get queue chr
                      00869 
0002C2 6EAD           00870                 movwf   TXREG,0                 ;transmit now
                      00871 
                      00872 ;circular-increment queue out-pointer, assuming aligned queue
                      00873                 inc_tq  TQ_OPTR
0002C4 2A03               M         incf    TQ_OPTR,F,0     ;linear increment the pointer
0002C6 9803               M         bcf     TQ_OPTR,0x4,0   ;clear any overflow
                      00874 
                      00875 ;If out-pointer now equals in-pointer, then the queue has become empty.
                      00876 ;If so, turn off transmit interrupt
0002C8 5002           00877                 movf    TQ_IPTR,W,0
0002CA 1803           00878                 xorwf   TQ_OPTR,W,0
0002CC E102           00879                 bnz     int_return
                      00880 
0002CE 820B           00881                 bsf     INT_FLAGS,TQ_EMPTY,0    ;flag that the queue is empty
0002D0 D829           00882                 rcall   mask_txint              ;mask the transmit interrupt
                      00883 
                      00884 ;-------------------------------------------------------;
                      00885 ;Restore state, and return from the interrupt
                      00886 ;-------------------------------------------------------;
0002D2 0011           00887 int_return:     retfie  1                       ;restore registers on the way out
                      00888 
                      00889 ;********************************************************************************
                      00890 ;* Receive Interrupt Subroutine
                      00891 ;*  Note: This is a subroutine that gets called only by the interrupt handler
                      00892 ;*  Note: we ignore framing and overrun errors.
                      00893 ;* On Entry:
                      00894 ;*     Character is waiting in the UART receiver
                      00895 ;*     RQ_FULL is set if the Rx queue is already full.
                      00896 ;*     The next available slot in the queue is at RQ_IPTR
                      00897 ;*     XOFF_STATE is set if transmission has already been stopped by a previously
                      00898 ;*      received XOFF character.
                      00899 ;*     PREV_CR is set if the previously received character was a CR
                      00900 ;*     PREV_LF is set if the previously received character was a LF
                      00901 ;*
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 22
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00902 ;* On Exit:
                      00903 ;*     Chr received from the UART, parity stripped, nulls ignored
                      00904 ;*     Chr is put into rx queue, if there is room (RQ_FULL = 0).
                      00905 ;*     If the queue is already full (RQ_FULL = 1), then the chr is discarded.
                      00906 ;*     RQ_FULL gets set if the receive queue has just become full.
                      00907 ;*     A LF that immediately follows a CR gets ignored. Other LFs get translated
                      00908 ;*      into CRs.
                      00909 ;*     A CR that immediately follows a LF gets ignored.
                      00910 ;*     PREV_CR and PREV_LF are used to convert CR-LF, LF-CR, and LF into just CR 
                      00911 ;*     XOFF_STATE set & transmit interrupt disabled if TX should stop due to XOFF
                      00912 ;*     XOFF_STATE cleared if it had been set and we received any non-null chr
                      00913 ;********************************************************************************
                      00914 ;point FSR0 to next empty queue space
0002D4 0E01           00915 rxi_service:    movlw   high(RX_QUEUE)
0002D6 6EDA           00916                 movwf   FSR2H,0
0002D8 5000           00917                 movf    RQ_IPTR,W,0
0002DA 6ED9           00918                 movwf   FSR2L,0
                      00919 
                      00920 ;Get received chr into W, strip parity, skip nulls
0002DC 50AE           00921                 movf    RCREG,W,0               ;get received data from UART
0002DE 0B7F           00922                 andlw   0x7f                    ;strip parity, test for null
0002E0 E012           00923                 bz      rxi_done                ;just ignore nulls
                      00924 
                      00925 ;see if transmit is blocked due to XOFF. If so, any received chr (except a null)
                      00926 ;will XON us, and we eat that character
0002E2 B00B           00927                 btfsc   INT_FLAGS,XOFF_STATE,0
0002E4 D021           00928                 bra     rxi_do_xon
                      00929 
                      00930 ;put received chr in queue. If it shouldn't go in the queue, we just won't
                      00931 ;bump the queue pointer later.
0002E6 6EDF           00932                 movwf   INDF2,0                 ;save received chr in queue
                      00933 
                      00934 ;If this is an XOFF character, then disable transmit without bumping RQ_IPTR
0002E8 0A13           00935                 xorlw   XOFF                    ;is this an xoff?
0002EA E01B           00936                 bz      rxi_do_xoff             ;if so, don't bump queue pointer
                      00937 
                      00938 ;Test for CR  which gets special treatment below
0002EC 0A1E           00939                 xorlw   XOFF ^ CR               ;Z set if chr = CR
0002EE E00C           00940                 bz      rxi_cr                  ;deal with CR
                      00941 
                      00942 ;Test for LF  which gets special treatment below
0002F0 0A07           00943                 xorlw   CR ^ LF                 ;Did we just get a LF?
0002F2 E00E           00944                 bz      rxi_lf                  ;deal with LF
                      00945 
                      00946 ;Neither CR or LF -  cancel any CRLF sequence progress
0002F4 940B           00947                 bcf     INT_FLAGS,PREV_CR,0
0002F6 960B           00948                 bcf     INT_FLAGS,PREV_LF,0
                      00949 
                      00950 ;The character is already in place in the queue. Actually enqueue the character
                      00951 ;now by bumping the in-pointer - unless the queue is full
0002F8 B80B           00952 rxi_enqueue:    btfsc   INT_FLAGS,RQ_FULL,0     ;full queue?
0002FA 0012           00953                 return                          ;full: drop chr on floor
                      00954 
                      00955                 inc_rq  RQ_IPTR                 ;circular-increment queue pointer
0002FC 2A00               M         incf    RQ_IPTR,F,0     ;linear increment the pointer
                          M                                 ;any carry gets chucked to wrap
                      00956 
                      00957 ;Set RQ_FULL if we just became full
0002FE 5000           00958                 movf    RQ_IPTR,W,0
000300 1801           00959                 xorwf   RQ_OPTR,W,0             ;does RQ_IPTR = RQ_OPTR?
000302 E101           00960                 bnz     rxi_done                ;n: the queue is not full
                      00961 
000304 880B           00962                 bsf     INT_FLAGS,RQ_FULL,0     ;y: note full queue
                      00963 
                      00964 ;Done with receive interrupt, so return
000306 0012           00965 rxi_done:       return
                      00966 
                      00967 ;------------------------------------------------------------------------------
                      00968 ; Translate CR-LF into CR. This requires looking at the state from the previous
                      00969 ; chr, and remembering the state of this chr for next time.
                      00970 ;------------------------------------------------------------------------------
000308 B60B           00971 rxi_cr:         btfsc   INT_FLAGS,PREV_LF,0     ;LF following a CR?
00030A D008           00972                 bra     rxi_crlfdone            ;yes: end of sequence
                      00973 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 23
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00030C 840B           00974                 bsf     INT_FLAGS,PREV_CR,0     ;remember that we got a fresh CR
00030E D7F4           00975                 bra     rxi_enqueue             ;go bump queue pointer to enqueue
                      00976 
                      00977 ;------------------------------------------------------------------------------
                      00978 ; Translate LF-CR into CR. This requires looking at the state from the previous
                      00979 ; chr, and remembering the state of this chr for next time.
                      00980 ;------------------------------------------------------------------------------
000310 B40B           00981 rxi_lf:         btfsc   INT_FLAGS,PREV_CR,0     ;LF following a CR?
000312 D004           00982                 bra     rxi_crlfdone            ;yes:deal with sequence
                      00983 
000314 0E0D           00984                 movlw   CR                      ;translate LF into CR
000316 6EDF           00985                 movwf   INDF2,0
                      00986 
000318 860B           00987                 bsf     INT_FLAGS,PREV_LF,0     ;remember that we got a LF
00031A D7EE           00988                 bra     rxi_enqueue             ;go bump queue pointer to enqueue
                      00989 
                      00990 ;------------------------------------------------------------------------------
                      00991 ; We've just completed a CR-LF or LF-CR sequence, deliberately not enqueing
                      00992 ; the second chr of one of these sequences. Now, reset state.
                      00993 ;------------------------------------------------------------------------------
00031C 940B           00994 rxi_crlfdone:   bcf     INT_FLAGS,PREV_CR,0     ;end of sequence
00031E 960B           00995                 bcf     INT_FLAGS,PREV_LF,0
000320 0012           00996                 return                          ;don't bump queue pointer
                      00997                 
                      00998 ;------------------------------------------------------------------------------
                      00999 ; Disable transmit because of XOFF received
                      01000 ;------------------------------------------------------------------------------
000322 800B           01001 rxi_do_xoff:    bsf     INT_FLAGS,XOFF_STATE,0  ;set XOFF flag
                      01002 
                      01003 ;fall into mask_txint
                      01004 
                      01005 ;------------------------------------------------------------------------------
                      01006 ; Local subroutine to mask the transmit interrupt
                      01007 ;------------------------------------------------------------------------------
000324 989D           01008 mask_txint:     bcf     PIE1,TXIE,0             ;mask tx interrupt          
000326 0012           01009                 return
                      01010 
                      01011 ;------------------------------------------------------------------------------
                      01012 ; Clear XOFF state, and re-enable transmit interrupt unless queue is empty
                      01013 ;------------------------------------------------------------------------------
000328 900B           01014 rxi_do_xon:     bcf     INT_FLAGS,XOFF_STATE,0  ;clear XOFF flag
                      01015 
                      01016 ;if the queue is not empty, return with transmit interrupt enabled
00032A A20B           01017                 btfss   INT_FLAGS,TQ_EMPTY,0
00032C 889D           01018                 bsf     PIE1,TXIE,0             ;not empty: unmask tx interrupt
                      01019 
00032E 0012           01020                 return
                      01021 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 24
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01022     page
                      01023 ;################################################################################
                      01024 ;# Subroutines
                      01025 ;################################################################################
                      01026 
                      01027 ;*==============================================================================*
                      01028 ; Subroutines to report load errors
                      01029 ; On entry at report_error:
                      01030 ;     FSR0H:FSR0L = message address
                      01031 ; On Exit:
                      01032 ;     W = 0
                      01033 ;     R0, R1, FSR0, TBLPTRL, TBLPTRH, TABLAT trashed
                      01034 ;*==============================================================================*
000330 EE00 F05E      01035 hex_error:      lfsr    0,hexerror_msg      ;hex character error
                      01036 
000334 2A09           01037 report_error:   incf    ERRCNTL,F,0
000336 B4D8           01038                 btfsc   STATUS,Z,0
000338 2A0A           01039                 incf    ERRCNTH,F,0
                      01040 
                      01041 ; fall into loader_printf, with message address in FSR0
                      01042 
                      01043 ;*==============================================================================*
                      01044 ;Subroutine to print string at FSR0
                      01045 ;*==============================================================================*
                      01046 
00033A CFE9 FFF6      01047 loader_printf:  movff   FSR0L,TBLPTRL
00033E CFEA FFF7      01048                 movff   FSR0H,TBLPTRH
                      01049 
                      01050 ;Fall into printf
                      01051 
                      01052 ;************************************===========================================*
                      01053 ;* Externally Accessible Subroutine *
                      01054 ;************************************
                      01055 ; Subroutine to print null-terminated strings
                      01056 ;
                      01057 ; String chrs are packed 2 to a 16-bit word, as the PIC assembler likes to do.
                      01058 ; The second (odd) byte may be a zero, if 2 strings were concactenated. The string
                      01059 ; is terminated by an even byte being 0. (A null odd byte will be ignored.)
                      01060 ; All CR's get translated to CR-LF by printw. 
                      01061 ; The receive interrupt is masked while the string is enqueued, so it goes in
                      01062 ; without echos interspersed. This makes error messages during hex loading
                      01063 ; look pretty. Note that long strings may cause us to miss rx characters.
                      01064 ; On Entry
                      01065 ;     TBLPTRH:TBLPTRL = address of string
                      01066 ; On Exit:
                      01067 ;     W = 0
                      01068 ;     R0 = last printed character, except CR, which will return LF
                      01069 ;     TBLPTRU = 0
                      01070 ;     TBLPTRH:TBLPTRL points to the next character after the terminating null
                      01071 ;     FSR0, TABLAT trashed
                      01072 ;     Receive interrupt (RCIE) is enabled
                      01073 ;*==============================================================================*
000342 6AF8           01074 printf:     clrf    TBLPTRU,0               ;there's nothing above 64K  
000344 9A9D           01075             bcf     PIE1,RCIE,0             ;mask receive interrupts
                      01076 
                      01077 ;print loop - terminates on even-byte null (when the first byte of a word is 0)
000346 0009           01078 printf_loop:    tblrd*+
000348 50F5           01079                 movf    TABLAT,W,0          ;get string byte, test for 0
00034A E002           01080                 bz      p_null
                      01081 
00034C D838           01082                 rcall   printw              ;print character from W
00034E D7FB           01083                 bra printf_loop
                      01084 
                      01085 ;check for an even-byte null, the string termination. Ignore null otherwise.
000350 A0F6           01086 p_null:         btfss   TBLPTRL,0,0         ;test TBLPTR bit 0 (has been post-incremented)
000352 D7F9           01087                 bra     printf_loop         ;clear means previous byte was odd
                      01088 
000354 8A9D           01089             bsf     PIE1,RCIE,0             ;unmask receive interrupts
000356 0012           01090             return
                      01091 
                      01092 ;************************************===========================================*
                      01093 ;* Externally Accessible Subroutine *
                      01094 ;************************************
                      01095 ; Subroutine to print R1:R0 as a a decimal value, with leading zeros suppressed
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 25
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01096 ; On Entry:
                      01097 ;     byte to send is in W
                      01098 ; On Exit:
                      01099 ;     W,R0,R1,R2,PRODH:PRODL,FSR0,INP_FLAG trashed
                      01100 ;*==============================================================================*
000358 820C           01101 print_dec:      bsf     KERN_FLAGS,INP_FLAG,0   ;suppress leading zeros
                      01102 
00035A C00E FFF4      01103                 movff   R1,PRODH                ;use PRODH & PRODL as temps
00035E C00D FFF3      01104                 movff   R0,PRODL
                      01105 
000362 0E27           01106                 movlw   high(.10000)            ;sw\et up divisor
000364 6E0E           01107                 movwf   R1,0
000366 0E10           01108                 movlw   low(.10000)
000368 6E0D           01109                 movwf   R0,0
00036A D80E           01110                 rcall   pddigit
                      01111 
00036C 0E03           01112                 movlw   high(.1000)
00036E 6E0E           01113                 movwf   R1,0
000370 0EE8           01114                 movlw   low(.1000)
000372 6E0D           01115                 movwf   R0,0
000374 D809           01116                 rcall   pddigit
                      01117 
000376 6A0E           01118                 clrf    R1,0
000378 0E64           01119                 movlw   .100
00037A 6E0D           01120                 movwf   R0,0
00037C D805           01121                 rcall   pddigit
                      01122 
00037E 0E0A           01123                 movlw   .10
000380 6E0D           01124                 movwf   R0,0
000382 D802           01125                 rcall   pddigit
                      01126 
000384 50F3           01127                 movf    PRODL,W,0           ;always print last digit
000386 D010           01128                 bra     pascdig
                      01129 
                      01130 ;------------------------------------------------------------
                      01131 ; Local subroutine to calculate and print one decimal digit
                      01132 ; On Entry:
                      01133 ;   PRODH:PRODL = quotiant
                      01134 ;   R1:R0 = divisor
                      01135 ;   INP_FLAG set if leading zeros are to be suppressed
                      01136 ; On Exit:
                      01137 ;   PRODH:PRODL = remainder
                      01138 ;   INP_FLAG cleared if result is not 0
                      01139 ; Trashes R2
                      01140 ;------------------------------------------------------------
000388 680F           01141 pddigit:    setf    R2,0                    ;start dividend as -1
                      01142 
00038A 2A0F           01143 pdigloop:       incf    R2,F,0              ;compute dividend
00038C 500D           01144                 movf    R0,W,0
00038E 5EF3           01145                 subwf   PRODL,F,0
000390 500E           01146                 movf    R1,W,0
000392 5AF4           01147                 subwfb  PRODH,F,0
000394 E2FA           01148                 bc      pdigloop
                      01149 
000396 500D           01150             movf    R0,W,0                  ;the above loop goes once too many times
000398 26F3           01151             addwf   PRODL,F,0               ;..so correct the remainder here
00039A 500E           01152             movf    R1,W,0
00039C 22F4           01153             addwfc  PRODH,F,0
                      01154 
00039E 500F           01155             movf    R2,W,0                  ;dividend
0003A0 A4D8           01156             btfss   STATUS,Z,0              ;if not zero then end leading zero suppression
0003A2 920C           01157             bcf     KERN_FLAGS,INP_FLAG,0
                      01158 
0003A4 B20C           01159             btfsc   KERN_FLAGS,INP_FLAG,0   ;leading zero to suppress?
0003A6 0012           01160             return                          ;y: don't print it
                      01161 
0003A8 0F30           01162 pascdig:    addlw   '0'                     ;make it ASCII
0003AA D009           01163             bra     printw                  ;print and return from there (trashes R0)
                      01164 
                      01165 ;************************************===========================================*
                      01166 ;* Externally Accessible Subroutine *
                      01167 ;************************************
                      01168 ; Subroutine to print W as a 2-character hex value
                      01169 ; On Entry:
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 26
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01170 ;     byte to send is in W
                      01171 ; On Exit:
                      01172 ;     W, R0, R1, FSR0 trashed
                      01173 ;*==============================================================================*
0003AC 6E0E           01174 print_hex2:     movwf   R1,0                    ;temp save low nibble
0003AE 380E           01175                 swapf   R1,W,0                  ;high byte in low nibble of W
0003B0 D801           01176                 rcall   print_hex1              ;send the high nibble
                      01177 
0003B2 500E           01178                 movf    R1,W,0                  ;now the low nibble
                      01179 
                      01180 ;fall into print_hex1
                      01181 
                      01182 ;************************************===========================================*
                      01183 ;* Externally Accessible Subroutine *
                      01184 ;************************************
                      01185 ; Subroutine to print one hex digit from the low nibble of W
                      01186 ; On Entry:
                      01187 ;     W low nibble = value to transmit
                      01188 ; On Exit:
                      01189 ;     W, FSR0 trashed
                      01190 ;     R0 = chr
                      01191 ;*==============================================================================*
                      01192 ;tricky binary to ASCII hex conversion
0003B4 0B0F           01193 print_hex1:     andlw   0x0f                    ;W=just the low nibble
0003B6 0809           01194                 sublw   0x09                    ;W=9-nib. is value greater than 9?
0003B8 B0D8           01195                 btfsc   STATUS,C,0              ;C set means <=9            
0003BA 0F07           01196                 addlw   'A'-'9' - 1             ;W=gap+9-nib
0003BC 0840           01197                 sublw   '0' + 'A'-'9' + 0x08    ;W='0'+gap+9(-gap)-9+nib
                      01198                                                 ;W='0'(+gap)+nib
                      01199 ;fall into printw to enqueue character in W
                      01200 
                      01201 ;************************************===========================================*
                      01202 ;* Externally Accessible Subroutine *
                      01203 ;************************************
                      01204 ; Subroutine to print W
                      01205 ;    Carriage returns (CR) get translated into CR-LF
                      01206 ;    If W = XOFF or W = XON, then cancel any XOFF state on our transmitter side
                      01207 ; On Entry at printw:
                      01208 ;     W = chr to transmit
                      01209 ; On Entry at printr0 (not externally accessable):
                      01210 ;     R0 = chr to transmit
                      01211 ; On Exit:
                      01212 ;     W, FSR0 trashed
                      01213 ;     R0 = printed chr, except for CR - which returns with LF
                      01214 ;*==============================================================================*
0003BE 6E0D           01215 printw:         movwf   R0,0                        ;save chr in R0
                      01216 
0003C0 0E00           01217 printr0:        movlw   high(TX_QUEUE)              ;point FSR0 to transmit queue
0003C2 6EEA           01218                 movwf   FSR0H,0
                      01219 
                      01220 ;See if tx queue is full, and stall if it is.
                      01221 ;The queue is full if TQ_IPTR = TQ_OPTR and the queue is not empty.         
0003C4 5002           01222 pw_wait_txq:        movf    TQ_IPTR,W,0             ;now check for full queue
0003C6 6EE9           01223                     movwf   FSR0L,0                 ;and set up queue pointer low byte
0003C8 1803           01224                     xorwf   TQ_OPTR,W,0             ;Z set for empty or completely full
0003CA E102           01225                     bnz     pw_room                 ;no - then not full!
                      01226 
0003CC A20B           01227                     btfss   INT_FLAGS,TQ_EMPTY,0    ;in-pointer = out-pointer. Empty?
0003CE D7FA           01228                     bra     pw_wait_txq             ;no: the queue is full
0003D0                01229 pw_room:
                      01230 ;put the character into the queue
0003D0 500D           01231                 movf    R0,W,0                      ;recover chr to print
0003D2 6EEF           01232                 movwf   INDF0,0                     ;put chr in the queue
                      01233 
                      01234 ;mask all interrupts while we mess with the queue pointer and flags
0003D4 9EF2           01235                 bcf     INTCON,GIE,0
                      01236 
                      01237 ;if we are sending an XOFF or XON character, and if we are XOFF'd from transmitting,
                      01238 ;then undo XOFF state so that this XOFF or XON will actually get sent.
0003D6 0A13           01239                 xorlw   XOFF                        ;set Z if XOFF
0003D8 A4D8           01240                 btfss   STATUS,Z,0
0003DA 0A02           01241                 xorlw   XOFF ^ XON                  ;set Z if XON
0003DC B4D8           01242                 btfsc   STATUS,Z,0
0003DE 900B           01243                 bcf     INT_FLAGS,XOFF_STATE,0      ;undo any transmit-side XOFF
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 27
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01244 
                      01245 ;circular-increment the queue pointer
                      01246                 inc_tq  TQ_IPTR
0003E0 2A02               M         incf    TQ_IPTR,F,0     ;linear increment the pointer
0003E2 9802               M         bcf     TQ_IPTR,0x4,0   ;clear any overflow
                      01247 
0003E4 920B           01248                 bcf     INT_FLAGS,TQ_EMPTY,0        ;tell txint the queue isn't empty
                      01249 
                      01250 ;Enable the transmit interrupt unless we are XOFF'd
0003E6 A00B           01251                 btfss   INT_FLAGS,XOFF_STATE,0      ;don't enable ints if XOFF'd
0003E8 889D           01252                 bsf     PIE1,TXIE,0                 ;enable transmit interrupt
                      01253 
                      01254 ;re-enable global interrupts
0003EA 8EF2           01255                 bsf     INTCON,GIE,0
                      01256 
                      01257 ;If this chr was a CR, then send an LF too.
0003EC 500D           01258                 movf    R0,W,0                      ;recover the printed character
0003EE 0A0D           01259                 xorlw   CR                          ;was it a CR?
0003F0 A4D8           01260                 btfss   STATUS,Z,0
0003F2 0012           01261                 return                              ;n: don't need an LF
                      01262 
0003F4 0E0A           01263                 movlw   LF          
0003F6 D7E3           01264                 bra     printw                      ;y:go enqueue LF
                      01265 
                      01266 ;************************************===========================================*
                      01267 ;* Externally Accessible Subroutine *
                      01268 ;************************************
                      01269 ; Subroutine to print null-terminated the serial number
                      01270 ; On Entry:
                      01271 ; trashes W,R0,FSR0,TBLPTRH,TBLPTRL
                      01272 ;*==============================================================================*
0003F8 0E0D           01273 print_sn:   movlw   CR                  ;initial newline because of newsn_msg
0003FA ECDF F001      01274             call    printw
                      01275 
0003FE 0E00           01276             movlw   high(loader_msg)
000400 6EF7           01277             movwf   TBLPTRH
                      01278 
000402 EE00 F0B6      01279             lfsr    0,sn_msg            ;"Serial Number: "
000406 DF99           01280             rcall   loader_printf
                      01281 
000408 0E14           01282             movlw   EE_SN               ;serial number location
00040A 6EA9           01283             movwf   EEADR,0
                      01284 
                      01285 ;fall into ee_print
                      01286 
                      01287 ;************************************===========================================*
                      01288 ;* Externally Accessible Subroutine *
                      01289 ;************************************
                      01290 ;Print string from EEPROM
                      01291 ; On Entry:
                      01292 ;    EEADR = address of null-terminated string
                      01293 ;  trashes W,R0,FSR0,READR
                      01294 ;*==============================================================================*
00040C D8B1           01295 ee_print:       rcall   rd_eeprom               ;get a byte
00040E 0900           01296                 iorlw   0                       ;null termination?
000410 B4D8           01297                 btfsc   STATUS,Z,0
000412 0012           01298             return                              ;y: done
                      01299 
000414 DFD4           01300                 rcall   printw
000416 2AA9           01301                 incf    EEADR,F,0
000418 D7F9           01302                 bra     ee_print
                      01303 
                      01304 ;************************************===========================================*
                      01305 ;* Externally Accessible Subroutine *
                      01306 ;************************************
                      01307 ; Subroutine to get one character from the Receive Queue
                      01308 ; (does not echo)
                      01309 ; On Exit:
                      01310 ;     Z set, W & R0 =0 if the queue is empty
                      01311 ;     otherwise, the character is in R0 and W
                      01312 ;     FSR0 trashed
                      01313 ;     GEI is set, enabling global interrupts
                      01314 ; (2.25 uS if no characters waiting)
                      01315 ;*==============================================================================*
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 28
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00041A 5001           01316 get_rxchr:      movf    RQ_OPTR ,W,0        ;(.25) check for empty queue
00041C 6EE9           01317                 movwf   FSR0L,0             ;(.25) FSR0 will point to Rx queue
00041E 1800           01318                 xorwf   RQ_IPTR,W,0         ;(.25) set Z if either full or empty
                      01319 
000420 A80B           01320                 btfss   INT_FLAGS,RQ_FULL,0 ;(.25)queue is not empty if it is full
000422 E007           01321                 bz      gr_done             ;(.5)with Z set, W=0: nothing in the queue
                      01322 
                      01323 ;Finish pointing FSR0 at the next queue character
000424 0E01           01324                 movlw   high(RX_QUEUE)      ;finish pointing FSR0 to receive queue 
000426 6EEA           01325                 movwf   FSR0H,0
                      01326 
                      01327 ;circular-increment the Rx queue out-pointer, mask interrupts while we do
000428 9EF2           01328                 bcf     INTCON,GIE,0        ;mask all interrupts
                      01329 
                      01330                 inc_rq  RQ_OPTR             ;circular-increment out pointer (not FSR0...)
00042A 2A01               M         incf    RQ_OPTR,F,0     ;linear increment the pointer
                          M                                 ;any carry gets chucked to wrap
00042C 980B           01331                 bcf     INT_FLAGS,RQ_FULL,0 ;queue is no longer full
                      01332 
                      01333 ;Get next chr from the Rx queue at FSR0
00042E 50EF           01334                 movf    INDF0,W,0           ;get the queue chr, clear Z flag
                      01335                                             ;(since there are no nulls in the queue)
                      01336 
000430 8EF2           01337                 bsf     INTCON,GIE,0        ;unmask interrupts
                      01338 
000432 6E0D           01339 gr_done:        movwf   R0,0                ;(.25)return chr or 0 in R0 and W, Z cleared/set
000434 0012           01340                 return                      ;(.5)
                      01341 
                      01342 ;************************************===========================================*
                      01343 ;* Externally Accessible Subroutine *
                      01344 ;************************************
                      01345 ; Subroutine to get a line of input from the user, echoing as we go. ^C or ESC
                      01346 ; causes an immediate exit with ERR_FLAG set
                      01347 ; CR's are not echoed. BS and DEL allow line editing.
                      01348 ; On Entry:
                      01349 ;      W = max allowed characters
                      01350 ; On Exit:
                      01351 ;     0-terminated input line is at LINBUF.
                      01352 ;     W= 1st chr of line
                      01353 ;     FSR1 points to the beginning of LINBUF, unless control-C
                      01354 ;     CR_FLAG cleared, unless no chrs found
                      01355 ;     Z set if no bytes found or if control-C detected
                      01356 ;     ERR_FLAG set if control-C or ESC detected, cleared otherwise
                      01357 ;     trashes R0,R1 FSR0
                      01358 ;*==============================================================================*
000436 6E0E           01359 getlin:     movwf       R1,0                    ;character count-down
000438 900C           01360             bcf         KERN_FLAGS,ERR_FLAG,0   ;no control-C yet
00043A 960C           01361             bcf         KERN_FLAGS,CR_FLAG,0    ;no CR yet
00043C EE10 F060      01362             lfsr        1,LINBUF                ;FSR1 points to the line buffer
                      01363 
000440 2A0E           01364 getl1:          incf        R1,F,0              ;room for terminating 0
                      01365 
000442 DFEB           01366 getl_loop:          rcall       get_rxchr       ;chr in W and R0
000444 E0FE           01367                     bz          getl_loop       ;wait for a character
                      01368 
000446 0A0D           01369                 xorlw       CR                  ;end of input?
000448 E01C           01370                 bz          getl_done
                      01371 
00044A 0A05           01372                 xorlw       CR ^ BS             ;backspace?
00044C E00D           01373                 bz          getl_bs
                      01374 
00044E 0A77           01375                 xorlw       BS ^ DEL            ;delete?
000450 E00B           01376                 bz          getl_bs
                      01377 
000452 0A7C           01378                 xorlw       DEL ^ CTRLC         ;abort?
000454 E01D           01379                 bz          getl_abort
                      01380 
000456 0A18           01381                 xorlw       CTRLC ^ ESC         ;other kind of abort?
000458 E01B           01382                 bz          getl_abort
                      01383 
00045A 4E0E           01384                 dcfsnz      R1,F,0              ;room in buffer?
00045C D7F1           01385                 bra         getl1               ;n: chuck the character
                      01386 
00045E 500D           01387                 movf        R0,W,0              ;recover character
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 29
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000460 6EE6           01388                 movwf       POSTINC1,0          ;put chr in the line buffer, bump
                      01389 
000462 B40C           01390                 btfsc       KERN_FLAGS,ECHO_FLAG    ;echo allowed?
000464 DFAC           01391                 rcall       printw                  ;y:echo
                      01392 
000466 D7ED           01393                 bra         getl_loop           ;look for another chr
                      01394 
                      01395 ;backspace or delete encountered
                      01396 
000468 50E1           01397 getl_bs:        movf        FSR1L,W,0
00046A 0A60           01398                 xorlw       low(LINBUF)         ;zero bytes in queue?
00046C E0EA           01399                 bz          getl_loop           ;y: ignore bs
                      01400 
00046E 0E08           01401 getl_dobs:      movlw       BS                  ;back up on screen
000470 DFA6           01402                 rcall       printw
000472 0E20           01403                 movlw       ' '
000474 DFA4           01404                 rcall       printw
000476 0E08           01405                 movlw       BS
000478 ECDF F001      01406                 call        printw
                      01407 
00047C 2A0E           01408                 incf        R1,F,0              ;un-bump available byte counter
00047E 06E1           01409                 decf        FSR1L,F,0           ;dec pointer (buffer is all in same 256-byte page)
000480 D7E0           01410                 bra         getl_loop
                      01411 
                      01412 ;Got a complete line.           
000482 6AE7           01413 getl_done:  clrf        INDF1,0                 ;Install terminating null
000484 EE10 F060      01414             lfsr        1,LINBUF                ;FSR1 points to the line buffer again
                      01415 
000488 50E7           01416             movf        INDF1,W,0               ;test for 0 characters
00048A E101           01417             bnz         getl_ret
00048C 860C           01418             bsf         KERN_FLAGS,CR_FLAG,0    ;CR already detected
                      01419 
00048E 0012           01420 getl_ret:   return
                      01421 
000490 800C           01422 getl_abort: bsf         KERN_FLAGS,ERR_FLAG,0   ;control-C or ESC detected
000492 0012           01423             return
                      01424     
                      01425 ;************************************===========================================*
                      01426 ;* Externally Accessible Subroutine *
                      01427 ;************************************
                      01428 ; -->>NOTE: Entry is at ask_yn<<--
                      01429 ; Ask user yes or no
                      01430 ; On Entry:
                      01431 ;    W = max length of input line
                      01432 ; On Exit:
                      01433 ;    Z set if Y
                      01434 ;    FSR1, LINEBUF, R0 trashed
                      01435 ;*==============================================================================*
000494 0E0D           01436 ask_again:  movlw   CR              ;new line
000496 DF93           01437             rcall   printw
                      01438 
000498 EE00 F0DA      01439 ask_yn:     lfsr    0,yn_msg        ;" (Y/N)?"
00049C DF4E           01440             rcall   loader_printf
                      01441 
00049E 0E08           01442             movlw   8               ;allow more chrs than necessary
0004A0 DFCA           01443             rcall   getlin          ;get user input
0004A2 D811           01444             rcall   get_uchr        ;Get the first character from the line buffer
                      01445                                     ;and convert to uppercase
                      01446 
0004A4 0A59           01447             xorlw   'Y'             ;yes respones?
0004A6 E003           01448             bz      got_yes         ;y: return with Z flag set
                      01449 
0004A8 0A17           01450             xorlw   'Y' ^ 'N'       ;no response?
0004AA E1F4           01451             bnz     ask_again       ;n: it's garbage. ask again
                      01452 
0004AC 94D8           01453             bcf     STATUS,Z        ;clear Z: we got a no       
                      01454 
                      01455 ;Z flag set if 'y', cleared of 'n'
0004AE 0012           01456 got_yes:    return
                      01457 
                      01458 ;************************************===========================================*
                      01459 ;* Externally Accessible Subroutine *
                      01460 ;************************************
                      01461 ; Check for an abort (either Control-C or ESC) from the user
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 30
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01462 ; On Exit:
                      01463 ;   Z set if no character found
                      01464 ;   Carry set if abort character found
                      01465 ;   W=R0=found character (if Z set)
                      01466 ; (4 uS if no chr waiting)
                      01467 ;*==============================================================================*
0004B0 DFB4           01468 chk_abort:      rcall   get_rxchr           ;(.5 + 2.25 if no chr)returns chr in R0 and W
0004B2 90D8           01469                 bcf     STATUS,C,0          ;(.25)no abort found yet
0004B4 E007           01470                 bz      ca_done             ;(.5)Z flag set if no input
                      01471 
0004B6 0A03           01472                 xorlw   CTRLC               ;abort?
0004B8 E002           01473                 bz      ca_abort
                      01474 
0004BA 0A18           01475                 xorlw   CTRLC ^ ESC         ;esc will abort too
0004BC B4D8           01476                 btfsc   STATUS,Z,0
                      01477 
0004BE 80D8           01478 ca_abort:       bsf     STATUS,C,0          ;carry means abort found
                      01479 
0004C0 500D           01480                 movf    R0,W,0              ;recover typed character
0004C2 94D8           01481                 bcf     STATUS,Z,0          ;indicate chr found
0004C4 0012           01482 ca_done:        return                      ;(.5)
                      01483 
                      01484 ;************************************===========================================*
                      01485 ;* Externally Accessible Subroutine *
                      01486 ;************************************
                      01487 ; Get one character from the Line Buffer, and convert it to uppercase,
                      01488 ; if necessary.
                      01489 ; On Entry:
                      01490 ;    FSR1 points to the next chr in the line buffer
                      01491 ; On Exit:
                      01492 ;    The next line buffer chr is in W & R0. Note that a CR is represented as 0.
                      01493 ;    FSR0 trashed
                      01494 ;    FSR1 incremented
                      01495 ;    CR_FLAG set if this chr is a CR
                      01496 ;*==============================================================================*
0004C6 D806           01497 get_uchr:   rcall   get_chr             ;get a chr from the line buffer into W & R0
                      01498 
                      01499 ;Convert any lowercase to uppercase
0004C8 087A           01500             sublw   'z'                 ;above lowercase z?
0004CA E302           01501             bnc     case_ok             ;yes: don't try to change case
                      01502 
0004CC BC0D           01503             btfsc   R0,0x06,0           ;if bit 6 is set, then clear bit 5
0004CE 9A0D           01504             bcf     R0,0x05,0           ;that makes it uppercase
                      01505 
0004D0 500D           01506 case_ok:    movf    R0,W,0              ;get chr into W too
0004D2 0012           01507             return
                      01508 
                      01509 ;************************************===========================================*
                      01510 ;* Externally Accessible Subroutine *
                      01511 ;************************************
                      01512 ; Get one character from the Line Buffer
                      01513 ; Note that the Line Buffer always terminates with a CR
                      01514 ; On Entry:
                      01515 ;    FSR1 points to the next chr in the line buffer
                      01516 ;    CR_FLAG is set if the CR for this line's already been found
                      01517 ; On Exit:
                      01518 ;    The next line buffer chr is in W & R0. Note that a CR is represented as 0.
                      01519 ;    FSR0 trashed
                      01520 ;    FSR1 incremented
                      01521 ;    CR_FLAG set if this chr is the end of the line (a null caused by a typed CR) 
                      01522 ;*==============================================================================*
0004D4 0E00           01523 get_chr:    movlw   0x00                        ;alread found this line's CR?
0004D6 B60C           01524             btfsc   KERN_FLAGS,CR_FLAG,0
0004D8 D003           01525             bra     gchr_done
                      01526 
0004DA 50E6           01527             movf    POSTINC1,W,0                ;also test for 0, meaning CR
0004DC B4D8           01528             btfsc   STATUS,Z,0
0004DE 860C           01529             bsf     KERN_FLAGS,CR_FLAG,0        ;it's a CR
                      01530 
0004E0 6E0D           01531 gchr_done:  movwf   R0,0
0004E2 0012           01532             return
                      01533     
                      01534 ;************************************===========================================*
                      01535 ;* Externally Accessible Subroutine *
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 31
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01536 ;************************************
                      01537 ; Get a decimal number, less than 256
                      01538 ; On Entry:
                      01539 ;    FSR1 points to the next character of an input line. The decimal
                      01540 ;    number is terminated by either a null or a space.
                      01541 ;    CR_FLAG set if the CR for this line has already been found
                      01542 ; On Exit:
                      01543 ;   W = PRODL = input value in binary, defaults to 0
                      01544 ;   ERR_FLAG set if any sort of error
                      01545 ;   INP_FLAG set if value found
                      01546 ;    CR_FLAG set if the CR for this line has been found
                      01547 ; Trashes R0,PRODH
                      01548 ;*==============================================================================*
0004E4 900C           01549 get_dec:    bcf     KERN_FLAGS,ERR_FLAG,0       ;no errors yet
0004E6 920C           01550             bcf     KERN_FLAGS,INP_FLAG,0       ;no input yet
0004E8 6AF3           01551             clrf    PRODL,0                     ;result so far
                      01552 
0004EA DFF4           01553 gd_loop:        rcall   get_chr                 ;get the next character into R0 and W
0004EC B60C           01554                 btfsc   KERN_FLAGS,CR_FLAG,0    ;end of input line?
0004EE D00F           01555                 bra     gd_exit                 ;normal exit
                      01556 
0004F0 0A20           01557                 xorlw   ' '                     ;end of parameter?
0004F2 E00D           01558                 bz  gd_exit                     ;normal exit
                      01559 
0004F4 820C           01560                 bsf     KERN_FLAGS,INP_FLAG,0   ;remember that input was found
                      01561 
0004F6 0E30           01562                 movlw   '0'                     ;de-ASCII
0004F8 5E0D           01563                 subwf   R0,F,0
                      01564 
0004FA 0E0A           01565                 movlw   .10                     ;previous digits * 10
0004FC 02F3           01566                 mulwf   PRODL,0
                      01567 
0004FE 5C0D           01568                 subwf   R0,W,0                  ;Is new digit legal ASCII decimal?
000500 E205           01569                 bc      gd_error
                      01570 
000502 500D           01571                 movf    R0,W,0                  ;add in new digit
000504 26F3           01572                 addwf   PRODL,F,0
000506 E202           01573                 bc      gd_error                ;overflow?
                      01574 
000508 52F4           01575                 movf    PRODH,F,0               ;overflow from multiply?
00050A E0EF           01576                 bz      gd_loop                 ;n: get another digit
                      01577 
00050C 800C           01578 gd_error:   bsf     KERN_FLAGS,ERR_FLAG,0       ;note error
                      01579 
00050E 50F3           01580 gd_exit:    movf    PRODL,W,0                   ;result to W for return
000510 0012           01581             return
                      01582 
                      01583 ;************************************===========================================*
                      01584 ;* Externally Accessible Subroutine *
                      01585 ;************************************
                      01586 ; Get a multi-character hex parameter value from the Line Buffer, skipping spaces
                      01587 ; and ignoring leading zeros. Returns default 0000 if there is no parameter.
                      01588 ; digits preceding the last 4 are ignored. This routine is not case-sensitive:
                      01589 ; lowercase is treated as uppercase.
                      01590 ; On Entry:
                      01591 ;    FSR1 points to the next chr in the line buffer
                      01592 ;    CR_FLAG set if the CR for this line has already been found
                      01593 ; On Exit:
                      01594 ;    FSR1 has been incremented as needed
                      01595 ;    R0 trashed
                      01596 ;    R1 = low byte of input value
                      01597 ;    R2 = high byte of input value
                      01598 ;    R1 & R2 = 0 if CR for this input has already been reached 
                      01599 ;    ERR_FLAG set if non-hex character found
                      01600 ;    CR_FLAG set if CR found
                      01601 ;    INP_FLAG set if a value is found - cleared if defaulting to 0
                      01602 ;*==============================================================================*
000512 920C           01603 get_lbhex4:     bcf     KERN_FLAGS,INP_FLAG,0   ;no characters yet
000514 900C           01604                 bcf     KERN_FLAGS,ERR_FLAG,0   ;no hex errors yet
000516 6A0E           01605                 clrf    R1,0                    ;value is 0 so far
000518 6A0F           01606                 clrf    R2,0
00051A B60C           01607                 btfsc   KERN_FLAGS,CR_FLAG,0    ;already found end of line?
00051C 0012           01608                 return                          ;return with R3:R1=0 if so
                      01609 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 32
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01610 ;skip over any leading spaces
00051E DFD3           01611 gh4_skipspace:      rcall   get_uchr                ;result in W & R0
                      01612 
000520 0A20           01613                     xorlw   ' '                     ;ignore leading spaces
000522 E0FD           01614                     bz      gh4_skipspace
                      01615 
                      01616 ;R0 = 1st new digit from LINBUF
                      01617 ;loop to get digits until space or CR. Throw away high digits (more than 4)
000524 B60C           01618 gh4_getdigit:       btfsc   KERN_FLAGS,CR_FLAG,0    ;CR ends us
000526 0012           01619                 return
                      01620 
000528 820C           01621                     bsf     KERN_FLAGS,INP_FLAG,0   ;remember that we found some user input
                      01622 
00052A 0E0F           01623                     movlw   0x0f
00052C 160F           01624                     andwf   R2,F,0                  ;chuck (clear) old high nibble of high byte
00052E 0EF0           01625                     movlw   0xf0
000530 140E           01626                     andwf   R1,W,0                  ;peel off the high nibble of the low byte
                      01627 
000532 120F           01628                     iorwf   R2,F,0                  ;combine the new highest remaining 2 nibbles
000534 3A0F           01629                     swapf   R2,F,0                  ;put the 2 highest nibbles in the right order
                      01630 
000536 D87F           01631                     rcall   hex2bin                 ;convert new chr in R0 into low nibble of R1 & W
000538 E204           01632                     bc      gh4_error               ;C set means hex character error
                      01633 
00053A DFC5           01634                     rcall   get_uchr                ;get another chr - result in W & R0
                      01635 
00053C 0A20           01636                     xorlw   ' '                     ;trailing space ends us
00053E E1F2           01637                     bnz     gh4_getdigit
                      01638 
000540 0012           01639                 return
                      01640 
000542 800C           01641 gh4_error:      bsf     KERN_FLAGS,ERR_FLAG,0       ;indicate hex error
000544 0012           01642                 return
                      01643 
                      01644             
                      01645 ;************************************===========================================*
                      01646 ;* Externally Accessible Subroutine *
                      01647 ;************************************
                      01648 ; Read SRAM
                      01649 ; On Entry:
                      01650 ;    ADDRESSH:ADDRESSL = SRAM address
                      01651 ; On Exit:
                      01652 ;    W=SRAM data
                      01653 ;    R0 trashed
                      01654 ;(about 15.25 uS)
                      01655 ;*==============================================================================*
000546 0E03           01656 rd_sram:    movlw   SRAM_DREAD          ;(.25)data read command
000548 D002           01657             bra     rw_sram             ;(.25) combined code
                      01658 
                      01659 ;************************************===========================================*
                      01660 ;* Externally Accessible Subroutine *
                      01661 ;************************************
                      01662 ; Write SRAM
                      01663 ; On Entry:
                      01664 ;    ADDRESSH:ADDRESSL = SRAM address
                      01665 ;    W=SRAM data
                      01666 ; On Exit:
                      01667 ;    W, R0, R1 trashed
                      01668 ; About 15.25 uS
                      01669 ;*==============================================================================*
00054A 6E0E           01670 wr_sram:    movwf   R1,0                    ;(.25)save write data
00054C 0E02           01671             movlw   SRAM_DWRITE         ;(.25)SRAM data write command
                      01672 
                      01673 ;Fall into rw_sram
                      01674 
                      01675 ;*==============================================================================*
                      01676 ;Subroutine to read or write to SRAM
                      01677 ; On Entry:
                      01678 ;    ADDRESSH:ADDRESSL = SRAM address
                      01679 ;    R1=SRAM write data for writes, dummy write data for reads
                      01680 ;    W=SRAM_DREAD or SRAM_DWRITE
                      01681 ; On Exit:
                      01682 ;    W = SPI data (SRAM data for reads, trash for writes)
                      01683 ;    R0,R1 trashed
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 33
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01684 ; About 14.75 uS
                      01685 ;*==============================================================================*
00054E 928B           01686 rw_sram:    bcf     LATC,SRAM_CEn,0     ;(.25)enable SRAM
000550 CFC9 F00D      01687             movff   SSPBUF,R0           ;(.25)flush SPI interface, clear BF bit
                      01688 
000554 6EC9           01689             movwf   SSPBUF,0            ;(.25)read or write command to SPI
000556 D838           01690             rcall   wait_spi            ;(.5+2.75=3.25)
                      01691 
000558 C006 FFC9      01692             movff   ADDRESSH,SSPBUF     ;(.25)high address byte
00055C D835           01693             rcall   wait_spi            ;(.5+2.75=3.25)
                      01694 
00055E C005 FFC9      01695             movff   ADDRESSL,SSPBUF     ;(.25)low address byte
000562 D832           01696             rcall   wait_spi            ;(.5+2.75=3.25)
                      01697 
000564 C00E FFC9      01698             movff   R1,SSPBUF           ;(.25)write data (for writes)
                      01699                                         ;..or dummy data (for reads)
000568 D82F           01700             rcall   wait_spi            ;(2.75)wait for write to complete
                      01701 
00056A 828B           01702             bsf     LATC,SRAM_CEn,0     ;(.25)disable SRAM
00056C 0012           01703             return                      ;(.5)
                      01704 
                      01705 ;************************************===========================================*
                      01706 ;* Externally Accessible Subroutine *
                      01707 ;************************************
                      01708 ; Read EEPROM (Page 95)
                      01709 ; On Entry at rd_epromw:
                      01710 ;    W = EEPROM address
                      01711 ; On Entry at rd_eprom:
                      01712 ;    EEADR = EEPROM address
                      01713 ; On Exit:
                      01714 ;    W=EEPROM data
                      01715 ;    Z set if data is 0
                      01716 ;    EEADR = specified address
                      01717 ; (1.75 uS)
                      01718 ;*==============================================================================*
00056E 6EA9           01719 rd_eepromw: movwf   EEADR,0         ;(.25)
                      01720 
000570 9EA6           01721 rd_eeprom:  bcf     EECON1,EEPGD,0  ;(.25)point to EEPROM
000572 9CA6           01722             bcf     EECON1,CFGS,0   ;(.25)not config ROM
000574 80A6           01723             bsf     EECON1,RD,0     ;(.25)initiate read operation
000576 50A8           01724             movf    EEDATA,W,0      ;(.25)read EEPROM, test for 0
                      01725 
000578 0012           01726             return                  ;(.50)result in W
                      01727 
                      01728 ;************************************===========================================*
                      01729 ;* Externally Accessible Subroutine *
                      01730 ;************************************
                      01731 ; Write EEPROM (Page 95)
                      01732 ; On Entry:
                      01733 ;    EEADR = EEPROM address
                      01734 ;    W=EEPROM data
                      01735 ; On Exit:
                      01736 ;    Interrupts are enabled (GIE is set)
                      01737 ;    W trashed
                      01738 ;*==============================================================================*
00057A 98A1           01739 wr_eeprom:  bcf     PIR2,EEIF       ;clear "write done" flag (page 95)
                      01740 
00057C 6EA8           01741             movwf   EEDATA,0        ;data to write
                      01742 
00057E 9EF2           01743             bcf     INTCON,GIE,0    ;disable interrupts
                      01744 
000580 0E04           01745             movlw   (1 << WREN)     ;Set up for EEPROM write
000582 6EA6           01746             movwf   EECON1,0
                      01747 
000584 0E55           01748             movlw   0x55            ;Write unlock sequence
000586 6EA7           01749             movwf   EECON2,0
000588 0EAA           01750             movlw   0xAA
00058A 6EA7           01751             movwf   EECON2,0
00058C 82A6           01752             bsf     EECON1,WR,0     ;write now
                      01753 
00058E 94A6           01754             bcf     EECON1,WREN,0   ;disable writes
                      01755 
000590 8EF2           01756             bsf     INTCON,GIE,0    ;enable interrupts
                      01757 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 34
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01758 ;wait for the write operation to complete  (per page 95)
000592 A8A1           01759 wait_wre:       btfss   PIR2,EEIF,0
000594 D7FE           01760                 bra     wait_wre
                      01761 
000596 0012           01762             return
                      01763 
                      01764 ;************************************===========================================*
                      01765 ;* Externally Accessible Subroutine *
                      01766 ;************************************
                      01767 ; Stall for about W * 25 mS
                      01768 ; On Exit:
                      01769 ;      R0,R1,W cleared
                      01770 ;*==============================================================================*
000598 6E0E           01771 stall_25ms:     movwf   R1,0
00059A 0E64           01772 s25_loop:           movlw   .100
00059C D803           01773                     rcall   stall_250us
00059E 2E0E           01774                     decfsz  R1,F,0
0005A0 D7FC           01775                     bra     s25_loop
0005A2 0012           01776                 return
                      01777 
                      01778 ;************************************===========================================*
                      01779 ;* Externally Accessible Subroutine *
                      01780 ;************************************
                      01781 ; Stall for about 250 * W uS
                      01782 ; On Exit:
                      01783 ;      R0,R1,W cleared
                      01784 ;*==============================================================================*
0005A4 6E0D           01785 stall_250us:    movwf   R0,0            ;(0.25)
                      01786 
0005A6 0EF8           01787 s250_loop:          movlw   .248        ;(0.25) (250 inner loop)
0005A8 DD4A           01788                     rcall   stall_1us   ;(249.00)
0005AA 2E0D           01789                     decfsz  R0,F,0      ;(0.25)
0005AC D7FC           01790                     bra     s250_loop   ;0.50)
                      01791 
0005AE 0012           01792                 return                  ;(.5)
                      01793 
                      01794 ;*==============================================================================*
                      01795 ; Subroutine to start the loader
                      01796 ; On Exit:
                      01797 ;     ERRCNTH, ERRCNTL = 0000
                      01798 ;     RECOUNTH, RECOUNTL = 0000
                      01799 ;     FLASH_MEM = 0
                      01800 ;     msb of ROWA_HIGH = 1, indicating the previous row wasn't FLASH data
                      01801 ;     FSR1H = high(RAM_BUF)
                      01802 ;     R0 = last printed character of loader_msg
                      01803 ;     R1, FSR0, TBLPTRL, TBLPTRH, TABLAT trashed
                      01804 ;*==============================================================================*
0005B0                01805 start_loader:
                      01806 ;Print the serial number
0005B0 DF23           01807                 rcall   print_sn
                      01808 
0005B2 6A09           01809                 clrf    ERRCNTL,0           ;no errors yet
0005B4 6A0A           01810                 clrf    ERRCNTH,0
                      01811 
0005B6 6A07           01812                 clrf    RECOUNTL,0          ;RECOUNTL,HIGH counts hex records
0005B8 6A08           01813                 clrf    RECOUNTH    ,0          ;...actually loaded into FLASH
                      01814 
0005BA 920C           01815                 bcf     KERN_FLAGS,FLASH_MEM,0  ;not in FLASH space yet
                      01816 
0005BC 8E12           01817                 bsf     ROWA_HIGH,7,0           ;previous record wasn't a FLASH data record
                      01818 
0005BE 0E02           01819                 movlw   high(RAM_BUF)           ;set up FSR1 as data pointer (never changes)
0005C0 6EE2           01820                 movwf   FSR1H,0                 ;data gets stored in RAM buffer
                      01821 
0005C2 EE00 F048      01822                 lfsr    0,loader_msg            ; print sign-on message
0005C6 D6B9           01823                 bra     loader_printf           ;return from there
                      01824 
                      01825 ;==============================================================================
                      01826 ; Subroutine to wait for the SRAM to be ready for data
                      01827 ; On Exit:
                      01828 ;    W = any data from the SPI
                      01829 ;==============================================================================
0005C8                01830 wait_spi:
0005C8                01831 loop_spi:
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 35
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0005C8 A0C7           01832             btfss   SSPSTAT,BF,0        ;(.25)spin until BF bit gets set
0005CA D7FE           01833             bra     loop_spi            ;(.25)spin for about 2 uS)
                      01834 
0005CC 50C9           01835             movf    SSPBUF,W,0          ;(.25)flush/read SPI interface, clear BF bit
0005CE 0012           01836             return                      ;(.5)
                      01837 
                      01838 ;*==============================================================================*
                      01839 ; Subroutine to wait for and get get one character from the Receive Queue
                      01840 ; echo the character upon receipt (except nulls)
                      01841 ; On Exit:
                      01842 ;     The character is in R0. If chr was CR, then R0 = LF
                      01843 ;     FSR0, W trashed
                      01844 ;     GEI is set, enabling global interrupts
                      01845 ;*==============================================================================*
0005D0 DF24           01846 wait_rxchr:     rcall   get_rxchr           ;get chr into W and R0
0005D2 E0FE           01847                 bz      wait_rxchr
                      01848 
0005D4 D6F5           01849                 bra     printr0             ;echo and return (trashes W)
                      01850 
                      01851 ;************************************===========================================*
                      01852 ;* Externally Accessible Subroutine *
                      01853 ;************************************
                      01854 ; Find a command in a command table
                      01855 ; On Entry:
                      01856 ;      FSR1 points to the next input character in the user input buffer
                      01857 ;      TBLPTRH:TBLPTRL points to the particular command table
                      01858 ;      Each command table entry comprises  a null terminated ASCII command
                      01859 ;      string (where the null must be on an even byte and odd-byte nulls are
                      01860 ;      ignored) followed by a 1-byte "command index"
                      01861 ; On Exit:
                      01862 ;      W = 0 if no match
                      01863 ;      W = command index from table if match
                      01864 ;      FSR1 points to the next input character after the command
                      01865 ; Trashes W,R0,R1,FSR2,TBLPTRH:TBLPTRL
                      01866 ;*==============================================================================*
0005D6 CFE1 FFD9      01867 parse_cmd:  movff   FSR1L,FSR2L             ;save pointer so we can retry
0005DA CFE2 FFDA      01868             movff   FSR1H,FSR2H
                      01869 
0005DE CFD9 FFE1      01870 nxt_cmd:        movff   FSR2L,FSR1L         ;restore pointer to user input
0005E2 CFDA FFE2      01871                 movff   FSR2H,FSR1H
0005E6 960C           01872                 bcf     KERN_FLAGS,CR_FLAG,0
0005E8 6A0E           01873                 clrf    R1,0                ;match so far
                      01874 
0005EA 0008           01875                 tblrd*                      ;end of table?
0005EC 50F5           01876                 movf    TABLAT,W,0
0005EE B4D8           01877                 btfsc   STATUS,Z,0          ;y: return with W=0
0005F0 0012           01878                 return
                      01879 
0005F2 0009           01880 nxt_cchr:           tblrd*+                 ;Get command character
0005F4 DF68           01881                     rcall   get_uchr        ;get an upper-case character from the user input
                      01882                                             ;result in W and R0
                      01883 
0005F6 0A20           01884                     xorlw   ' '             ;convert space seperator to a null
0005F8 A4D8           01885                     btfss   STATUS,Z,0
0005FA 0A20           01886                     xorlw   ' '             ;not space: put it back
                      01887 
0005FC 18F5           01888                     xorwf   TABLAT,W,0      ;compare 1 chr
0005FE 120E           01889                     iorwf   R1,F,0          ;accumulate result
                      01890                                             ;set Z flag if still matching
                      01891 
000600 66F5           01892                     tstfsz  TABLAT,0        ;end of this command?
000602 D7F7           01893                     bra     nxt_cchr        ;n: test another character
                      01894 
000604 A0F6           01895                 btfss   TBLPTRL,0x00,0      ;skip over word-alignment null if necessary
000606 0009           01896                 tblrd*+
                      01897 
000608 0009           01898                 tblrd*+                     ;point TABLAT to command index
                      01899 
                      01900                                             ;Z was set/cleared by iorwf above
00060A E1E9           01901                 bnz     nxt_cmd             ;unless all chrs matched, try the next command
                      01902 
00060C 50F5           01903             movf    TABLAT,W,0          ;get command index
00060E 0012           01904             return                      ;return with W=command index
                      01905 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 36
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01906 ;************************************===========================================*
                      01907 ;* Externally Accessible Subroutine *
                      01908 ;************************************
                      01909 ; Get an exactly 2-character hex value from the Line Buffer. This is as fast as
                      01910 ; possible so we can keep up with hex record loading This routine *IS* cases
                      01911 ; sensitive - lowercase will cause an error. This routine also does not skip
                      01912 ; over white space.
                      01913 ;
                      01914 ; On Exit:
                      01915 ;     Result in W and R1
                      01916 ;     Result added to CHECKSUM
                      01917 ;     Z set if checksum = 0
                      01918 ;     ERR_FLAG set if any hex character errors. (Never cleared though)
                      01919 ;     R0, FSR0 trashed
                      01920 ;*==============================================================================*
000610 D807           01921 get_lbhex2:     rcall   get_lbhex1              ;get high nibble
000612 B0D8           01922                 btfsc   STATUS,C,0              ;C set means error
000614 800C           01923                 bsf     KERN_FLAGS,ERR_FLAG,0
                      01924 
000616 D804           01925                 rcall   get_lbhex1              ;get low nibble
000618 B0D8           01926                 btfsc   STATUS,C,0              ;C cleared means success
00061A 800C           01927                 bsf     KERN_FLAGS,ERR_FLAG,0
                      01928 
00061C 2604           01929                 addwf   CHECKSUM,F,0            ;add to checksum, set Z appropriately
00061E 0012           01930                 return
                      01931 
                      01932 ;*==============================================================================*
                      01933 ; Subroutine to get one character from the Rx queue, convert it to a binary
                      01934 ; nibble and test for good hex. This routine *IS* case-sensitive: A-F must be
                      01935 ; uppercase.
                      01936 ;
                      01937 ; Note: this is not an externally-acessible subroutine because the programmer
                      01938 ; firmware must load received data through a line buffer, so that line editing
                      01939 ; (at least deleting characters) can be supported.
                      01940 ; On Entry:
                      01941 ;     R1 = previous nibble(s)
                      01942 ; On Exit:
                      01943 ;     R0 = binary value of nibble
                      01944 ;     W = R1 = combined nibbles (upper nibble of R1 entry value is lost.)
                      01945 ;     C cleared if no error, set if bad hex character
                      01946 ;     FSR0 trashed
                      01947 ;*==============================================================================*
000620 DF59           01948 get_lbhex1:     rcall   get_chr         ;get line buffer chr into R0, case sensitive
                      01949 
000622 D009           01950                 bra     hex2bin
                      01951 
                      01952 ;*==============================================================================*
                      01953 ; Get an exactly 2-character hex value from the Rx queue. This is as fast as
                      01954 ; possible so we can keep up with hex record loading This routine *IS* cases
                      01955 ; sensitive - lowercase will cause an error. This routine also does not skip
                      01956 ; over white space.
                      01957 ;
                      01958 ; Note: this is not an externally-acessible subroutine because the programmer
                      01959 ; firmware must load received data through a line buffer, so that line editing
                      01960 ; (at least deleting characters) can be supported.
                      01961 ; On Exit:
                      01962 ;     Result in W and R1
                      01963 ;     Result added to CHECKSUM
                      01964 ;     Z set if checksum = 0
                      01965 ;     ERR_FLAG set if any hex character errors. (Never cleared though)
                      01966 ;     R0, FSR0 trashed
                      01967 ;*==============================================================================*
000624 D807           01968 get_rqhex2:     rcall   get_rqhex1              ;get high nibble
000626 B0D8           01969                 btfsc   STATUS,C,0              ;C set means error
000628 800C           01970                 bsf     KERN_FLAGS,ERR_FLAG,0
                      01971 
00062A D804           01972                 rcall   get_rqhex1              ;get low nibble
00062C B0D8           01973                 btfsc   STATUS,C,0              ;C cleared means success
00062E 800C           01974                 bsf     KERN_FLAGS,ERR_FLAG,0
                      01975 
000630 2604           01976                 addwf   CHECKSUM,F,0            ;add to checksum, set Z appropriately
000632 0012           01977                 return
                      01978 
                      01979 ;*==============================================================================*
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 37
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01980 ; Subroutine to get one character from the Rx queue, convert it to a binary
                      01981 ; nibble and test for good hex. This routine *IS* case-sensitive: A-F must be
                      01982 ; uppercase.
                      01983 ;
                      01984 ; Note: this is not an externally-acessible subroutine because the programmer
                      01985 ; firmware must load received data through a line buffer, so that line editing
                      01986 ; (at least deleting characters) can be supported.
                      01987 ; On Entry:
                      01988 ;     R1 = previous nibble(s)
                      01989 ; On Exit:
                      01990 ;     R0 = binary value of nibble
                      01991 ;     W = R1 = combined nibbles (upper nibble of R1 entry value is lost.)
                      01992 ;     C cleared if no error, set if bad hex character
                      01993 ;     FSR0 trashed
                      01994 ;*==============================================================================*
000634 DFCD           01995 get_rqhex1:     rcall   wait_rxchr          ;get queue chr into R0, case sensitive
                      01996 
                      01997                 ;fall into hex2bin
                      01998 
                      01999 ;************************************===========================================*
                      02000 ;* Externally Accessible Subroutine *
                      02001 ;************************************
                      02002 ; Subroutine to convert hex chr in R0 to a binary, testing for a good
                      02003 ; hex digit. Combine result into previous digit in R1.
                      02004 ; This routine *IS* case-sensitive: A-F must be uppercase.
                      02005 ; On Entry: 
                      02006 ;     R0 is ASCII chr for this nibble
                      02007 ;     R1 = previous nibble(s)
                      02008 ; On Exit:
                      02009 ;     R0 = binary value of nibble
                      02010 ;     W = R1 = combined nibbles (upper nibble of R1 entry value is lost.)
                      02011 ;     C cleared if no error, set if bad hex character
                      02012 ;     both nibbles will be trashed if a bad hex chr is received.
                      02013 ; (5 uS, worst case)
                      02014 ;*==============================================================================*
000636 0E30           02015 hex2bin:        movlw   '0'             ;(0.25)remove ASCII bias
000638 5E0D           02016                 subwf   R0,F,0          ;(0.25)result into R0
                      02017 
                      02018 ;test for chr between '0' and '9'
00063A 0E0A           02019                 movlw   0x0a            ;(0.25)
00063C 5C0D           02020                 subwf   R0,W,0          ;(0.25)
00063E E308           02021                 bnc     good_nibble     ;C cleared means '0'-'9'. binary value in R0
                      02022 
                      02023 ;simultaneously check for gap chr between '9' and 'A' and for chr above 'F'
000640 0E11           02024                 movlw   'A'-'0'         ;(0.25)shift down to zero base
000642 5E0D           02025                 subwf   R0,F,0          ;(0.25)legal values are now 0x00 through 0x05
000644 0E06           02026                 movlw   0x06            ;(0.25)
000646 5C0D           02027                 subwf   R0,W,0          ;(0.25)C set means value is 0x06 or more
                      02028 
000648 B0D8           02029                 btfsc   STATUS,C,0      ;(0.50)C set means gap chr or above F, an error
00064A 0012           02030                 return                  ;Bad hex chr: Return with carry set
                      02031                 
00064C 0E0A           02032                 movlw   0x0a            ;(0.25)convert 0x00 - 0x05 into 0x0A - 0x0F
00064E 260D           02033                 addwf   R0,F,0          ;(0.25)binary value in R0 (leaves C cleared)
                      02034 
                      02035 ;install new R0 value as the low nibble of R1, shifting old value to the high nibble
000650 380E           02036 good_nibble:    swapf   R1,W,0          ;(0.25)push previous low nibble into high position
000652 0BF0           02037                 andlw   0xf0            ;(0.25)strip off any previous high nibble
000654 100D           02038                 iorwf   R0,W,0          ;(0.25)combine with new low nibble
000656 6E0E           02039                 movwf   R1,0            ;(0.25)result back into R1 for return
                      02040 
000658 0012           02041                 return                  ;(0.50)Success: value in R0 and carry cleared       
                      02042 
                      02043 ;*==============================================================================*
                      02044 ; Subroutine to read and compare two rows of FLASH data into the RAM buffer
                      02045 ; This is a dual-purpose subroutine, to save code space:
                      02046 ;   1) Used to copy FLASH into the buffer - in which case, Z is ignored on return
                      02047 ;   2) Used to verify that FLASH matches the buffer, in which case, the buffer
                      02048 ;      gets over-written, precluding any possibility of retrying the write.
                      02049 ; On Entry:
                      02050 ;    ROWA_HIGH:ROWA_LOW contain the FLASH address
                      02051 ;    FSR1H contains the high byte of the RAM buffer address
                      02052 ; On Exit:
                      02053 ;    Data from FLASH has been written to the RAM buffer
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 38
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02054 ;    Z setand R0=0 if the entire buffer matched the data before it was copied
                      02055 ;    R0, R1, FSR1L, TBLPTRL, TBLPTRH, TABLAT all trashed
                      02056 ;*==============================================================================*
00065A D83B           02057 read_ver_flash: rcall   flash_setup     ;set up TBLPTRL, TBLPTRH, FSR1L, CFGS
                      02058 
00065C 6A0D           02059                 clrf    R0,0                ;no mismatches yet
                      02060 
00065E 0E40           02061                 movlw   FLASH_ROW * FLASH_BLOCK ;byte count
000660 6E0E           02062                 movwf   R1,0
                      02063 
000662 0009           02064 rv_loop:            tblrd*+                 ;read flash data into TABLAT, bump
                      02065 
                      02066 ;compare the flash to the buffer, and make R0 non-zero if not the same
                      02067 ;then put the flash data in the buffer
000664 50F5           02068                     movf    TABLAT,W,0      ;get flash data
000666 18E7           02069                     xorwf   INDF1,W,0       ;compare, don't bump pointer yet
000668 120D           02070                     iorwf   R0,F,0          ;result accumulates in R0
                      02071 
00066A 50F5           02072                     movf    TABLAT,W,0
00066C 6EE6           02073                     movwf   POSTINC1,0      ;read into buffer, bump pointer
                      02074 
00066E 2E0E           02075                     decfsz  R1,F,0          ;do all bytes in this block
000670 D7F8           02076                     bra     rv_loop
                      02077 
000672 520D           02078                 movf    R0,F,0              ;set Z if the buffer matched the data
000674 0012           02079                 return
                      02080 
                      02081 ;*==============================================================================*
                      02082 ; Subroutine to write buffer data to two sequential FLASH rows (Page 90 onward)
                      02083 ; On Entry:
                      02084 ;    Data is in RAM buffer
                      02085 ;    ROWA_HIGH, ROWA_LOW = FLASH address
                      02086 ;    FSR1H contains the high byte of the data buffer address
                      02087 ; On Exit:
                      02088 ;    Flash has been written
                      02089 ;    Error message printed and ERR_FLAG set if verify fails
                      02090 ;    W, R0, R1, FSR1L trashed
                      02091 ;*==============================================================================*
000676                02092 write_flash:
                      02093 
                      02094 ;--------------------------------------------------------------------------------------
                      02095 ; Writing to FLASH is slow, and interrupts must be masked during the process - so we
                      02096 ; must tell the sender to pause (via XOFF) while we write to FLASH. The sender may not
                      02097 ; respond to the XOFF immediately, so we will stall here until we don't see any more
                      02098 ; characters coming into the receive queue from the UART. Once the UART receiver is
                      02099 ; quiet, we mask all interrupts. Note that we won't actually pull any characters from
                      02100 ; the receive queue here: we just look at the queue pointer to see if it is changing.
                      02101 ;--------------------------------------------------------------------------------------
000676 0E13           02102                 movlw   XOFF                ;pause receiver
000678 DEA2           02103                 rcall   printw              ;trashes W, R0, FSR0
                      02104 
                      02105 ;wait until we get no received characters for at least 3 character times = 3.1 mS
00067A 5000           02106 wait_xoff:          movf    RQ_IPTR ,W,0    ;snapshot of Rx queue in-pointer
00067C 6E0E           02107                     movwf   R1,0            ;temp storage
                      02108 
00067E 0E0D           02109                     movlw   .13             ;13 X 250 uS = 3.25 mS stall
000680 DF91           02110                     rcall   stall_250us     ;trashes R0
                      02111 
000682 500E           02112                     movf    R1,W,0          ;any new characters?
000684 1800           02113                     xorwf   RQ_IPTR,W,0     ;RX_IPTR changes with each received chr
000686 E1F9           02114                     bnz     wait_xoff
                      02115 
                      02116 ;--------------------------------------------------------------------------------------
                      02117 ; First, erase the FLASH row pair at address ROWA_HIGH, ROWA_LOW. This takes about 2 mS
                      02118 ; (page 90)
                      02119 ;--------------------------------------------------------------------------------------
000688 D824           02120                 rcall   flash_setup         ;set up TBLPTR, FSR1L
                      02121 
00068A 9EF2           02122                 bcf     INTCON,GIE,0        ;disable interrupts
                      02123 
                      02124 ; Point to flash memory, enable an erase function (page 94)
00068C 0E94           02125                 movlw   (1 << EEPGD) | ( 1 << WREN) | (1 << FREE)
00068E 6EA6           02126                 movwf   EECON1,0
                      02127 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 39
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000690 0E55           02128                 movlw   0x55                ;unlock sequence (page 91)
000692 6EA7           02129                 movwf   EECON2,0
000694 0EAA           02130                 movlw   0xAA
000696 6EA7           02131                 movwf   EECON2,0
000698 82A6           02132                 bsf     EECON1,WR,0         ;Set WR bit to begin erase
                      02133 
                      02134 ;--------------------------------------------------------------------------------------
                      02135 ; Next, write two FLASH rows with data from RAM_BUF. This takes about 2 mS each???
                      02136 ; TBLPTRH,TBLPTRL are already set up; interrupts are already masked
                      02137 ;--------------------------------------------------------------------------------------
00069A 0E02           02138                 movlw   FLASH_BLOCK         ;R1 counts rows within a block
00069C 6E0E           02139                 movwf   R1,0
00069E 000A           02140                 tblrd*-                     ;decrement TBLPTR, fro upcoming pre-increment
                      02141 
0006A0 0E20           02142 wrow_loop:          movlw   FLASH_ROW       ;R0 counts bytes within a row
0006A2 6E0D           02143                     movwf   R0,0
                      02144 
                      02145 ;Loop to fill the PIC's flash holding register. We use pre-increment here so that
                      02146 ;TBLPTR is still pointing to the correct row when we actually write to flash.
0006A4 50E6           02147 wbyte_loop:             movf    POSTINC1,W,0    ;read a data byte
0006A6 6EF5           02148                         movwf   TABLAT,0        ;write it to the row buffer
0006A8 000F           02149                         tblwt+*                 ;pre-increment, write to buffer
0006AA 2E0D           02150                         decfsz  R0,F,0          ;next byte
0006AC D7FB           02151                         bra     wbyte_loop
                      02152 
                      02153 ;Write the holding register to the flash data row pointed to by TBLPTR
0006AE 0E84           02154                     movlw   (1 << EEPGD) | ( 1 << WREN) ;enable Flash write
0006B0 6EA6           02155                     movwf   EECON1,0
                      02156 
0006B2 0E55           02157                     movlw   0x55                ;unlock sequence
0006B4 6EA7           02158                     movwf   EECON2,0
0006B6 0EAA           02159                     movlw   0xAA
0006B8 6EA7           02160                     movwf   EECON2,0
0006BA 82A6           02161                     bsf     EECON1,WR,0         ;Set WR bit to begin write
                      02162 
                      02163 ;do a secod row, if we haven't already  
0006BC 2E0E           02164                 decfsz  R1,F,0                  ;done all rows in this erase block?
0006BE D7F0           02165                 bra     wrow_loop               ;n: do another row
                      02166 
                      02167 ;Done: disable flash write
0006C0 94A6           02168                 bcf     EECON1,WREN,0           ;disable further writes
                      02169 
                      02170 ;--------------------------------------------------------------------------------------
                      02171 ; Finally, verify written data by comparing FLASH to the RAM buffer
                      02172 ; (This trashes the RAM buffer data.) 
                      02173 ;--------------------------------------------------------------------------------------
0006C2 DFCB           02174                 rcall   read_ver_flash      ;verify the data, trash the buffer
                      02175                                             ;returns with Z set if match
                      02176 
0006C4 8EF2           02177                 bsf     INTCON,GIE,0        ;re-enable interrupts here, in case we report error
                      02178 
0006C6 EE00 F06E      02179                 lfsr    0,verifyerr_msg
0006CA A4D8           02180                 btfss   STATUS,Z,0
0006CC DE33           02181                 rcall   report_error        ;FSR0 = verifyerr_msg
                      02182 
                      02183 ;--------------------------------------------------------------------------------------
                      02184 ; Critical timing is done. send XON to the sender, and return.
                      02185 ;--------------------------------------------------------------------------------------
0006CE 0E11           02186                 movlw   XON                 ;un-pause receiver
0006D0 D676           02187                 bra     printw              ;return from there
                      02188 
                      02189 ;*==============================================================================*
                      02190 ; Subroutine to set up FSRL and TBLPTR for reads and writes to FLASH
                      02191 ; On Entry:
                      02192 ;    ROWA_HIGH:ROWA_LOW = flash row address
                      02193 ; On Exit:
                      02194 ;    FSR1L = 0
                      02195 ;    TBLPTRU:TBLPTRH:TBLPTRL = ROWA_HIGH:ROWA_LOW
                      02196 ;*==============================================================================*
0006D2 6AE1           02197 flash_setup:    clrf    FSR1L,0             ;beginning of RAM buffer
                      02198 
0006D4 6AF8           02199                 clrf    TBLPTRU,0           ;high address bits are 0
0006D6 C012 FFF7      02200                 movff   ROWA_HIGH,TBLPTRH
0006DA C011 FFF6      02201                 movff   ROWA_LOW,TBLPTRL
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 40
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0006DE 0012           02202                 return
                      02203 
                      02204 ;*==============================================================================*
                      02205 ; Subroutine to test for the user typing three sequential ESCAPEs to go to
                      02206 ; LOADED_CODE. If FLASH_MEM is set, meaning that we are actively loading a file,
                      02207 ; then ESCAPEs will be ignored.
                      02208 ; On Entry:
                      02209 ;     FLASH_MEM is set if we are actively loading data into FLASH.
                      02210 ; On Exit (not to LOADED_CODE):
                      02211 ;     R0 = chr received. If chr was CR, then R0 = LF
                      02212 ;     W, R1, FSR0 trashed
                      02213 ;*==============================================================================*
0006E0 0E03           02214 test_esc:   movlw   3                           ;loop counter: count ESCs
0006E2 6E0E           02215             movwf   R1,0
                      02216 
0006E4 DF75           02217 wait_escapes:   rcall   wait_rxchr              ;get user input into R0
                      02218 
0006E6 B20C           02219                 btfsc   KERN_FLAGS,FLASH_MEM,0  ;active write to flash memory?
0006E8 0012           02220             return                              ;yes: ESC sequences will be ignored
                      02221 
0006EA 500D           02222                 movf    R0,W,0
0006EC 0A1B           02223                 xorlw   ESC                     ;another ESC?
0006EE A4D8           02224                 btfss   STATUS,Z,0
0006F0 0012           02225             return                              ;any non-ESC end the hunt
                      02226 
0006F2 2E0E           02227                 decfsz  R1,F,0
0006F4 D7F7           02228                 bra     wait_escapes
                      02229 
0006F6 EF00 F004      02230             goto    LOADED_CODE                 ;complete ESC sequence: go to LOADED_CODE
                      02231 
                      02232 ;*==============================================================================*
                      02233 ; Subroutine to set up the EEPROM, assuming it is corrupt (probably has
                      02234 ; never been written)
                      02235 ; On Entry:
                      02236 ;    TBLPTRH = high(loader_msg)
                      02237 ;*==============================================================================*
0006FA EE00 F09A      02238 new_eeprom:     lfsr    0,eeinit_msg        ;"Initializing EEPROM"
0006FE DE1D           02239                 rcall   loader_printf
                      02240 
                      02241 ;Write the ID string to EEPROM
000700 0E14           02242                 movlw   EE_INITLEN          ;Initialization string length 
000702 6E0E           02243                 movwf   R1,0                ;byte counter
                      02244 
000704 0E48           02245                 movlw   low(loader_msg)
000706 6EF6           02246                 movwf   TBLPTRL,0
                      02247 
000708 0E00           02248                 movlw   EE_INIT             ;init string address in EEPROM
00070A 6EA9           02249                 movwf   EEADR,0             ;..where wr_eeprom wants the address
                      02250 
00070C 0009           02251 wrid_loop:          tblrd*+                     ;get string byte, bump pointer
00070E 50F5           02252                     movf    TABLAT,W,0
                      02253 
000710 DF34           02254                     rcall   wr_eeprom           ;write an EEPROM byte
000712 2AA9           02255                     incf    EEADR,F,0           ;bump pointer
                      02256 
000714 2E0E           02257                     decfsz  R1,F,0              ;test all bytes
000716 D7FA           02258                     bra     wrid_loop
                      02259 
                      02260 ;initialize the serial number
000718 D820           02261 get_snagain:    rcall   get_sn
00071A E0FE           02262                 bz      get_snagain             ;insist on a serial number
                      02263 
                      02264 ;initialize all EEPROM variables 
                      02265 
00071C D00B           02266                 bra     clr_eevars
                      02267 
                      02268 ;*==============================================================================*
                      02269 ; Subroutine to edit the EEPROM, assuming it is not corrupt
                      02270 ; On Entry:
                      02271 ;    TBLPTRH = high(loader_msg)
                      02272 ;*==============================================================================*
00071E                02273 edit_eeprom:
                      02274 
                      02275 ;Print the existing serial number
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 41
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00071E DE6C           02276             rcall   print_sn
                      02277 
                      02278 ;Ask user for serial number
                      02279 
000720 D81C           02280             rcall get_sn
                      02281 ;If the user responded with a 0-character line then don't change the serial number.
000722 EE00 F0CE      02282             lfsr    0,unchanged_msg     ;"unchanged"
000726 B4D8           02283             btfsc   STATUS,Z            ;Z set means no new serial number
000728 DE08           02284             rcall   loader_printf
                      02285 
                      02286 ;Ask user permission to initialize all the EEPROM variables, and do so
00072A EE00 F0E4      02287             lfsr    0,clrvars_msg   ;"Clear EEPROM variables"
00072E DE05           02288             rcall   loader_printf
000730 DEB3           02289             rcall   ask_yn
000732 E10C           02290             bnz     ee_done             ;'n'
                      02291 
                      02292 ;Subroutine end...
000734                02293 clr_eevars:
                      02294 
000734 0EE4           02295             movlw   EE_VARLEN           ;total variables length 
000736 6E0E           02296             movwf   R1,0                ;byte counter
                      02297 
000738 0E1C           02298             movlw   EE_VARBEG           ;init string address in EEPROM
00073A 6EA9           02299             movwf   EEADR,0             ;..where wr_eeprom wants the address
                      02300 
00073C 0E00           02301 cc_loop:        movlw   0x00                ;clear it
00073E DF1D           02302                 rcall   wr_eeprom           ;write an EEPROM byte
000740 2AA9           02303                 incf    EEADR,F,0           ;bump pointer
                      02304 
000742 2E0E           02305                 decfsz  R1,F,0              ;clear all bytes
000744 D7FB           02306                 bra     cc_loop
                      02307 
000746 EE01 F002      02308             lfsr    0,cleared_msg       ;"EEPROM variables cleared"
00074A DDF7           02309             rcall   loader_printf
                      02310 
                      02311 ;Go to the firmware if the user says ok. (If the firmware has not been installed,
                      02312 ;then the dummy firmware will go to back the loader.)
00074C EE01 F022      02313 ee_done:    lfsr    0,run_msg           ;"Run code?"
000750 DDF4           02314             rcall   loader_printf
                      02315 
000752 DEA2           02316             rcall   ask_yn
000754 E1E4           02317             bnz     edit_eeprom
                      02318 
000756 EF00 F004      02319             goto    LOADED_CODE
                      02320 
                      02321 ;*==============================================================================*
                      02322 ; Subroutine to get the serial number from the user
                      02323 ; On Entry:
                      02324 ;    TBLPTRH = high(loader_msg)
                      02325 ; On Exit:
                      02326 ;    Z set if no serial number given
                      02327 ; trashes W, R0, R1, FSR0, FSR1
                      02328 ;*==============================================================================*
00075A EE00 F0B0      02329 get_sn:     lfsr    0,newsn_msg     ;"New Serial Number: "
00075E DDED           02330             rcall   loader_printf
                      02331 
000760 0E08           02332             movlw   EE_SNLEN        ;max serial number length
000762 EC1B F002      02333             call    getlin          ;get null-terminated serial number from user
000766 B4D8           02334             btfsc   STATUS,Z        ;Z set if 0 chrs, otherwise FSR1 = LINBUF
000768 0012           02335             return                  ;with Z set
                      02336 
00076A 0E14           02337             movlw   EE_SN           ;serial number location
00076C 6EA9           02338             movwf   EEADR,0         ;address for wr_eeprom
                      02339 
                      02340 ;loop to write new serial number (including its null termination to EEPROM.
                      02341 ;IND1 points to the serial number in the line buffer.
00076E 50E6           02342 wrsn_loop:      movf    POSTINC1,W,0    ;get a chr
000770 6E0E           02343                 movwf   R1,0            ;for test at end
                      02344 
000772 DF03           02345                 rcall   wr_eeprom       ;write chr to EEPROM at FSR0L   
000774 2AA9           02346                 incf    EEADR,F,0       ;next location in EEPROM
000776 520E           02347                 movf    R1,F,0          ;was this the null termination?
000778 E1FA           02348                 bnz     wrsn_loop       ;n: keep going
                      02349 
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 42
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00077A 94D8           02350 sn_same:    bcf     STATUS,Z            ;clear Z: got a s/n
00077C 0012           02351             return
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 43
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02352     page
                      02353 ;*==============================================================================*
                      02354 ; Print an error message in the listing if this is code too big
                      02355 ;*==============================================================================*
00077E                02356 loader_end:
                      02357 
                      02358     if  loader_end > LOADED_CODE
                      02359     error   "Martin sez: Code is too large!"
                      02360     endif
                      02361 
                      02362     end
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 44
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

A                                 00000000
A8n                               00000000
A9n                               00000005
ABDEN                             00000000
ABDOVF                            00000007
ACCESS                            00000000
ACKDT                             00000005
ACKEN                             00000004
ACKSTAT                           00000006
ACQT0                             00000003
ACQT1                             00000004
ACQT2                             00000005
ADCON0                            00000FC2
ADCON1                            00000FC1
ADCON2                            00000FC0
ADCS0                             00000000
ADCS1                             00000001
ADCS2                             00000002
ADDEN                             00000003
ADDRESSH                          00000006
ADDRESSL                          00000005
ADEN                              00000003
ADFM                              00000007
ADIE                              00000006
ADIF                              00000006
ADIP                              00000006
ADON                              00000000
ADRCLK                            00000002
ADRES                             00000FC3
ADRESH                            00000FC4
ADRESL                            00000FC3
AN0                               00000000
AN1                               00000001
AN10                              00000001
AN11                              00000004
AN12                              00000000
AN2                               00000002
AN3                               00000003
AN4                               00000005
AN5                               00000000
AN6                               00000001
AN7                               00000002
AN8                               00000002
AN9                               00000003
ANS0                              00000000
ANS1                              00000001
ANS10                             00000002
ANS11                             00000003
ANS12                             00000004
ANS2                              00000002
ANS3                              00000003
ANS4                              00000004
ANS5                              00000005
ANS6                              00000006
ANS7                              00000007
ANS8                              00000000
ANS9                              00000001
ANSEL                             00000F7E
ANSELH                            00000F7F
ANSELH_INIT                       0000000A
ANSEL_INIT                        00000003
BANKED                            00000001
BAUD19200                         000000CF
BAUD38400                         00000067
BAUD57600                         00000044
BAUD9600                          000001A0
BAUDCON                           00000FB8
BAUDCTL                           00000FB8
BAUDRATE                          000001A0
BCLIE                             00000003
BCLIF                             00000003
BCLIP                             00000003
BF                                00000000
BGST                              00000005
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 45
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

BOR                               00000000
BRG16                             00000003
BRGH                              00000002
BS                                00000008
BSR                               00000FE0
C                                 00000000
C12IN0M                           00000000
C12IN0N                           00000000
C12IN1M                           00000001
C12IN1N                           00000001
C12IN2M                           00000003
C12IN2N                           00000003
C12IN3M                           00000001
C12IN3N                           00000001
C1CH0                             00000000
C1CH1                             00000001
C1IE                              00000006
C1IF                              00000006
C1INP                             00000003
C1IP                              00000006
C1OE                              00000005
C1ON                              00000007
C1OUT_CM1CON0                     00000006
C1OUT_PORTA                       00000004
C1POL                             00000004
C1R                               00000002
C1RSEL                            00000005
C1SP                              00000003
C2CH0                             00000000
C2CH1                             00000001
C2IE                              00000005
C2IF                              00000005
C2INP                             00000002
C2IP                              00000005
C2OE                              00000005
C2ON                              00000007
C2OUT_CM2CON0                     00000006
C2OUT_PORTA                       00000005
C2POL                             00000004
C2R                               00000002
C2RSEL                            00000004
C2SP                              00000003
CALL_TABLE                        0000000A
CCP1                              00000002
CCP1CON                           00000FBD
CCP1IE                            00000002
CCP1IF                            00000002
CCP1IP                            00000002
CCP1M0                            00000000
CCP1M1                            00000001
CCP1M2                            00000002
CCP1M3                            00000003
CCP2CON                           00000FBA
CCP2IE                            00000000
CCP2IF                            00000000
CCP2IP                            00000000
CCP2M0                            00000000
CCP2M1                            00000001
CCP2M2                            00000002
CCP2M3                            00000003
CCP2_PORTB                        00000003
CCP2_PORTC                        00000001
CCPR1                             00000FBE
CCPR1H                            00000FBF
CCPR1L                            00000FBE
CCPR2                             00000FBB
CCPR2H                            00000FBC
CCPR2L                            00000FBB
CFGS                              00000006
CHECKSUM                          00000004
CHS0                              00000002
CHS1                              00000003
CHS2                              00000004
CHS3                              00000005
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 46
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

CK                                00000006
CKE                               00000006
CKP                               00000004
CKTXP                             00000004
CM1CON0                           00000F7B
CM2CON0                           00000F7A
CM2CON1                           00000F79
CR                                0000000D
CREN                              00000004
CR_FLAG                           00000003
CS                                00000002
CSRC                              00000007
CTRLC                             00000003
CVR0                              00000000
CVR1                              00000001
CVR2                              00000002
CVR3                              00000003
CVRCON                            00000FB5
CVRCON2                           00000FB4
CVREF                             00000002
CVREN                             00000007
CVROE                             00000006
CVRR                              00000005
CVRSS                             00000004
D                                 00000005
DBUFDIR                           00000006
DBUFOEn                           00000007
DC                                00000001
DC1B0                             00000004
DC1B1                             00000005
DC2B0                             00000004
DC2B1                             00000005
DDRA                              TRISA
DDRB                              TRISB
DDRC                              TRISC
DDRD                              TRISD
DDRE                              TRISE
DEL                               0000007F
DONE                              00000001
DTRXP                             00000005
D_A                               00000005
D_NOT_A                           00000005
ECCP1AS                           00000FB6
ECCPAS0                           00000004
ECCPAS1                           00000005
ECCPAS2                           00000006
ECCPASE                           00000007
ECHO_FLAG                         00000002
EEADR                             00000FA9
EEADR0                            00000000
EEADR1                            00000001
EEADR2                            00000002
EEADR3                            00000003
EEADR4                            00000004
EEADR5                            00000005
EEADR6                            00000006
EEADR7                            00000007
EECON1                            00000FA6
EECON2                            00000FA7
EEDATA                            00000FA8
EEIE                              00000004
EEIF                              00000004
EEIP                              00000004
EEPGD                             00000007
EEPROM                            00F00000
EE_INIT                           00000000
EE_INITLEN                        00000014
EE_SN                             00000014
EE_SNLEN                          00000008
EE_VARBEG                         0000001C
EE_VARLEN                         000000E4
ERRCNTH                           0000000A
ERRCNTL                           00000009
ERR_FLAG                          00000000
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 47
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

ESC                               0000001B
FALSE                             00000000
FAST                              00000001
FERR                              00000002
FLASH_BLOCK                       00000002
FLASH_MEM                         00000001
FLASH_ROW                         00000020
FLT0                              00000000
FREE                              00000004
FSR0                              00000000
FSR0H                             00000FEA
FSR0L                             00000FE9
FSR1                              00000001
FSR1H                             00000FE2
FSR1L                             00000FE1
FSR2                              00000002
FSR2H                             00000FDA
FSR2L                             00000FD9
FVREN                             00000007
FVRST                             00000006
GCEN                              00000007
GIE                               00000007
GIEH                              00000007
GIEL                              00000006
GIE_GIEH                          00000007
GO                                00000001
GO_DONE                           00000001
GO_NOT_DONE                       00000001
HLVDCON                           00000FD2
HLVDEN                            00000004
HLVDIE                            00000002
HLVDIF                            00000002
HLVDIN                            00000005
HLVDIP                            00000002
HLVDL0                            00000000
HLVDL1                            00000001
HLVDL2                            00000002
HLVDL3                            00000003
IBF                               00000007
IBOV                              00000005
IDLEN                             00000007
INDF0                             00000FEF
INDF1                             00000FE7
INDF2                             00000FDF
INP_FLAG                          00000001
INT0                              00000000
INT0E                             00000004
INT0F                             00000001
INT0IE                            00000004
INT0IF                            00000001
INT1                              00000001
INT1E                             00000003
INT1F                             00000000
INT1IE                            00000003
INT1IF                            00000000
INT1IP                            00000006
INT1P                             00000006
INT2                              00000002
INT2E                             00000004
INT2F                             00000001
INT2IE                            00000004
INT2IF                            00000001
INT2IP                            00000007
INT2P                             00000007
INTCON                            00000FF2
INTCON2                           00000FF1
INTCON3                           00000FF0
INTEDG0                           00000006
INTEDG1                           00000005
INTEDG2                           00000004
INTSRC                            00000007
INT_FLAGS                         0000000B
INT_VECTOR                        00000008
IOCB                              00000F7D
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 48
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

IOCB4                             00000004
IOCB5                             00000005
IOCB6                             00000006
IOCB7                             00000007
IOFS                              00000002
IPEN                              00000007
IPR1                              00000F9F
IPR2                              00000FA2
IRCF0                             00000004
IRCF1                             00000005
IRCF2                             00000006
IRVST                             00000005
IVRST                             00000005
KBI0                              00000004
KBI1                              00000005
KBI2                              00000006
KBI3                              00000007
KERN_FLAGS                        0000000C
K_ASKYN                           0000002A
K_CHKABORT                        0000002C
K_CONIN                           0000000A
K_CONOUT                          0000000C
K_EEPRINT                         00000010
K_GETCHR                          00000020
K_GETDEC                          00000024
K_GETHEX2                         00000026
K_GETHEX4                         00000028
K_GETLIN                          0000001C
K_GETUCHR                         00000022
K_HEX2BIN                         0000001A
K_KERN_ID                         00000004
K_KERN_REV                        00000002
K_PARSE                           0000001E
K_PRINTDEC                        00000016
K_PRINTF                          0000000E
K_PRINTHEX1                       00000012
K_PRINTHEX2                       00000014
K_PRINTSN                         00000018
K_PROG_ID                         00000004
K_RDEEPROM                        00000032
K_RDSRAM                          0000002E
K_STALL1U                         0000003E
K_STALL250U                       0000003C
K_STALL25M                        0000003A
K_WREEPROM                        00000034
K_WRSRAM                          00000030
LATA                              00000F89
LATA0                             00000000
LATA1                             00000001
LATA2                             00000002
LATA3                             00000003
LATA4                             00000004
LATA5                             00000005
LATA6                             00000006
LATA7                             00000007
LATB                              00000F8A
LATB0                             00000000
LATB1                             00000001
LATB2                             00000002
LATB3                             00000003
LATB4                             00000004
LATB5                             00000005
LATB6                             00000006
LATB7                             00000007
LATC                              00000F8B
LATC0                             00000000
LATC1                             00000001
LATC2                             00000002
LATC3                             00000003
LATC4                             00000004
LATC5                             00000005
LATC6                             00000006
LATC7                             00000007
LATD                              00000F8C
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 49
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

LATD0                             00000000
LATD1                             00000001
LATD2                             00000002
LATD3                             00000003
LATD4                             00000004
LATD5                             00000005
LATD6                             00000006
LATD7                             00000007
LATE                              00000F8D
LATE0                             00000000
LATE1                             00000001
LATE2                             00000002
LF                                0000000A
LINBUF                            00000060
LOADED_CODE                       00000800
LVDCON                            00000FD2
LVDEN                             00000004
LVDIE                             00000002
LVDIF                             00000002
LVDIN                             00000005
LVDIP                             00000002
LVDL0                             00000000
LVDL1                             00000001
LVDL2                             00000002
LVDL3                             00000003
LVV0                              00000000
LVV1                              00000001
LVV2                              00000002
LVV3                              00000003
M12_75V                           00000003
M13_1V                            00000001
M21V                              00000001
M25V                              00000000
MAXLIN                            00000050
MC1OUT                            00000007
MC2OUT                            00000006
MCLR                              00000003
MSK0                              00000000
MSK1                              00000001
MSK2                              00000002
MSK3                              00000003
MSK4                              00000004
MSK5                              00000005
MSK6                              00000006
MSK7                              00000007
N                                 00000004
NOT_A                             00000005
NOT_ADDRESS                       00000005
NOT_BOR                           00000000
NOT_CS                            00000002
NOT_DONE                          00000001
NOT_MCLR                          00000003
NOT_PD                            00000002
NOT_POR                           00000001
NOT_RBPU                          00000007
NOT_RD                            00000000
NOT_RI                            00000004
NOT_SS                            00000005
NOT_T1SYNC                        00000002
NOT_T3SYNC                        00000002
NOT_TO                            00000003
NOT_W                             00000002
NOT_WR                            00000001
NOT_WRITE                         00000002
OBF                               00000006
OERR                              00000001
OSCCON                            00000FD3
OSCFIE                            00000007
OSCFIF                            00000007
OSCFIP                            00000007
OSCTUNE                           00000F9B
OSTS                              00000003
OV                                00000003
P                                 00000004
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 50
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

P18_0                             00000002
P18_1                             00000003
P19_0                             00000004
P19_1                             00000005
P1A                               00000002
P1B                               00000005
P1C                               00000006
P1D                               00000007
P1M0                              00000006
P1M1                              00000007
P20_0                             00000006
P20_1                             00000007
P21_0                             00000000
P21_1                             00000001
P24_12Vn                          00000002
P24_5Vn                           00000000
P24_6Vn                           00000004
PC                                00000FF9
PCL                               00000FF9
PCLATH                            00000FFA
PCLATU                            00000FFB
PD                                00000002
PDC0                              00000000
PDC1                              00000001
PDC2                              00000002
PDC3                              00000003
PDC4                              00000004
PDC5                              00000005
PDC6                              00000006
PEIE                              00000006
PEIE_GIEL                         00000006
PEN                               00000002
PGC                               00000006
PGD                               00000007
PGM                               00000005
PIE1                              00000F9D
PIE2                              00000FA0
PIR1                              00000F9E
PIR2                              00000FA1
PLLEN                             00000006
PLUSW0                            00000FEB
PLUSW1                            00000FE3
PLUSW2                            00000FDB
POR                               00000001
PORTA                             00000F80
PORTB                             00000F81
PORTC                             00000F82
PORTD                             00000F83
PORTE                             00000F84
POSTDEC0                          00000FED
POSTDEC1                          00000FE5
POSTDEC2                          00000FDD
POSTINC0                          00000FEE
POSTINC1                          00000FE6
POSTINC2                          00000FDE
PR2                               00000FCB
PREINC0                           00000FEC
PREINC1                           00000FE4
PREINC2                           00000FDC
PREV_CR                           00000002
PREV_LF                           00000003
PROD                              00000FF3
PRODH                             00000FF4
PRODL                             00000FF3
PRSEN                             00000007
PSA                               00000003
PSP0                              00000000
PSP1                              00000001
PSP2                              00000002
PSP3                              00000003
PSP4                              00000004
PSP5                              00000005
PSP6                              00000006
PSP7                              00000007
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 51
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

PSPIE                             00000007
PSPIF                             00000007
PSPIP                             00000007
PSPMODE                           00000004
PSSAC0                            00000002
PSSAC1                            00000003
PSSBD0                            00000000
PSSBD1                            00000001
PSTRCON                           00000FB9
PWM1CON                           00000FB7
R                                 00000002
R0                                0000000D
R1                                0000000E
R2                                0000000F
RA0                               00000000
RA1                               00000001
RA2                               00000002
RA3                               00000003
RA4                               00000004
RA5                               00000005
RA6                               00000006
RA7                               00000007
RAMBUF_SIZ                        00000100
RAM_BUF                           00000200
RB0                               00000000
RB1                               00000001
RB2                               00000002
RB3                               00000003
RB4                               00000004
RB5                               00000005
RB6                               00000006
RB7                               00000007
RBIE                              00000003
RBIF                              00000000
RBIP                              00000000
RBPU                              00000007
RC0                               00000000
RC1                               00000001
RC2                               00000002
RC3                               00000003
RC4                               00000004
RC5                               00000005
RC6                               00000006
RC7                               00000007
RCEN                              00000003
RCIDL                             00000006
RCIE                              00000005
RCIF                              00000005
RCIP                              00000005
RCON                              00000FD0
RCREG                             00000FAE
RCSTA                             00000FAB
RD                                00000000
RD0                               00000000
RD1                               00000001
RD16                              00000007
RD2                               00000002
RD3                               00000003
RD4                               00000004
RD5                               00000005
RD6                               00000006
RD7                               00000007
RE0                               00000000
RE1                               00000001
RE2                               00000002
RE3                               00000003
RECOUNTH                          00000008
RECOUNTL                          00000007
REC_TYPE                          00000010
RESET_VECTOR                      00000000
REV_MAJOR                         00000001
REV_MINOR                         00000000
RI                                00000004
ROWA_HIGH                         00000012
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 52
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

ROWA_LOW                          00000011
RQ_FULL                           00000004
RQ_IPTR                           00000000
RQ_OPTR                           00000001
RQ_SIZE                           00000100
RSEN                              00000001
RX                                00000007
RX9                               00000006
RX9D                              00000000
RX_QUEUE                          00000100
R_NOT_W                           00000002
R_W                               00000002
S                                 00000003
SBOREN                            00000006
SCK                               00000003
SCKP                              00000004
SCL                               00000003
SCS0                              00000000
SCS1                              00000001
SDA                               00000004
SDI                               00000004
SDO                               00000005
SEN                               00000000
SENDB                             00000003
SETUP                             00000003
SLRA                              00000000
SLRB                              00000001
SLRC                              00000002
SLRCON                            00000F78
SLRD                              00000003
SLRE                              00000004
SMP                               00000007
SP0                               00000000
SP1                               00000001
SP2                               00000002
SP3                               00000003
SP4                               00000004
SPBRG                             00000FAF
SPBRGH                            00000FB0
SPEN                              00000007
SRAM_CEn                          00000001
SRAM_DREAD                        00000003
SRAM_DWRITE                       00000002
SRAM_SREAD                        00000005
SRAM_SWRITE                       00000001
SREN                              00000005
SS                                00000005
SSPADD                            00000FC8
SSPBUF                            00000FC9
SSPCON1                           00000FC6
SSPCON2                           00000FC5
SSPEN                             00000005
SSPIE                             00000003
SSPIF                             00000003
SSPIP                             00000003
SSPM0                             00000000
SSPM1                             00000001
SSPM2                             00000002
SSPM3                             00000003
SSPMSK                            00000F77
SSPOV                             00000006
SSPSTAT                           00000FC7
START                             00000003
STATUS                            00000FD8
STKFUL                            00000007
STKOVF                            00000007
STKPTR                            00000FFC
STKUNF                            00000006
STOP                              00000004
STRA                              00000000
STRB                              00000001
STRC                              00000002
STRD                              00000003
STRSYNC                           00000004
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 53
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

SWDTE                             00000000
SWDTEN                            00000000
SYNC                              00000004
T08BIT                            00000006
T0CKI                             00000004
T0CON                             00000FD5
T0CS                              00000005
T0IE                              00000005
T0IF                              00000002
T0PS0                             00000000
T0PS1                             00000001
T0PS2                             00000002
T0SE                              00000004
T13CKI                            00000000
T1CKI                             00000000
T1CKPS0                           00000004
T1CKPS1                           00000005
T1CON                             00000FCD
T1OSCEN                           00000003
T1OSI                             00000001
T1OSO                             00000000
T1RUN                             00000006
T1SYNC                            00000002
T2CKPS0                           00000000
T2CKPS1                           00000001
T2CON                             00000FCA
T2OUTPS0                          00000003
T2OUTPS1                          00000004
T2OUTPS2                          00000005
T2OUTPS3                          00000006
T3CCP1                            00000003
T3CCP2                            00000006
T3CKI                             00000000
T3CKPS0                           00000004
T3CKPS1                           00000005
T3CON                             00000FB1
T3SYNC                            00000002
TABLAT                            00000FF5
TBLPTR                            00000FF6
TBLPTRH                           00000FF7
TBLPTRL                           00000FF6
TBLPTRU                           00000FF8
TMR0                              00000FD6
TMR0H                             00000FD7
TMR0IE                            00000005
TMR0IF                            00000002
TMR0IP                            00000002
TMR0L                             00000FD6
TMR0ON                            00000007
TMR1                              00000FCE
TMR1CS                            00000001
TMR1H                             00000FCF
TMR1IE                            00000000
TMR1IF                            00000000
TMR1IP                            00000000
TMR1L                             00000FCE
TMR1ON                            00000000
TMR2                              00000FCC
TMR2IE                            00000001
TMR2IF                            00000001
TMR2IP                            00000001
TMR2ON                            00000002
TMR3                              00000FB2
TMR3CS                            00000001
TMR3H                             00000FB3
TMR3IE                            00000001
TMR3IF                            00000001
TMR3IP                            00000001
TMR3L                             00000FB2
TMR3ON                            00000000
TO                                00000003
TOS                               00000FFD
TOSH                              00000FFE
TOSL                              00000FFD
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 54
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

TOSU                              00000FFF
TQ_EMPTY                          00000001
TQ_IPTR                           00000002
TQ_OPTR                           00000003
TQ_SIZE                           00000010
TRISA                             00000F92
TRISA0                            00000000
TRISA1                            00000001
TRISA2                            00000002
TRISA3                            00000003
TRISA4                            00000004
TRISA5                            00000005
TRISA6                            00000006
TRISA7                            00000007
TRISA_INIT                        00000003
TRISB                             00000F93
TRISB0                            00000000
TRISB1                            00000001
TRISB2                            00000002
TRISB3                            00000003
TRISB4                            00000004
TRISB5                            00000005
TRISB6                            00000006
TRISB7                            00000007
TRISB_INIT                        0000000A
TRISC                             00000F94
TRISC0                            00000000
TRISC1                            00000001
TRISC2                            00000002
TRISC3                            00000003
TRISC4                            00000004
TRISC5                            00000005
TRISC6                            00000006
TRISC7                            00000007
TRISC_INIT                        00000090
TRISD                             00000F95
TRISD0                            00000000
TRISD1                            00000001
TRISD2                            00000002
TRISD3                            00000003
TRISD4                            00000004
TRISD5                            00000005
TRISD6                            00000006
TRISD7                            00000007
TRISD_INIT                        000000FF
TRISE                             00000F96
TRISE0                            00000000
TRISE1                            00000001
TRISE2                            00000002
TRISE_INIT                        00000008
TRMT                              00000001
TRUE                              000000FF
TUN0                              00000000
TUN1                              00000001
TUN2                              00000002
TUN3                              00000003
TUN4                              00000004
TUN5                              00000005
TX                                00000006
TX9                               00000006
TX9D                              00000000
TXEN                              00000005
TXIE                              00000004
TXIF                              00000004
TXIP                              00000004
TXREG                             00000FAD
TXSTA                             00000FAC
TX_QUEUE                          000000E0
UA                                00000001
VCFG0                             00000004
VCFG1                             00000005
VDIRMAG                           00000007
VPP                               00000003
VPULSE                            00000002
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 55
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

VREFM                             00000002
VREFN                             00000002
VREFP                             00000003
W                                 00000000
WCOL                              00000007
WDTCON                            00000FD1
WPUB                              00000F7C
WPUB0                             00000000
WPUB1                             00000001
WPUB2                             00000002
WPUB3                             00000003
WPUB4                             00000004
WPUB5                             00000005
WPUB6                             00000006
WPUB7                             00000007
WR                                00000001
WREG                              00000FE8
WREN                              00000002
WRERR                             00000003
WUE                               00000001
XOFF                              00000013
XOFF_STATE                        00000000
XON                               00000011
Z                                 00000002
_BOREN_NOSLP_2L                   000000FD
_BOREN_OFF_2L                     000000F9
_BOREN_ON_2L                      000000FB
_BOREN_SBORDIS_2L                 000000FF
_BORV_18_2L                       000000FF
_BORV_22_2L                       000000F7
_BORV_27_2L                       000000EF
_BORV_30_2L                       000000E7
_CCP2MX_PORTBE_3H                 000000FE
_CCP2MX_PORTC_3H                  000000FF
_CONFIG1H                         00300001
_CONFIG2H                         00300003
_CONFIG2L                         00300002
_CONFIG3H                         00300005
_CONFIG4L                         00300006
_CONFIG5H                         00300009
_CONFIG5L                         00300008
_CONFIG6H                         0030000B
_CONFIG6L                         0030000A
_CONFIG7H                         0030000D
_CONFIG7L                         0030000C
_CP0_OFF_5L                       000000FF
_CP0_ON_5L                        000000FE
_CP1_OFF_5L                       000000FF
_CP1_ON_5L                        000000FD
_CP2_OFF_5L                       000000FF
_CP2_ON_5L                        000000FB
_CP3_OFF_5L                       000000FF
_CP3_ON_5L                        000000F7
_CPB_OFF_5H                       000000FF
_CPB_ON_5H                        000000BF
_CPD_OFF_5H                       000000FF
_CPD_ON_5H                        0000007F
_DEBUG_OFF_4L                     000000FF
_DEBUG_ON_4L                      0000007F
_DEVID1                           003FFFFE
_DEVID2                           003FFFFF
_EBTR0_OFF_7L                     000000FF
_EBTR0_ON_7L                      000000FE
_EBTR1_OFF_7L                     000000FF
_EBTR1_ON_7L                      000000FD
_EBTR2_OFF_7L                     000000FF
_EBTR2_ON_7L                      000000FB
_EBTR3_OFF_7L                     000000FF
_EBTR3_ON_7L                      000000F7
_EBTRB_OFF_7H                     000000FF
_EBTRB_ON_7H                      000000BF
_FCMEN_OFF_1H                     000000BF
_FCMEN_ON_1H                      000000FF
_FOSC_ECIO6_1H                    000000F5
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 56
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

_FOSC_EC_1H                       000000F4
_FOSC_HSPLL_1H                    000000F6
_FOSC_HS_1H                       000000F2
_FOSC_INTIO67_1H                  000000F8
_FOSC_INTIO7_1H                   000000F9
_FOSC_LP_1H                       000000F0
_FOSC_RCIO6_1H                    000000F7
_FOSC_RC_1H                       000000F3
_FOSC_XT_1H                       000000F1
_HFOFST_OFF_3H                    000000F7
_HFOFST_ON_3H                     000000FF
_IDLOC0                           00200000
_IDLOC1                           00200001
_IDLOC2                           00200002
_IDLOC3                           00200003
_IDLOC4                           00200004
_IDLOC5                           00200005
_IDLOC6                           00200006
_IDLOC7                           00200007
_IESO_OFF_1H                      0000007F
_IESO_ON_1H                       000000FF
_LPT1OSC_OFF_3H                   000000FB
_LPT1OSC_ON_3H                    000000FF
_LVP_OFF_4L                       000000FB
_LVP_ON_4L                        000000FF
_MCLRE_OFF_3H                     0000007F
_MCLRE_ON_3H                      000000FF
_PBADEN_OFF_3H                    000000FD
_PBADEN_ON_3H                     000000FF
_PWRT_OFF_2L                      000000FF
_PWRT_ON_2L                       000000FE
_STVREN_OFF_4L                    000000FE
_STVREN_ON_4L                     000000FF
_WDTEN_OFF_2H                     000000FE
_WDTEN_ON_2H                      000000FF
_WDTPS_1024_2H                    000000F5
_WDTPS_128_2H                     000000EF
_WDTPS_16384_2H                   000000FD
_WDTPS_16_2H                      000000E9
_WDTPS_1_2H                       000000E1
_WDTPS_2048_2H                    000000F7
_WDTPS_256_2H                     000000F1
_WDTPS_2_2H                       000000E3
_WDTPS_32768_2H                   000000FF
_WDTPS_32_2H                      000000EB
_WDTPS_4096_2H                    000000F9
_WDTPS_4_2H                       000000E5
_WDTPS_512_2H                     000000F3
_WDTPS_64_2H                      000000ED
_WDTPS_8192_2H                    000000FB
_WDTPS_8_2H                       000000E7
_WRT0_OFF_6L                      000000FF
_WRT0_ON_6L                       000000FE
_WRT1_OFF_6L                      000000FF
_WRT1_ON_6L                       000000FD
_WRT2_OFF_6L                      000000FF
_WRT2_ON_6L                       000000FB
_WRT3_OFF_6L                      000000FF
_WRT3_ON_6L                       000000F7
_WRTB_OFF_6H                      000000FF
_WRTB_ON_6H                       000000BF
_WRTC_OFF_6H                      000000FF
_WRTC_ON_6H                       000000DF
_WRTD_OFF_6H                      000000FF
_WRTD_ON_6H                       0000007F
_XINST_OFF_4L                     000000BF
_XINST_ON_4L                      000000FF
__18F45K20                        00000001
ask_again                         00000494
ask_yn                            00000498
ca_abort                          000004BE
ca_done                           000004C4
case_ok                           000004D0
cc_loop                           0000073C
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 57
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

chk_abort                         000004B0
ckid_loop                         000001D6
cksumerror_msg                    00000066
cleared_msg                       00000102
clr_eevars                        00000734
clrvars_msg                       000000E4
code_loader                       000001F8
dr_ckcum                          0000025E
dr_data_loop                      00000256
edit_eeprom                       0000071E
ee_done                           0000074C
ee_print                          0000040C
eeinit_msg                        0000009A
errcount_msg                      0000008E
flash_setup                       000006D2
flush_l                           000001FA
gchr_done                         000004E0
gd_error                          0000050C
gd_exit                           0000050E
gd_loop                           000004EA
get_chr                           000004D4
get_dec                           000004E4
get_lbhex1                        00000620
get_lbhex2                        00000610
get_lbhex4                        00000512
get_rqhex1                        00000634
get_rqhex2                        00000624
get_rxchr                         0000041A
get_sn                            0000075A
get_snagain                       00000718
get_uchr                          000004C6
getl1                             00000440
getl_abort                        00000490
getl_bs                           00000468
getl_dobs                         0000046E
getl_done                         00000482
getl_loop                         00000442
getl_ret                          0000048E
getlin                            00000436
gh4_error                         00000542
gh4_getdigit                      00000524
gh4_skipspace                     0000051E
good_nibble                       00000650
got_yes                           000004AE
gr_done                           00000432
hex2bin                           00000636
hex_error                         00000330
hexerror_msg                      0000005E
inc_rq                            
inc_tq                            
init                              0000012E
int_return                        000002D2
int_service                       000002AE
load_done                         0000028A
load_start                        00000208
loader_end                        0000077E
loader_msg                        00000048
loader_printf                     0000033A
loop_spi                          000005C8
mask_txint                        00000324
new_eeprom                        000006FA
new_row                           0000023A
newsn_msg                         000000B0
nocode_msg                        0000080C
not_written                       00000274
nxt_cchr                          000005F2
nxt_cmd                           000005DE
p_null                            00000350
parse_cmd                         000005D6
pascdig                           000003A8
pddigit                           00000388
pdigloop                          0000038A
print_dec                         00000358
print_hex1                        000003B4
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 58
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
SYMBOL TABLE
  LABEL                             VALUE 

print_hex2                        000003AC
print_sn                          000003F8
printf                            00000342
printf_loop                       00000346
printr0                           000003C0
printw                            000003BE
pw_room                           000003D0
pw_wait_txq                       000003C4
rd_eeprom                         00000570
rd_eepromw                        0000056E
rd_sram                           00000546
read_ver_flash                    0000065A
reccount_msg                      00000076
report_error                      00000334
run_msg                           00000122
rv_loop                           00000662
rw_sram                           0000054E
rxi_cr                            00000308
rxi_crlfdone                      0000031C
rxi_do_xoff                       00000322
rxi_do_xon                        00000328
rxi_done                          00000306
rxi_enqueue                       000002F8
rxi_lf                            00000310
rxi_service                       000002D4
s250_loop                         000005A6
s25_loop                          0000059A
same_row                          0000024C
sn_msg                            000000B6
sn_same                           0000077A
stall_1us                         0000003E
stall_250us                       000005A4
stall_25ms                        00000598
start_loader                      000005B0
test_esc                          000006E0
txi_service                       000002B8
unchanged_msg                     000000CE
verifyerr_msg                     0000006E
wait_escapes                      000006E4
wait_recstart                     00000206
wait_rxchr                        000005D0
wait_spi                          000005C8
wait_wre                          00000592
wait_xoff                         0000067A
wbyte_loop                        000006A4
wr_eeprom                         0000057A
wr_sram                           0000054A
wrid_loop                         0000070C
write_flash                       00000676
wrow_loop                         000006A0
wrsn_loop                         0000076E
yn_msg                            000000DA


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXX--XXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
01C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0280 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
MPASM  5.43                     18FKERNEL.ASM   1-25-2016  7:54:38         PAGE 59
EPROM Programmer Kernel Rev PIC18 1.00
Copyright (C) 2015 Martin Eberhard
MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


02C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0300 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0340 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0380 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
03C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0400 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0440 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0480 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
04C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0500 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0540 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0580 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
05C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0600 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0640 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0680 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
06C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0700 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0740 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXX--
0800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0840 : XXXX------------ ---------------- ---------------- ----------------
0000 : -XXX-XX-XXXXXX-- ---------------- ---------------- ----------------
0000 : XXXXXXXXXXXXXXXX XXXXXX---------- ---------------- ----------------

All other memory blocks unused.

Program Memory Bytes Used:  2017
Program Memory Bytes Free: 30751


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

